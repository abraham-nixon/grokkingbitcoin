[[answers]]
== Answers to exercises
:imagedir: {baseimagedir}/answers

=== Chapter 2

==== Cryptographic hash functions

1. 256 bits
2. 32 bytes
3. A cryptographic hash function
4. `061a` is `6*256 + (16+10) = 1536 + 26 = 1562` in decimal form. The
binary form of '06' is `0000 0110` and the binary form of `1a` is
`0001 1010` so the full binary representation is `0000 0110 0001
1010`.
5. No. If it was possible, the function would not be second-pre-image
resistant.
6. Property 2 and 4 are lacking:
7. Second-preimage-resistance is stopping the attacker. He needs to
find an input that gives the same hash as a certain other input, the
cat picture.

==== Digital signatures

1. The money supply increase rate will decrease over time because the
reward to Lisa halves every 4 years. This means that the total amount
of CT ever to be created is 21,000,000.
2. The coworkers have read-access to the spreadsheet. They can watch
the spreadsheet and verify that Lisa doesn't reward herself too much
or too often.
3. The private key is created using a random number generator of some
sort. A very simple one is a coin that you flip 256 times to generate
your 256 bit private key. You can also use your operating system's
built-in random number generator.
4. The private key.
5. The message is hashed because we want signatures to be small and
fixed in size. We don't want the signatures to be big just because the
signed message is big.
6. Mallory would need John's private key to steal cookies
from him. She would also need his name, John, to write into the email
to Lisa, but that's easily available in the spreadsheet.
7. Fred can use my public key to encrypt the message and send the
encrypted message to me. I can then decrypt that message using my
private key.
8. I sign the message using my private key and write the digital
signature onto the note in the bottle. Fred can then verify that the
signature is in fact made with my private key. He does that by using
my public key to decrypt the signature and compare the decrypted hash
with the actual hash of the message. If they match, he can be sure
that the message is from me.
9. The names in the spreadsheets act as identifiers for public keys,
we could instead skip the names and use public keys diretly in the
spreadsheet. We will do that in the next chapter. An email to Lisa
wouldn't have to contain any names and look something like this:

 Please more 10 CT from
 <my public key>
 to
 <recipient public key>
 Signature:
 <signature of above message made with my private key>

=== Chapter 3

1. The public key hash is made short because a) It makes the
spreadsheet smaller in size and b) it is shorter, and thus easier, to
write for a user.

2. No. She is very trustworthy. She will not tamper with the
spreadsheet.

3. Yes you can. There is a base58check decoding algorithm that does
that.

4. It's used by a payer to translate the recipient's address into a
public key hash. The payer needs to write the recipient's PKH in the
email to Lisa.

5. Let's base58 encode `0047` step by step:
  a. Remove leading `00` bytes. There is one, which leaves us with `47`
  b. Convert to decimal number: `47` in hex is `4*16+7=71` in decimal
  c. Divide by `71` by `58`: `71/58=1*58+13`. Quotient is `1`, remainder is `13`
  d. Divide quotient `1` by `58`: `1/58=0*58+1`. Quotient is `0`, remainder is `1`
  e. Lookup remainders `13` and `1`, result: `E` and `2`
  f. Add a '1' for the removed `00` byte in step a, which results in `E21`
  g. Reverse, `12E`. Done

6. The 4 byte checksum.

7. He must make two separate payments. For example: Payment 1 spends 2
CT from @~1~ and payment 2 spends 8 CT from @~2~.

8. Yes it is. Put the version byte `00` in front and base58check
encode them to get the addresses.

9. No, because the spreadsheet contains public key hashes. Since
cryptographic hash functions are one-way functions, you can't go from
public key hash to public key.

10. They can look at the amounts. Many of the 10 CT payments are
probably cookie purchases.

11. The bad guy cannot steal cookie tokens, because he needs the
public key in order to exploit the flaw in the public key derivation
function. The spreadsheet contains public key hashes, they can't get
the public key, see exercise 11.

12. The bad guy needs the private key in order to sign fraudulent
emails to Lisa. Eventhough he can reverse RIPEMD160, he'd still need
to pre-image attack SHA256 and reverse the public key derivation
function to get to a working private key.

=== Chapter 4

1. `bitcoin:155gWNamPrwKwu5D6JZdaLVKvxbpoKsp5S&amount=50`

2. Each character corresponds to 6 bits of entropy because 2^6^=64. 10 such characters make 60 bits of entropy, which corresponds to 60 coin flips.

3. Four problems:
  ** Passwords are easily forgotten
  ** Randomness is hard
  ** Security of a password decreases as technology improves
  ** You need to keep track of two items: The backup _and_ the
   password. This increases the risk that the backup is lost.

4. The seed is created by using a random number generator, for example a series of coin flips or the random number generator provided by your operating system.

5. An xprv consists of a private key and a chain code.

6. An xpub consists of a public key and a chain code.

7. The xprv at path `m/2/1` and the wanted index `7`.

8. No, you would need xprv `m/2/1` to derive xpub `M/2/1/7'`. You
first derive hardened xprv `m/2/1/7'` from `m/2/1` using hardnened
extended private key derivation and then calculate the xpub `M/2/1/7'`
from `m/2/1/7'`.

9. You can use this procedure to get the master xprv:
  .. Use master xpub `M` to derive xpub `M/4`.
  .. Use `M/4` to derive the left half hash at index 1.
  .. Subtract that left half hash from `m/4/1` to get private key `m/4`.
  .. Subtract the left half hash of `M/4` from `m/4` to get private key `m`.
  .. `m` together with the chain code of xpub `M` is the master xprv.

10. Yes, I'd be able to steal all funds in any addresses because I can
calculate the master xprv.

11. The victim could have used hardening to generate `m/4'`
instead. That way I wouldn't be able to get the master xprv. If I
stole `m/4'/1` and master xpub, I would only be able to steal funds on
the `m/4'/1` key. I would not be able to calculate the `M/4'` xpub.

12. The employees can import the extended public key for the counter
sales account. Then the employees will be able to generate any public
keys under that account, and thus generate as many addresses as they
need without ever having to know any private keys.

13. My (and Anita's) wallet can generate 10 addresses ahead of time
and monitor the spreadsheet for those addresses. If Anita gets paid on
one of these addresses, probably the first of those 10, then my wallet
wouldn't reuse that address when I request a payment from a
customer. I would instead take the next unused address.

=== Chapter 5

1. I would spend the 4 CT and the 7 CT outputs. The new outputs would
be 10 CT to the cafe and 1 CT in change to an address that I control.

2. They are used in inputs to reference transactions to spend outputs
from.

3. Because you can't spend part of a transansaction output. You either
spend the output or you don't. If the output contains more value than
you're paying, you need to give back change to yourself.

4. In the signature scripts in the inputs.

5. Because the verifiers need to know what public key to verify the
signature with. You can't verify the signature with a public key hash,
so you need to explicitly reveal the public key in the signature
script.

6. The signature scripts are cleaned so that verifiers don't have to know the order in which the inputs are signed. It's easier if all inputs are clean from signatures when signing.

7. Each output of a transaction contains a pubkey script. It contains
the second part of a script program. The first part will be provided
later when the output is spent.

8. The script program must end with "OK" on top of the stack.

9. A p2sh address always starts with a `3`. You can also recognize it
by base58 decoding it and looking at the first byte. If that byte is
`05` it's a p2sh address.

10. I'll create a transaction with one input and three outputs:
+
image::{imagedir}/ex-solution-10.svg[{full-width}]

11. 10,003 UTXOs. You remove two UTXOs by spending two outputs and you
add five new UTXOs. The net effect on the UTXO set is thus +3 UTXOs.

12. The pubkey script can be for example `1`. The spending input can
have an empty signature script. The full script program just puts a
`1` on the stack. A result stack with non-zero on top means "OK".

13. `OP_ADD 10 OP_EQUAL`. This will first add the two top items on the
stack and put the result back on top. Then we will push the number 10
to the stack and compare the two top items. If equal, "OK" will be
pushed to the stack.

14. I have to run a full node that verifies everything in the
spreadsheet from the very first transaction up to the transaction
containing my money from Faiza. I need to verify (among other things)
that:
+
* Lisa created the expected number of coinbase transactions with the correct amounts in them.
* for each transaction, the sum of outputs doesn't exceed the sum of
  inputs.
* All signatures from Faiza's payment back to all coinbase
  transactions are ok.

15. If there are several UTXOs to the same PKH, it means that as soon
as one of them is spent, the security of the other UTXOs to the same
PKH will be degraded. This is because we remove layer of security, the
cryptographic hash function. From that point we rely solely on public
key derivation function to be secure. Users can avoid that problem by
using unique addresses for all incoming payments. Then all UTXOs would
be for different public key hashes.
