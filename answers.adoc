[[answers]]
== Answers to exercises
:imagedir: {baseimagedir}/answers

=== Chapter 2

==== Cryptographic hash functions

1. 256 bits
2. 32 bytes
3. A cryptographic hash function
4. `061a` is `6*256 + (16+10) = 1536 + 26 = 1562` in decimal form. The
binary form of '06' is `0000 0110` and the binary form of `1a` is
`0001 1010` so the full binary representation is `0000 0110 0001
1010`.
5. No. If it was possible, the function would not be second-pre-image
resistant.
6. Property 2 and 4 are lacking:
7. Second-preimage-resistance is stopping the attacker. He needs to
find an input that gives the same hash as a certain other input, the
cat picture.

==== Digital signatures

1. The money supply increase rate will decrease over time because the
reward to Lisa halves every 4 years. This means that the total amount
of CT ever to be created is 21,000,000.
2. The coworkers have read-access to the spreadsheet. They can watch
the spreadsheet and verify that Lisa doesn't reward herself too much
or too often.
3. The private key is created using a random number generator of some
sort. A very simple one is a coin that you flip 256 times to generate
your 256 bit private key. You can also use your operating system's
built-in random number generator.
4. The private key.
5. The message is hashed because we want signatures to be small and
fixed in size. We don't want the signatures to be big just because the
signed message is big.
6. Mallory would need John's private key to steal cookies
from him. She would also need his name, John, to write into the email
to Lisa, but that's easily available in the spreadsheet.
7. Fred can use my public key to encrypt the message and send the
encrypted message to me. I can then decrypt that message using my
private key.
8. I sign the message using my private key and write the digital
signature onto the note in the bottle. Fred can then verify that the
signature is in fact made with my private key. He does that by using
my public key to decrypt the signature and compare the decrypted hash
with the actual hash of the message. If they match, he can be sure
that the message is from me.
9. The names in the spreadsheets act as identifiers for public keys,
we could instead skip the names and use public keys diretly in the
spreadsheet. We will do that in the next chapter. An email to Lisa
wouldn't have to contain any names and look something like this:

 Please more 10 CT from
 <my public key>
 to
 <recipient public key>
 Signature:
 <signature of above message made with my private key>

=== Chapter 3

1. The public key hash is made short because a) It makes the
spreadsheet smaller in size and b) it is shorter, and thus easier, to
write for a user.

2. No. She is very trustworthy. She will not tamper with the
spreadsheet.

3. Yes you can. There is a base58check decoding algorithm that does
that.

4. It's used by a payer to translate the recipient's address into a
public key hash. The payer needs to write the recipient's PKH in the
email to Lisa.

5. Let's base58 encode `0047` step by step:
  a. Remove leading `00` bytes. There is one, which leaves us with `47`
  b. Convert to decimal number: `47` in hex is `4*16+7=71` in decimal
  c. Divide by `71` by `58`: `71/58=1*58+13`. Quotient is `1`, remainder is `13`
  d. Divide quotient `1` by `58`: `1/58=0*58+1`. Quotient is `0`, remainder is `1`
  e. Lookup remainders `13` and `1`, result: `E` and `2`
  f. Add a '1' for the removed `00` byte in step a, which results in `E21`
  g. Reverse, `12E`. Done

6. The 4 byte checksum.

7. He must make two separate payments. For example: Payment 1 spends 2
CT from @~1~ and payment 2 spends 8 CT from @~2~.

8. Yes it is. Put the version byte `00` in front and base58check
encode them to get the addresses.

9. No, because the spreadsheet contains public key hashes. Since
cryptographic hash functions are one-way functions, you can't go from
public key hash to public key.

10. They can look at the amounts. Many of the 10 CT payments are
probably cookie purchases.

11. The bad guy cannot steal cookie tokens, because he needs the
public key in order to exploit the flaw in the public key derivation
function. The spreadsheet contains public key hashes, they can't get
the public key, see exercise 11.

12. The bad guy needs the private key in order to sign fraudulent
emails to Lisa. Eventhough he can reverse RIPEMD160, he'd still need
to pre-image attack SHA256 and reverse the public key derivation
function to get to a working private key.

=== Chapter 4

1. `bitcoin:155gWNamPrwKwu5D6JZdaLVKvxbpoKsp5S&amount=50`

2. Each character corresponds to 6 bits of entropy because 2^6^=64. 10 such characters make 60 bits of entropy, which corresponds to 60 coin flips.

3. Four problems:
  ** Passwords are easily forgotten
  ** Randomness is hard
  ** Security of a password decreases as technology improves
  ** You need to keep track of two items: The backup _and_ the
   password. This increases the risk that the backup is lost.

4. The seed is created by using a random number generator, for example a series of coin flips or the random number generator provided by your operating system.

5. An xprv consists of a private key and a chain code.

6. An xpub consists of a public key and a chain code.

7. The xprv at path `m/2/1` and the wanted index `7`.

8. No, you would need xprv `m/2/1` to derive xpub `M/2/1/7'`. You
first derive hardened xprv `m/2/1/7'` from `m/2/1` using hardnened
extended private key derivation and then calculate the xpub `M/2/1/7'`
from `m/2/1/7'`.

9. You can use this procedure to get the master xprv:
  .. Use master xpub `M` to derive xpub `M/4`.
  .. Use `M/4` to derive the left half hash at index 1.
  .. Subtract that left half hash from `m/4/1` to get private key `m/4`.
  .. Subtract the left half hash of `M/4` from `m/4` to get private key `m`.
  .. `m` together with the chain code of xpub `M` is the master xprv.

10. Yes, I'd be able to steal all funds in any addresses because I can
calculate the master xprv.

11. The victim could have used hardening to generate `m/4'`
instead. That way I wouldn't be able to get the master xprv. If I
stole `m/4'/1` and master xpub, I would only be able to steal funds on
the `m/4'/1` key. I would not be able to calculate the `M/4'` xpub.

12. The employees can import the extended public key for the counter
sales account. Then the employees will be able to generate any public
keys under that account, and thus generate as many addresses as they
need without ever having to know any private keys.

13. My (and Anita's) wallet can generate 10 addresses ahead of time
and monitor the spreadsheet for those addresses. If Anita gets paid on
one of these addresses, probably the first of those 10, then my wallet
wouldn't reuse that address when I request a payment from a
customer. I would instead take the next unused address.

=== Chapter 5

1. I would spend the 4 CT and the 7 CT outputs. The new outputs would
be 10 CT to the cafe and 1 CT in change to an address that I control.

2. They are used in inputs to reference transactions to spend outputs
from.

3. Because you can't spend part of a transansaction output. You either
spend the output or you don't. If the output contains more value than
you're paying, you need to give back change to yourself.

4. In the signature scripts in the inputs.

5. Because the verifiers need to know what public key to verify the
signature with. You can't verify the signature with a public key hash,
so you need to explicitly reveal the public key in the signature
script.

6. The signature scripts are cleaned so that verifiers don't have to know the order in which the inputs are signed. It's easier if all inputs are clean from signatures when signing.

7. Each output of a transaction contains a pubkey script. It contains
the second part of a script program. The first part will be provided
later when the output is spent.

8. The script program must end with "OK" on top of the stack.

9. A p2sh address always starts with a `3`. You can also recognize it
by base58 decoding it and looking at the first byte. If that byte is
`05` it's a p2sh address.

10. I'll create a transaction with one input and three outputs:
+
image::{imagedir}/ch05-ex-solution-10.svg[{full-width}]

11. 10,003 UTXOs. You remove two UTXOs by spending two outputs and you
add five new UTXOs. The net effect on the UTXO set is thus +3 UTXOs.

12. The pubkey script can be for example `1`. The spending input can
have an empty signature script. The full script program just puts a
`1` on the stack. A result stack with non-zero on top means "OK".

13. `OP_ADD 10 OP_EQUAL`. This will first add the two top items on the
stack and put the result back on top. Then we will push the number 10
to the stack and compare the two top items. If equal, "OK" will be
pushed to the stack.

14. I have to run a full node that verifies everything in the
spreadsheet from the very first transaction up to the transaction
containing my money from Faiza. I need to verify (among other things)
that:
+
* Lisa created the expected number of coinbase transactions with the correct amounts in them.
* for each transaction, the sum of outputs doesn't exceed the sum of
  inputs.
* All signatures from Faiza's payment back to all coinbase
  transactions are ok.

15. If there are several UTXOs to the same PKH, it means that as soon
as one of them is spent, the security of the other UTXOs to the same
PKH will be degraded. This is because we remove layer of security, the
cryptographic hash function. From that point we rely solely on public
key derivation function to be secure. Users can avoid that problem by
using unique addresses for all incoming payments. Then all UTXOs would
be for different public key hashes.

=== Chapter 6

1. By the previous block's block id, which is the hash of the previous
block's header.

2. The merkle root of a block commits to all transactions in that block.

3. Lisa's block signature commits to the previous block id, the merkle
root and the timestamp. This in turn commits to the whole blockchain
before this block and and all transactions in the block.

4. The first transaction in each block is a coinbase transaction. This
coinbase transaction creates 50 new cookie tokens. This will be cut in
half every four years, so after next halving, only 25 cookie tokens
will be created in each block.

5. All transactions. The hash functions will all result in an index
containing `1` because there are no zeroes in the bloom filter. Any
item in the transaction that we test will be a positive.

6. In the input we will test:
   * The txid together with the index that identifies the output to spend.
   * All data items in the signature scripts
   * All data items in the pubkey scripts
   * The txid of the transaction

7. They are not pre-image resistant, collision resistant or
second-preimage resistant. The outputs space is very small, typically
just a few hundered to a few thousand numbers. It will only take a
fraction of a second to find a pre-image of for example `172`.

8. The rightmost leaf must be copied to make an even number of
leaves. The same goes for the next level, where the third hash needs
to be copied.
+
image::{imagedir}/ch06-ex-solution-8.svg[{full-width}]

9. If Lisa's private block signing key is stolen the thief can start
double spending. Also if a bad guy replaces Lisa's block signing
public key on one or more sources, like the bulletin board or the
intranet, the bad guy can fool people in accepting blocks not signed
by Lisa.

10. Lisa can censor transactions and the shared folder administrator
can censor blocks.

11. a) Yes, a new node that downloads all blocks from the shared
folder will notice that there are two versions of the block. b) Yes,
an old node that has already downloaded the original block will detect
that there is an alternate version of the block.

12. The bits at indexes `1`, `5`, `6` and `7` are set to `1` and the
other to `0`. The full node would NOT send this transaction to the
full node. Nothing that is tested hashes to only `1`-bits. This was somewhat of a trick question, because the  is a 
+
image::{imagedir}/ch06-ex-solution-12.svg[{full-width}]

13. The partial merkle tree is:
+
 Number of tx: 3
 Flags: ✔✔✘✔✔✔
 Hashes 3 4 6

14. The interesting transactions are number 7 and 13, or leafs number
6 and 10 from the left. You have already seen the solution in
<<bigger-trees>>, but we provide it here as well for reference.

image::{imagedir}/ch06-ex-solution-14.svg[{full-width}]

[start=15]
15. You need to verify that
* the transaction's txid is in the list of hashes.
* the root of the partial merkle tree matches the merkle root in the block header.
* the block header is correctly signed.

=== Chapter 7

1. She single handedly decides what transactions get confirmed.

2. The probability of censorship will decrease because all miners must
decide to censor my transactions, otherwise my transactions will slip
through because some miner decides to confirm it.

3. Miners can cheat with random numbers. You can't prove whether a miner
cheated or not.

4. If the block id of a block is lower than the target in the block
header, and the target is the agreed upon target.

5. By repeatedly increasing the nonce and hash (double SHA256) the
block header until the block id (the block header hash) is lower than
the target.

6. The branch of the fork with most accumulated proof of work. This is
not neccesarily the same as the branch with most blocks.

7. A miner with hashrate 100 Mhash/s can perform 100,000,000 tries per
second to find a valid proof of work.

8. The target will decrease. If the 2016 blocks took 15 days instead
of the goal of 14 days, it means that it's too hard to find blocks, so
we need to increase the difficulty, which means decrease the target.

9. 50%. But if you plan to give up your try at some point, should
things not go as planned, your chances will decrease a bit.

10. The small block will reach the other miners more quickly than the
big block because a smaller block travels a computer network faster
than a big block. The small block is probably also quicker to verify
than the big block. Miners will probably download and verify the small
block faster than the big block and continue their mining activity on
top of the small block, which gives the small block a higher
probability of becoming part of the strongest chain.

11. The target will decrease by a factor 3/4. The time to produce 2016
block is 1.5 weeks, the first 1008 blocks takes 1 week and the next
1008 weeks takes 0.5 weeks. So the new target becomes

[stem]
++++
new\ target=old\ target*\frac{1.5\ weeks}{2\ weeks}=old\ target*\frac{3}{4}
++++

[start=12]
12. Selma has the majority of the hash rate. As long as she plays by
the same rules as everyone else, she's going to earn a lot of block
rewards. When she breaks the rules by changing the target prematurely,
all full nodes, except Selma's, will discard her blocks. Selma will
continue working on her own branch of the blockchain with her new
rules, while all the rest will work on the branch with the old
rules. The branches will be mutually incompatible. The hashrate of the
old branch will drop to 48%, but the system ticks on and everyone
continues their daily lives as normal. Selma, on the other hand, will
spend a lot of electricity and time on her new branch and no one will
buy her block rewards. The value of her mined coins will probably drop
dramatically since they are not following the consensus rules. Selma
is a loser.

13. The "fee per byte" metric used by most miners will be
very low. For every byte of transaction data the miner puts in its
block it will loose a little competitiveness because the block will
get bigger and thus slower to transport over the network and to
verify. If the fee per byte for the transaction isn't high enough to
compensate for the lost competitiveness, the miner will probably not
include it.
