[[ch02]]
== Digital signatures - Securing cookie tokens
:imagedir: {baseimagedir}/ch02
This chapter covers

* Creating a simple money system, Cookie Tokens
* Understanding cryptographic hashes
* Authenticating payments using digital signatures
* Keeping your secret codes secret

We will start the chapter by setting the stage for the rest of this
book. We will describe a very simple payment system that we will
improve upon using Bitcoin technologies. By the end of this book the
simple system will have evolved into what we call Bitcoin.

The only fundamental technical skill you need in order to start
learning Bitcoin is cryptographic hashes. Cryptographic hashes are so
important to Bitcoin that you really need to understand them before
starting to learn anything else. The second section of this chapter
will teach you what you need to know about cryptographic hashes.

The rest of the chapter will solve the problem of the imposter,
someone claiming to be someone else to pay money from that someone's
account. We solve that by introducing digital signatures to the simple
system.

.Digital signatures in Bitcoin 
image::{imagedir}/visual-toc-digital-signatures.svg[{big-width}]

=== The cookie token spreadsheet

Suppose that there is a cafe in the office where you work. You and
your coworkers use a spreadsheet to keep track of "cookie
tokens", CT. Cookie tokens can be exchanged for cookies in the cafe.

[.inbitcoin]
.Bitcoin, the currency
****
A cookie token correspond to a bitcoin, the currency unit of
Bitcoin. Bitcoin got its first price point 2010 when someone bought
two pizzas for 10000 BTC. That money would get you 500000 pizzas
today.
****

.The spreadsheet have a column for the sender, a column for the recipient and a column for the amount of cookie tokens transferred. New cookie token transfers are appended at the end of the spreadsheet.
image::{imagedir}/cookie-sheet-basic.svg[{half-width}]

This spreadsheet is stored on Lisa's computer. The spreadsheet is
shared read-only for everybody on the office network to open and
watch, except Lisa. Lisa is very trustworthy. Everybody
trusts her. She has full access to do whatever she likes with the
spreadsheet. You and all the others can only view the spreadsheet by
opening it in read-only mode.

Whenever Alice wants a cookie, she asks Lisa, who sits right next to
the cafe, to transfer 10 tokens from her to the cafe. Lisa knows who
Alice is and can verify in the spreadsheet that she owns enough cookie
tokens. She will search for 'Alice' in the spreadsheet and sum all the
amounts with Alice's name in the "To" column and subtract all the
amounts with Alice's name in the "From" column. Here is the complete
search result, there are three transfers, involving Alice:

.Lisa calculates Alice's balance. The sum of her received CT is 100 and the sum of her withdrawn CT is 30. Alice's balance is 70 CT.
image::{imagedir}/alices-transfers-in-cookie-sheet.svg[{big-width}]

Lisa calculates that Alice has 70 CT. That is enough for Alice to pay 10
CT to the cafe. She appends a row at the end of the spreadsheet:

image::{imagedir}/alice-buys-cookie.svg[{half-width}]

The cafe sees this new row in the spreadsheet and hands over a cookie
to Alice.

[.gbinfo]
.Earn them
****
You may also get cookie tokens as part of your salary.
****

When you run out of cookie tokens, you can buy tokens for dollars from
someone who has an excessive amount of cookie tokens, possibly Anne or
the cafe, at a price you both agree on. Lisa will then add a row to the
spreadsheet accordingly. Lisa have promised never to remove or change
anything in the spreadsheet, just add to it. What happens in the
spreadsheet, stays in the spreadsheet!

[.inbitcoin]
.Money supply curve
****
Bitcoin use the same schedule for issuance as the cookie token
spreadsheet. All new bitcoins are created as rewards to the nodes
securing the Bitcoin ledger, the blockchain, just as Lisa is rewarded
for securing the cookie token spreadsheet.

image::{imagedir}/2ndcol-money-supply.svg[]
****

Lisa, who is performing valuable work to secure this money system, is
rewarded with 7200 newly minted cookie tokens per day. Every day, she
adds a new row to the spreadsheet, that creates 7200 new CT with Lisa
as the recipient.

image::{imagedir}/lisa-is-rewarded.svg[{half-width}]

This is how all the cookie tokens in the spreadsheet are created. The
very first row in the spreadsheet is a reward row like the one above
that creates the very first 7200 CT ever. The plan is that Lisa is
rewarded 7200 cookie tokens per day during the first four years, and
then the reward is halved to 3600 CT/day for the next four years, and
so on until the reward is 0 CT/day. Let's not worry, for now, about
what happens when the reward approaches 0, that's far in the
future. We will discuss that in <<ch07>>. This reward halving
makes the total money supply, the total amount of CT in circulation,
approach 21000000 CT, but it will never exceed 21000000. What Lisa
does with the new cookie tokens she earned is up to her. She can buy
cookies or sell the cookie tokens. She can also save them for later.

The spreadsheet system works quite well and everybody eats a healthy
amount of cookies.

Lisa basically performs the same work as miners in the Bitcoin
network. She verifies payments and updates the ledger, the Bitcoin
blockchain. Let's make it clear how the concepts in the spreadsheet
corresponds to concepts in Bitcoin:

[%autowidth,options="header"]
.How key ingredients of the cookie token system and the Bitcoin system relates.
|===
| Cookie Tokens | Bitcoin | Covered in
| 1 cookie token | 1 bitcoin | <<ch02>>
| The spreadsheet | The blockchain | <<ch06>>
| A row in the spreadsheet | A transaction | <<ch05>>
| Lisa | A miner | <<ch07>>
|===

This table will follow us throughout the book. It describes
differences between the cookie token system and Bitcoin. We will
delete rows from it as we introduce various Bitcoin stuff. For
example, The row "The spreadsheet" will be deleted in <<ch06>> when we
use a blockchain to store transactions. We will also add a few rows as
we introduce new concepts for the cookie token system that does not
exist in Bitcoin.

At the end of <<ch08>> this table will only contain the first row,
mapping 1 cookie token to 1 bitcoin. That will mark the end of this
cookie token example, and from that point we will only talk about
Bitcoin itself.

This is our starting point for learning how Bitcoin works. We call
this version 1.0 of the cookie token spreadsheet system:

[%autowidth,options="header"]
.Release notes, cookie tokens 1.0
|===
|Version|Feature|How

.2+|image:{commonimagedir}/new.png[role="gbnew"]*1.0*
|Simple payment system
|Relies on Lisa being very trustworthy and knowing everyone's face
|Finite money supply
|7200 New CT rewarded to Lisa daily, halves every four years.
|===

We will add a lot of fancy stuff to this system and a new version will
be released in every chapter. For example, at the end of this chapter
we will release version 2.0 that solves the problem of the imposter
using digital signatures. Every chapter will take us closer to the end
result, Bitcoin.

[id=cryptographic_hashing]
=== Cryptographic hashes

Cryptographic hashes are used all over the place in Bitcoin. Trying to
learn Bitcoin without knowing what cryptographic hashes are, is like
learning chemistry without knowing what an atom is.

You can think of a cryptographic hash as a fingerprint. A person will
produce the same fingerprint of her left thumb every time it is taken,
but it is extremely hard to find another person with the same left
thumb fingerprint. The fingerprint does not disclose any information
about the person other than her left thumb fingerprint. You cannot
know what math skills she has or what eye color she has by looking at
her fingerprint.

A fingerprint of a file is called a cryptographic hash. To create a
cryptographic hash of a file, you send the file into a computer
program called a _cryptographic hash function_. Suppose that you want to
create a cryptographic hash, a fingerprint, of your favorite cat
picture.

[.gbinfo]
.Bits? Bytes? Hex?
****
A _bit_ is the smallest unit in a computer. It can take two different
values, 0 or 1. Like a light bulb, it can be either on or off. A
_byte_ is eight bits, that together can take 256 different values. We
often use _hexadecimal_, or _hex_, encoding when we display numbers in
this book. Each byte is printed as two hex digits each in the range
0-f where a=10 and f=15.

image::{imagedir}/bits-bytes-hex.svg[]
****

.Creating a cryptographic hash of a cat picture. Input is the cat picture and output is a big number of 32 bytes.
image::{imagedir}/hashing-a-cat.svg[{big-width}]

The hash in the picture is a 256 bit number. 256 bits equals 32
bytes. It means that to store the number in a file, the file will be
32 bytes big, which is tiny compared to the size of the 1.21 Megabytes
cat picture.

The word "hash" means something that is chopped into small pieces or
mixed up. It is actually a very good description of what a
cryptographic hash function does. It takes the cat picture and
performs a mathematical calculation on it. Out comes a big number that
does not remotely look like a cat. You cannot "reconstruct" the cat
picture from just the hash, a cryptographic hash function is a
_one-way function_. Let's see what happens when you change the cat
picture just a tiny bit and run that cat picture through the same
cryptographic hash function:

.Hashing a modified cat picture. Can you spot the difference? The cryptographic hash function certainly did.
image::{imagedir}/hashing-a-modified-cat.svg[{big-width}]

This hash turns out completely different than the first hash. Let's
compare them:

 Old hash: dee6a5d375827436ee4b47a930160457901dce84ff0fac58bf79ab0edb479561
 New hash: d2ca4f53c825730186db9ea585075f96cd6df1bfd4fb7c687a23b912b2b39bf6

See how that tiny change to the cat picture made a huge difference in
the hash value?

==== Why are cryptographic hash functions useful?

Cryptographic hash functions can be used as an integrity check, to
detect changes in data. Suppose that you want to store your favorite
cat picture on your laptop's hard drive, but you suspect that the
picture may become corrupt on the hard drive. This could happen for
example due to disk errors or by hackers. How can you make sure that
you detect corruption?

First, you calculate a cryptographic hash of the cat picture on your
hard drive and write it down on a piece of paper.

.Save a hash of the cat picture on a piece of paper
image::{imagedir}/integrity-check-1.svg[{half-width}]

Later, when you want to look at the picture, you can make sure that
the picture hasn't changed. Calculate the cryptographic hash of the
cat picture again and compare it to the original hash on your paper.

.Check the integrity of the cat picture. You detect a change.
image::{imagedir}/integrity-check-2.svg[{big-width}]

[.gbfaq]
.Extremely sure?
****
There is a tiny chance that the cat picture has changed even thought
the hashes match. But as we will see later, that chance is so small it
can be ignored.
****

If the new hash matches the one on paper, you can be extremely sure
that the picture hasn't changed. On the other hand if the hashes don't
match, the cat picture has definitely changed.

Cryptographic hashes are used a lot in Bitcoin to verify that data
hasn't changed. For example, every now and then, on average every 10
minutes, the whole history of all Bitcoin transactions is hashed. If
the data changes, it will be noticed by anyone verifying the data.

==== How does a cryptographic hash function work?

The real answer is very complex, so we will not go there. But to help
you understand the operation of a cryptographic hash function, we will
create a very simplistic cryptographic hash function. Well, it is not
really cryptographic, we will come to that later. Let's just call it a
hash function for now.

[.gbinfo]
.Modulo
****
Modulo means to wrap around when a calculation reaches a certain
value. For example:

 0   mod 256 = 0
 255 mod 256 = 255
 256 mod 256 = 0
 257 mod 256 = 1
 258 mod 256 = 2

`258 mod 256` is the remainder of the integer division `258/256`: `258 =
1*256 + 2`. The remainder is `2`.
****

Suppose that you want to hash a file containing the six bytes `a1 02
12 6b c6 7d`. You want the hash to be a one byte number, 8 bits. We
can construct a hash function using _addition modulo 256_, which means
to wrap around to 0 when the result of an addition reaches 256:

.Simplistic hash function using byte-wise addition modulo 256.
image::{imagedir}/simplistic-hash-algorithm.svg[{half-width}]

The result is the decimal number 99. What does 99 say about the
original input `a1 02 12 6b c6 7d`? Not much. 99 looks just as random
as any other single byte number.

If you change the input, the hash will change, even though there is a
chance that the hash will remain 99. After all, there are just 256
different possible outputs of this simple hash function. With real
cryptographic hash functions, as the one we used to hash the cat
picture, the chance is unimaginably small. We will soon get a glimpse
of that probability.

==== Properties of a cryptographic hash function

A cryptographic hash function is a function that takes any digital
input data and produces a fixed-length output. In the example with the
emailed cat picture, the input is the cat picture of 1.21 MB and the
output is a 256 bit number. The function will output the exact same
hash each time the same input is used. But it will output a totally
different value when even the slightest variation of the input is
used. The output of a cryptographic hash function is often referred to
as a _hash_ or a _digest_. I am using term _hash_ here, but either
is equally valid.

.Cryptographic hash functions
****
Some cryptographic hash functions are not considered cryptographically secure any more.
|===
| Name | Bits | OK?

| SHA256 | 256 | Yes
| SHA512 | 512 | Yes
| RIPEMD 160 | 160 | Yes
| SHA-1 | 160 | No
| MD5 | 128 | No
|===
****
Let us have a look at what properties you can expect from a
cryptographic hash function. We will illustrate the properties using
the SHA256 (Secure Hash Algorithm with 256 bit output) algorithm,
because it is the one that Bitcoin uses the most. There are several
different cryptographic hash functions, but they all provide the same
basic properties:

. The same input will always produce the same hash.
. Slightly different inputs will produce very different hashes.
. The hash is always of the same fixed size. For SHA256 it is 256
  bits.
. Trial-and-error is the only known way to find an input that gives a
certain hash.

.A cryptographic hash function, SHA256, in action. The input "Hello!" will give you the same output every time, but the slightly modified input "Hello" will give you a totally different output.
image::{imagedir}/cryptographic_hashing.svg[{big-width}]

[.inbitcoin]
.Double SHA256
****
We most often use double SHA256 in Bitcoin:

image::{imagedir}/2ndcol-double-sha256.svg[]
****

The first three properties are illustrated in the diagram above. The
fourth property of cryptographic hash functions is what makes it a
_cryptographic_ hash function and this needs a bit more
elaboration. There are some variations to the fourth property, all of
which are desirable for cryptographic hash functions:

.Different desirable properties for cryptographic hash functions. For collision resistance, X can be anything, as long as the two inputs give the same output X.
image::{imagedir}/hash-properties.svg[{big-width}]

Collision resistance:: It's hard to find two different inputs that
give _the same_ hash.
Preimage resistance:: It's hard to find an input that gives _a
certain_ hash.
Second-preimage resistance:: It's hard to find an input that gives
_the same hash as a certain other input_.

==== Illustration of "hard"

The term "hard" in this context means astronomically hard. It is
silly to even try. We will have a look at second-preimage resistance
as an example of what "hard" means, but a similar example can be
made for any of the three variants.

.Second preimage resistance
****
image::{imagedir}/2ndcol-second-preimage.svg[[]
****

Suppose that you want to find an input to SHA256 that results in the
same hash as `Hello!`:

 334d016f755cd6dc58c53a86e183882f8ec14f52fb05345887c8a5edd42c87b7

There is no way to change the input just a little bit so that the
function "won't notice". It will notice and output a totally different
hash. The only way to find an input, other than `Hello!`, that gives
the hash
`334d016f755cd6dc58c53a86e183882f8ec14f52fb05345887c8a5edd42c87b7` is
to try different inputs one by one and check if it produces the
desired hash.

Let's try.

.Finding an input with the same hash as "Hello!". Nearly impossible.
[options="header,nowrap",cols="2l,3l,3m",subs=verbatim]
|===
| Input | Hash | Success?
| Hello1! | 82642dd9...2e366e64 | nope 
| Hello2! | 493cb8b9...83ba14f8 | nope
| Hello3! | 90488e86...64530bae | nope 
| ... | ... | nope, nope, ..., nope
| Hello9998! | cf0bc6de...e6b0caa4 | nope 
| Hello9999! | df82680f...ef9bc235 | nope 
| Hello10000! | 466a7662...ce77859c | nope
a| image:{imagedir}/grumpy-cat-drawing.jpg[{thumb}] | dee6a5d3...db479561 | nope
| My entire music collection | a5bcb2d9...9c143f7a | nope
|===

[.gbfaq]
.How big is 2^256^?
****
2^256^ is about 3*10^77^ which is almost the number of atoms in the
universe. To find a preimage to SHA256 is like picking an atom in the
universe and hope it's the correct one.
****

As you can see, we are not very successful. Let us think about how
much time it would take for a typical desktop computer to find such an
input. It can calculate about 60 million hashes per second and the
expected number of tries needed to find a solution is 2^255^. The
result is 2^255^ / (60*10^6^) s ≈ 10^68^ s ≈ 3*10^61^ years, or
about

 30000000000000000000000000000000000000000000000000000000000000 years

I think we can stop trying, don't you? I don't think buying a faster
computer will help either. Even if we had 1 trillion computers and ran
them concurrently it would take about 3*10^49^ years.

Preimage resistance, second-preimage resistance and collision
resistance are extremely important in Bitcoin. Most of its security
relies on these properties.

==== Summary

.Can't figure out input
****
image::{imagedir}/preimage-resistance.svg[]
****

A cryptographic hash function is a computer program that takes any
data as input and computes a big number, a cryptographic hash, based
on that input.

image::{imagedir}/cryptographic_hashing.svg[{big-width}]

It is astronomically hard to find an input that will result in a
specific output. This is why we call it a one-way function. You have
to repeatedly guess different inputs.

===== Our toolbox

.Toolbox
****
image::{imagedir}/toolbox-cryptographic-hash-function.svg[]
****

We will discuss several important topics throughout this book. When you
have learned about a specific topic, like cryptographic hash
functions, we will put a new tool into our toolbox for later use.

Our first tool to put into the toolbox is the cryptographic hash function.

.Our first tool. The cryptographic hash function is represented by a paper shredder, and the cryptographic hash is represented by a pile of paper stripes.
image::{imagedir}/tool-cryptographic-hash-function.svg[{half-width}]

From now on we will use the paper shredder to represent a
cryptographic hash function. A pile of paper stripes will represent a
cryptographic hash. The text on the shredder tells what kind of
cryptographic hash function we use. You will learn about a few other
cryptographic hash functions later in the book as we need them.

==== Exercises

===== Warm up

. How many bits is the output of SHA256?
. How many bytes is the output of SHA256?
. What is needed to calculate the cryptographic hash of the text "`hash me`"?
. What is decimal and binary representations of the hexadecimal data `a109`?
. Can you modify the text "`cat`" so that the modified text gets the
same cryptographic hash as "`cat`"?

===== Dig in

[start=6]
. Our simplistic hash function from the section <<cryptographic_hashing>>
is not a _cryptographic_ hash function. Which two of the four properties
of a cryptographic hash function is it lacking?
+
image::{imagedir}/simplistic-hash-algorithm-exercise.svg[{half-width}]

. The paper shredder in our toolbox is not a perfect analogy. Can you
tell why? What properties of a cryptographic hash function does the
shredder lack? Short on better analogies, we will stick to using the
shredder to denote a cryptographic hash function.

=== Digital signatures

****
image::{imagedir}/2ndcol-physical-vs-digital-signature.svg[]
****

This part of <<ch02>> explores how you can prove to someone that you
approve a payment. To do that, we use _digital signatures_. A digital
signature is a digital equivalent of a hand written signature. The
difference is that a hand written signature is tied to a person, while
a digital signature is tied to a random number called a private key. A
digital signature is much harder to forge than a hand written
signature.

==== Typical use of digital signatures





Suppose that you want to send your favorite cat picture to your friend
Fred via email, but you suspect that the picture may be, maliciously
or accidentally, corrupted during transfer. How would you and Fred
make sure that the picture Fred receives is exactly the same as the
one you send?

You can include a _digital signature_ of the cat picture in the
email. Fred can then verify this digital signature to make sure that
the cat picture is authentic. This is done in three different phases:

.You send a digitally signed cat picture to Fred. Fred verifies the signature to make sure that he's got the same cat as the cat you signed.
image::{imagedir}/signing-overview.svg[{big-width}]

Step 1 is preparation. You create a huge random number, that we call a
_private key_. This private key can be used to create digital
signatures. You then create the _public key_ that can be used to
verify the signatures created by the private key. The public key is
_calculated_ from the private key. You hand the public key to Fred in
person so that Fred is sure that the public key belongs to you.

Step 2 is signing. You write an email to Fred and attach the cat
picture. You also use your private key and the cat picture to
digitally sign the cat picture. The result is a _digital signature_
that you include in your email. Send the email to Fred.

Step 3 is verifying. Fred receives your email, but he is concerned
that the cat picture might be corrupt, so he wants to verify the
signature. He uses your public key that he got from you in step 1, the
digital signature in the email and the attached cat picture. If any of
the signature or the cat picture has changed since you created the
signature, the verification will fail.

==== Improving cookie token security

It's time to move back to our cookie token spreadsheet. The company is
doing well and grows rapidly. After a while Lisa has a hard time
recognizing everyone. She notices that some people are not honest. For
example Malory says that she is Anne, to trick Lisa into moving cookie
tokens from Anne to the cafe, instead of from Malory to the cafe.

****
image:{imagedir}/note-to-lisa.svg[]
****

Things are getting out of hand, so Lisa thinks out a great plan. She
is going to require everybody to _digitally sign_ their cookie token
transfers, by writing a message and a _digital signature_ in an email.

Suppose that there is a new guy at the office, John. The company has
given him some CT as a welcome gift when he started. Now John wants to
buy a cookie in the cafe for 10 CT. He needs to digitally sign a
cookie token transfer. This is what he has to do:

.The digital signature process. 1. John creates a keypair and gives the public key to Lisa. 2. John signs a message with the private key. 3. Lisa verifies that the message is signed with the private key belonging to the public key she got from John.
[[generate-key-pair]]
image::{imagedir}/generate-key-pair.svg[{big-width}]

Just as with the email to Fred in the previous section, there are three
phases in this process.

[.gbinfo]
.Key pair reuse
****
A key pair is created once. The same private key can be used several
times to digitally sign stuff. We will see later why this is not
always a good idea for privacy and security reasons.
****

. John prepares by generating a key pair. The private key is kept
secret by John, and the public key is handed over to Lisa. This is a
one-time setup step.
. John wants a cookie. He writes a message and signs it with his
private key. He gives the message and the digital signature to Lisa.
. Lisa verifies the signature of the message using Johns public key
and updates the spreadsheet.

==== Preparation: John generates a key pair

The signing and validation process is based on a pair of a private key
and a public key. John needs a private key in order to sign payments
and Lisa will need John's public key in order to verify John's
signatures. John needs to prepare for this by creating a key pair. The
key pair is created by first generating a private key and then
calculate the public key from that private key.

.John creates a key pair. The private key is a huge random number and the public key is derived from that random number. John stores his private key on his hard drive and the public key is handed to Lisa.
image::{imagedir}/create-keypair.svg[{big-width}]

.One-way
****
image:{imagedir}/2ndcol-key-derivation-one-way.svg[]
****

John will use a random number generator to generate a huge, 256 bit,
random number. This random number is now John's private key. The
private key is then transformed into a public key using a public key
derivation function. The public key derivation function is a one-way
function, just as the cryptographic hash functions discussed
earlier. You can not derive the private key from the public key. The
security of digital signatures relies heavily on this feature.

How the public key derivation function works is a hard topic covered
in <<ch04,chapter 4>>. Luckily, you do not have to be a cryptography expert to
understand how digital signatures works from a user's perspective.

===== Two ways to use the key pair

Keys are used to encrypt and decrypt data. Encryption is used to make
messages unreadable to everybody but the ones that hold the proper
decryption key.

The private and public keys are thought of as a pair because they have
a very strong relationship; The public key can be used to encrypt
messages that only the private key can decrypt. It also works the
other way around, the private key can encrypt messages that can only
be decrypted by the public key.

[[enc-dec-public-private]]
.Encrypting and decrypting with the public and private keys. Left: Encrypt with the public key and decrypt with the private key. Right: Encrypt with the private key and decrypt with the public key.
image::{imagedir}/enc-dec-public-private.svg[{half-width}]

[.gbinfo]
****
We will use the right side to make digital signatures. We will not use
the left side at all in this book.
****

In the left side of <<enc-dec-public-private>>, only John would be
able to read the encrypted message because he is the only one with
access to his private key. This feature of public and private keys is
not used in Bitcoin at all. It is used when two parties want to
communicate in private. This is what's used when you do your online
banking for example. When you see the little padlock in the address bar
of your web browser, then you know that left side of the figure is
used to secure your communication.

In the right side of the figure, Lisa can decrypt the message because
she has the public key belonging to Johns private key. It is not good
practice to use the private key to encrypt messages, as in the right
side of the diagram, because the public key is, well, public. When
John hands his public key to Lisa, someone might overhear the
conversation, or Lisa might leave her table with public keys open on
her computer screen. And that's okay. The public key is not
secret. That is why it is a bad idea to encrypt a message with the
private key and expect the message to be secret.

The right side is instead used to make digital signatures.

===== Locked box example

To illustrate the relationship between the private and the public
keys, imagine a box with a lock. The lock has three states: Left
(locked), Up (unlocked), and Right (locked).

image::{imagedir}/locked-box-overview.svg[{half-width}]

There are two keys to this lock, one key can only turn the lock to the
right, clockwise, and the other key can only turn the lock to the
left, counterclockwise.

Let's assume that John selects the right-only key to be his
private key. The left-only key is then his public key. He could chose
either one of them to be the private key, it does not matter. He makes
several copies of the public key and hands them out to Lisa, Ellen and
a bunch of other people. He keeps the private key to himself in his
pocket.

====== Encrypt and decrypt

Ellen can now encrypt a secret message to John. She writes a note with
the secret message

 Hey, your zipper is down

.Encrypt/decrypt
****
.Ellen encrypts with public key
image::{imagedir}/locked-box-locked-left.svg[]
.John decrypts with private key
image::{imagedir}/locked-box-unlocked-private.svg[]
****

and puts it in the box, closes the box and locks it with her copy of
the public key. The public key only turns to the left, so when she is
done the lock is in its leftmost position. The box is now locked. To
open the box you need a key that can turn the lock to the right. Only
John's private key can do that. None of the copies of the public key
will help, because they can only turn to the left.

John, who is the only one with the private key, can now use his
private key, that only turns right, to unlock the box and read the
secret message. He is confident that the message has not been read by
anyone else during its time in the box, because he has had his private
key in his pocket all the time. He gently turns around and zips up.

We have just witnessed the left side process of
<<enc-dec-public-private>>:

.Ellen encrypts a message that only John can read.
image::{imagedir}/encrypt-decrypt.svg[{half-width}]

====== Sign and verify

The above was an illustration of the encryption feature of public and
private keys. But while John was able to read the secret message from
Ellen, he could not tell _who_ wrote the message. Anyone with a copy
of the public key could have done that.

But this box has another great feature. It can be used by John to
write a message that anyone with the public key can read and be
absolutely sure that it was John who wrote the message. This is an
example of a digital signature.

.Sign/verify
****
.Signed by John
image::{imagedir}/locked-box-locked-right.svg[]
.Verified by Ellen
image::{imagedir}/locked-box-unlocked-public.svg[]
****

Say that John wants to send the message

 Lisa, please move 10CT to Cafe. /John

to Lisa. John gave Lisa his public key, that only turns left, in the
previous section, so Lisa knows that this public key belongs to Johns
private key. John writes the message on a note and puts it in the
box. He closes the box and locks it with his private key, that only
turns right. When he is done, the box is locked in the rightmost
position. Everyone knows how this box works, so everyone is aware that
only the private key can lock the box in this way, because only the
private key can turn the lock to the right.

Lisa can now use her copy of the public key to unlock the box by
turning it left one step to the upright, unlocked, position. She takes
out the note and reads it. She knows for sure that John put this
message in the box, because he is the only person with the
private key. Lisa can now trust that the message is from John and move
10 cookie tokens from him to the cafe.

This is an analogy of digital signatures, and analogies are seldom
perfect. It should be taken with a grain of salt, because the
signature can only be verified by one person in this analogy. A real
digital signature can be verified multiple times by multiple persons
with a copy of the public key.

The signing process uses the right side of the diagram in
<<enc-dec-public-private>>:

.John signs with his private key and Lisa verifies with Johns public key. She now knows for sure that John wrote this message.
image::{imagedir}/sign-verify.svg[{half-width}]

==== Recap on key pairs

Let's summarize what we have learned about public and private keys.

A key pair is created by first creating a private key. The private key
is a huge secret random number. The public key is then calculated from
the private key.

image::{imagedir}/recap-keys-create.svg[{big-width}]

The private key can be used to encrypt a message that can be decrypted
only by using the public key, and vice versa.

image::{imagedir}/recap-keys-sign-verify.svg[{half-width}]

The encryption and decryption in the figure above is the foundation
for digital signatures. This process is *not* suitable to send secret
messages because the public key is usually widely known.

The reverse process is also common where the public key is used to
encrypt and the private key is used to decrypt. This process is used
to send secret messages. It is not used in Bitcoin.

==== Where were we?

****
image::{commonimagedir}/periscope.gif[]
****

Digital signatures were briefly mentioned in <<ch01>>, where Alice's
Bitcoin transaction of 1 bitcoin to Bob were signed by Alice using her
private key.

.Digital signatures in Bitcoin
image::{imagedir}/periscope-digital-signatures.svg[{half-width}]

John has created a pair of keys and is about to digitally sign his
payment to the cafe with his private key so that Lisa can verify that
it's actually John who makes the payment. Lisa verifies this using
John's public key.

==== John signs his payment

Let's have a close look at how the signing really happens.

.John digitally signs the transfer of 10 CT to the cafe. The message to Lisa is first hashed and then encrypted with John's private key. The note to Lisa contains both the message in clear text and the signature.
image::{imagedir}/signing-details.svg[{big-width}]

[.inbitcoin]
.Signatures in Bitcoin
****
Bitcoin use this type of signature for most Bitcoin payments
today. But it is not the only way to authenticate a payment.
****

The message that John wants to sign is "Lisa, please move 10CT to
Cafe. /John". The signing function will hash this message with SHA256
whose output is a 256 bit number. This hash value is then encrypted
with John's private key. The result is a string that looks like
garbage:

 INxAs7oFDr80ywy4bt5uYPIv/09fJMW+04U3sJUfgV39
 A2k8BKzoFRHBXm8AJeQwnroNb7qagg9QMj7Vp2wcl+c=

This is the signature. If John would have used another private key or
a slightly different message as input, the signature would have looked
completely different. For example, using the input message "Lisa,
please move 10CT to Malory. /John" would generate this signature:

[.gbminiex]
.Why different?
****
Can you tell why the signature looks completely different.
****

 IBkECIzYrfw6pEEdAUbDpD32rq481j6h5a7UrEYG6BBz
 dmZmsFAtT+cvXTZbpwC76/gMES9DCcS5ArjhCDjwbq8= 

This is not even remotely similar to the previous signature. This is
good to know for John, as he knows that his signature cannot be used
for other messages than his intended message. We will talk more on
that in the next section where Lisa verifies the signature.

****
image::{imagedir}/note-to-lisa.svg[]
****

The last thing that John does is to compose a note to Lisa and give it
to her.

==== Lisa verifies the signature

Lisa does not recognize John. She looks at the note and sees that the
note claims to be from John, so she looks up John in her table of
public keys.

.Lisa uses the message (1), the signature (2) and John's public key (3) to verify that the message is actually signed with John's private key.
image::{imagedir}/verify-signature.svg[{big-width}]

The purpose of Lisa's actions in this picture is to determine that the
cookie token transfer was signed by the private key it claims to be
signed with. The message _says_ it is from John. She did receive Johns
public key the other day and she put the public key in her table of
public keys. The things she has at hand is

. The message "Lisa, please move 10CT to Cafe. /John"
. The Signature `INxAs7oFDr8...`
. Johns public key that she just looked up in her table

.A signature is an encrypted hash
****
image::{imagedir}/2ndcol-encrypted-hash.svg[]
****

John encrypted the hash of the message with his _private_ key. This
encrypted hash is the signature. So if Lisa decrypts the signature (2)
with John's _public_ key (3), the result should be the same hash.

Lisa takes the signature (2) and decrypts it with the public key (3)
she looked up in her table of public keys. The decryption outputs a
big number. If this number is equal to the hash of the message (1), it
proves that John's private key was used to sign the message. Lisa
takes the message (1), exactly as written, and hashes that message
just like John did when he created the signature. This message hash is
then compared with the decrypted signature. The message hash and the
decrypted signature match.

Lisa can now be sure that no one is trying to fool her. She updates
the spreadsheet with John's transfer:

.Lisa have added a row for John's cookie token transfer after verifying the signature of John's message.
image::{imagedir}/cookie-sheet-basic-johns-transfer.svg[{half-width}]

=== Private key security

John is in control of his cookie tokens because he owns the
private key. No one but John can use John's cookie tokens because he is
the only one with access to his private key. If his private key is
stolen, he can lose any and all of his cookie tokens.

One morning when John came to the office, he took his laptop from his
desk and went straight to the cafe to buy his two morning cookies. He
opened his laptop to write a message to Lisa.

 Good morning Lisa! please move 20 CT to Cafe. /John
 Signature:
 H1CdE34cRuJDsHo5VnpvKqllC5JrMJ1jWcUjL2VjPbsj
 X6pi/up07q/gWxStb1biGU2fjcKpT4DIxlNd2da9x0o=

He sent an email with the message and a signature to Lisa, as
usual. But the cafe didn't hand him any cookies. The guy behind the
desk said that he hasn't seen any incoming payment of 20 CT yet. Lisa
is usually very quick in verifying and executing transfers.

John opens the spreadsheet and searches for "John". This is what he sees:

.Someone stole money from John. Who is Melissa and how was this possible? John did not sign any such transfer.
image::{imagedir}/cookie-sheet-john-pwned.svg[{half-width}]

John steps into Lisa's office asking for an explanation. She answers
him that she got a message signed with Johns private key asking her to
send money to this new coworker, Melissa. She even shows him the
message and signature. Of course there is no Melissa at the office,
eventhough a lot of new employees have started at the company
lately. Lisa don't care about names anymore, only public keys and
signatures.

The explanation to all this is that someone has

. managed to copy Johns private key. John's laptop has been on his
  desk all night long. Anyone could have taken out the hard drive from
  the laptop to search for his private key.
. created a new key pair and sent the new public key to Lisa:

 Hi Lisa. My name is Melissa, and I'm new here.
 My public key is
 02c5d2dd24ad71f89bfd99b9c2132f796fa746596a06f5a33c53c9d762e37d9008

. sent a signed message to Lisa

 Hi Lisa, please move 90 CT to Melissa. Thanks, John
 Signature:
 IPSq8z0IyCVZNZNMIgrOz5CNRRtRO+A8Tc3j9og4pWbA
 H/zT22dQEhSaFSwOXNp0lOyE34d1+4e30R86qzEbJIw=

Lisa validated the transfer in step 3 and concluded that it is valid
and executed the transfer. John asks Lisa to revert the, according to
him, fraudulent transfer. But Lisa refuses to do that. She thinks the
transfer is perfectly valid. If John let someone see his private key,
that's his problem, not Lisa's. That's part of why she's so trusted
within the company, she keeps her promises.

John creates a new key pair and ask Lisa to add his new public key
under the name John2.

How can John secure his new private key and still have it readily
available when he wants a cookie? John is pretty sure that he will not
have more than 1000 cookie tokens on that key.

[.gbinfo]
.You are responsible
****
You have the full responsibility for the security of your private keys.
****

The security of the spreadsheet has shifted from a system where Lisa
knows everyone's face to one where Lisa knows everyone's
public key. In a sense, the security could actually be worse now,
because it might be easier for Malory to steal John's private key than
it is for her to trick Lisa into thinking Malory is John. That depends
on how John protects his private key. An important thing to note is
that the security of John's private key is totally up to him. No one
is going to be able to restore John's private key if he loses it. And
Lisa sure is not going to reverse "fraudulent" transfers just because
John is sloppy with security. If he stores it in clear text in a
shared folder on the company's intranet, anyone can easily copy his
private key and use that to steal Johns cookie tokens. But if John
stores the private key in an encrypted file, protected by a strong
password, on his own laptop's hard drive, it's a lot harder to get a
copy of his key, because you must

. get access to Johns hard drive
. know John's password

If John thinks that he will never have more than 50 CT on his private
key, he might not be very concerned with security. But the cafe who
manages about 10000 cookie tokens might be very concerned. John and
the cafe probably need different strategies for storing their private
keys.

There is a trade-off between security and convenience. You can for
example keep your private key encrypted on an off-line laptop in a
bank safe-deposit box. When you want to buy a cookie you need to go to
the bank, take out the laptop from your safe-deposit box, decrypt the
private key with your password, and use the private key to digitally
sign a message to Lisa. Write down the message and signature on a
note, put back the laptop into the safe-deposit box and bring the note
back to the office. Very secure, and very inconvenient.

On the other hand, you can store your private key in clear text on
your mobile phone. Then you have the key at your fingertips and can
sign a message within seconds from when the urge for a cookie starts
to nudge you. Very insecure and very convenient.

Some of the different trade-offs are

.Security considerations against attackers. Note how the more secure options are also more inconvenient.
image::{imagedir}/private-key-security.svg[{half-width}]

Online vs offline:: On-line means that the private key is stored on a
device with network access, like your mobile phone or general purpose
laptop. Off-line means that the private key is stored on a piece of
paper, or a computer without any network access. On-line storage is
risky because remote security exploits or malicious software on your
computer, like computer viruses, may send the private key to someone
without you noticing. If the device is off-line, no one can take the
private key without physical access to the device.

Clear text vs encrypted:: If the private key is stored in clear text
in a file on the hard drive of your computer, anyone with access to
your computer, either remotely over a computer network, or physically,
can make a copy of the private key. That includes any viruses that
your computer may be victim to. You can avoid many of these attacks by
encrypting your private key with a password that only you know. Any
attacker would then need both read access to your hard-drive and your
secret password to copy the key.

Whole key vs Splitted key:: Usually people store their entire private
key on a single computer. That's convenient, you only need one
computer to spend your cookie tokens. An attacker need to get access
to your hard drive in order to steal the private key. But if your
private key is splitted into three parts, and you store the three
parts separately on three different computers, then the attacker must
get access to the hard drives of three computers. That's much harder
because she must know what three computers to attack and also
successfully attack them. Making a payment in this setup is a real
hassle, but very secure.

Any combination of the above methods can be used to store your
keys. But as a rule of thumb, the higher the security against
attackers, the higher the risk of you accidentally losing access to
your key. For example, if you store the private key encrypted on your
hard drive, you risk losing your key due to both computer failure and
forgetting your password. So in this sense, the more secure you store
your keys, the less secure it is.

=== Summary

Lisa has solved the problem with people claiming to be someone else
when they make a payment. She requires all payers to digitally sign
the cookie token transfers. Every user of the spreadsheet needs to
have a private key and a public key. Lisa keeps track of which public
key belongs to whom. A payment must from now on be written in an email
to Lisa, and the message must be digitally signed with the person's
private key. Lisa can then verify the signature to make sure she is
not being fooled.

image::{imagedir}/digital-signature-summary.svg[{big-width}]

The gist of this is that as long as John keeps his private key to
himself, no one will be able to spend his money.

==== System changes

We need to add another concept to our concept table. The "Note to Lisa":

[%autowidth]
.Adding the "Note to Lisa" as a key concept
|===
| Cookie Tokens | Bitcoin | Covered in

| 1 cookie token | 1 bitcoin | <<ch02>>
| The spreadsheet | The blockchain | <<ch06>>
| *Note to Lisa* | *A transaction* | *<<ch05>>*
| A row in the spreadsheet | A transaction | <<ch05>>
| Lisa | A miner | <<ch07>>
|===

The note to Lisa will be replaced by transactions in
<<ch05>>. Transactions will replace both the note to Lisa and the row
in the spreadsheet. It's time to release version 2.0 of the cookie
tokens.

[%autowidth,options="header"]
.Release notes, cookie tokens 2.0
|===
|Version|Feature|How

|image:{commonimagedir}/new.png[role="gbnew"]*2.0*
|Secure payments
|Digital signatures solves the problem with the imposter

.2+|1.0
|Simple payment system
|Relies on Lisa being very trustworthy and knowing everyone's face
|Finite money supply
|7200 New CT rewarded to Lisa daily, halves every four years.
|===

Everybody still trust Lisa to not change the spreadsheet in any way
except when executing signed cookie token transfers. If Lisa wanted to
she could steal anyone's cookie tokens by just adding a transfer to the
spreadsheet. But she wouldn't do that, or would she?

.Toolbox
****
image::{imagedir}/toolbox-signatures.svg[]
****

We have a lot of new tools that we will put in our toolbox for later
use: Key pair generation, digital signing, the signature and the
verification.

.The tools used for signing and verification.
image::{imagedir}/tool-signing.svg[{half-width}]

=== Exercises

==== Warm up

. Lisa is rewarded 7200 CT per day for her work. Why won't the money
supply increase infinitely over time? Why don't we have 7200*10000=72
million CT after 10000 days?
. How can coworkers detect if Lisa rewards herself too much or too often?
. How is the private key of a key-pair created?
. What key is used to sign a message?
. The signing process hashes the message to sign. Why?
. If John didn't end his message with "/John", would Lisa be able to
determine who to withdraw money from?  
. What would Malory need in order to steal cookie tokens from John?

==== Dig in

[start=8]
. Suppose that you have a private key and that you have given your
public key to a friend, Fred. Suggest how Fred can send you a secret
message that only you can understand.

****
image::{imagedir}/message-in-a-bottle.svg[]
****
[start=9]
. Suppose that you (let's pretend your name is Laura) and Fred still
have the keys from the previous exercise. Now you want to send a message in a bottle to Fred saying
+
----
"Hi Fred! Can we meet at Tiffany’s at sunset tomorrow? /Laura"
----
+
Please explain how you would sign the message so that Fred can be sure
that the message is actually from you.

. Are the names in the spreadsheet really needed anymore? Could they
be replaced by something else? If that is possible, suggest how a
typical payment can look?

=== Recap

In this chapter you learned that

* Bitcoins are created as rewards to nodes securing the blockchain.
* The reward halves every four years to limit the money supply.
* You can use cryptographic hash functions to detect changes in a file
  or in a message.
* You can't make up a preimage of a cryptographic hash. A preimage is
  an input that has a certain known output.
* Digital signatures are useful to prove the authenticity of a
  payment. Only the rightful owner of bitcoins may spend them.
* Someone verifying a digital signature does not have to know _who_ made
  the signature. She just have to know that the signature was made
  with the private key the signature claims to be signed with.
* To receive bitcoins or cookie tokens, you need a private key, that
  you create yourself in private. You derive the public key from the
  private key.
* There are several strategies to store private keys ranging from
  unencrypted on your mobile phone to splitted and encrypted across
  several safe deposit boxes.
* General rule of thumb: The more secure against theft, the easier to
  accidentally lose the keys.
