[[ch06]]
== The blockchain - Further reducing trust in Lisa
:imagedir: {baseimagedir}/ch06

This chapter covers

* Securing the spreadsheet integrity (at least improving it)
* Lightweight wallets (SPV wallet)
* Reducing wallet bandwidth requirements

In the previous chapter we introduced transactions that enabled anyone
to verify all transactions in the spreadsheet. But there are still
things verifiers cannot verify: That Lisa doesn't remove transactions
and that she doesn't censor transactions. Censorship resistance will
be handled in the next chapter. This chapter will make it impossible
for lisa to remove or replace transactions without also making it
obvoius that she has tampered with transaction history.

Lisa does this by getting rid of the spreadsheet and replace it with a
thing called the _blockchain_. The blockchain contains transactions
that are secured from tampering by hashing and signing the
transactions in a clever way. This technique makes it easy to provide
cryptographic proof of fraud if Lisa tries any dirty tricks. All
verifiers keeps their own copies of the blockchain and they can now
fully validate the blockchain to ensure that Lisa doesn't remove
already confirmed transactions.

It's been a while since we talked about normal users' wallets. We will
introduce something called a lightweight wallet, or SPV (simplified
payment verification) wallet, that will defer the verification of
transactions to someone else, a full node, to save bandwidth and
storage space. This is possible thanks to the blockchain.

=== Lisa can delete transactions

As noted several times before, Lisa can delete transactions. For
example, Lisa buys a cookie from the cafe, eats it, and deletes the
transaction. Of course, Lisa wouldn't do that because she's the most
trustworthy person on earth, but all coworkers don't know that or
don't believe in it.

.Lisa buys a cookie and then reverts the transaction. She just stole a cookie from the cafe.
image::{imagedir}/deleted-tx.svg[{big-width}]

When the cafe eventually notices that the transaction has disappeared,
they can't prove that Lisa's transaction was ever in the
spreadsheet. And Lisa can't prove it was not there. This situation is
troublesome. If word is against word, we are in for a long and costly
dispute, possibly involving lawyers, police, Acme Insurances and
private detectives.

How can we make it possible to prove if a transaction was confirmed or
not? We want a way for Lisa to publish the transactions and their
ordering such that she can't tamper with them.

=== Build the first blockchain

The reason Lisa can delete transactions is that no one can verify that
the list of all transactions has changed. Lisa can make any changes
she wants at virtually no cost. What if we could prevent Lisa from
changing transaction data, or make it provable that she has fiddled
with history?

Some developers suggest that we get rid of the cookie token
spreadsheet and replace it with a blockchain. The blockchain stores
transactions just like the spreadsheet did. But the blockchain also
contains some other stuff to protect the integrity of the contained
transactions.

.The blockchain is a chain of blocks. Each block points to the previous block through the block id. The first block is at height 0.
image::{imagedir}/blockchain.svg[{big-width}]

The blockchain consists of blocks. Each block contains one or more
transactions and a block header. The block header consists of

* the double SHA256 hash of the previous block's header, previous block id
* the combined hash of the transactions in the block, the _merkle root_
* a timestamp, creation time of the block
* Lisa's signature of the block header

.Block id
****
image::{imagedir}/2ndcol-block-id.svg[]
****

The hash of a block header is used as an identifier for the block, just as
a transaction hash, txid, is used as an identifier for a
transaction. We will sometimes refer to the block header hash as
block id.

The leftmost part of the block header is the block id of the previous
block in the blockchain. This is why we call it a _chain_. The
previous block header hashes form a chain of block headers.

The second part from the left is the combined hash of the
transactions. This is the _merkle root_ of a _merkle tree_. We will
talk about that in later sections of this chapter, but for now let's
just say that they are hashed together into a single hash value that
is written into the block header. You can't change any transactions in
the block without also changing the merkle root.

==== Lisa builds a block

Lisa creates a new block every 10 minutes containing all recent
unconfirmed transactions and writes it in a new file on a shared
folder. Everyone has permission to read files from to this shared
folder, but Lisa can write files. When Lisa writes the block to a file
in the shared folder, she _confirms_ the transactions in that block.

image::{imagedir}/block-files.svg[{big-width}]

When Lisa creates a new block, she writes the current time into the
timestamp field of the block header. The block creation timestamp is
important to verifiers, so that they can verify that blocks are
created at the expected pace, one every 10 minutes. Lisa cannot create
one block per exactly 10 minutes, but the two week average should be 1
block per 10 minutes. This will be further discussed in <<ch07>>.

[.inbitcoin]
****
Bitcoin blocks are not signed this way. They are "signed" with
proof-of-work described in <<ch07>>.
****

Before Lisa is finished with the block she must sign it using a
private key known only to Lisa.

.Lisa signs a block with her block signing private key. The public key is well known among the coworkers.
image::{imagedir}/lisa-signs-block.svg[{half-width}]

The corresponding public key must be made publicly available to all
verifiers. It can be published on the company's intranet and on a
billboard at the main entrance. The signature is required because only
Lisa should be able to add blocks to the blockchain (for now). Anyone
else trying to create a block and write it to the shared folder, for
example the system administrator for the shared folder server, will
not be able to sign it correctly, because they don't have Lisa's
private key.

****
image::{imagedir}/2ndcol-lisas-block-public-key.svg[]
****

Using private keys to sign blocks is not always a good idea for two
reasons:

1. Lisa's private key can be stolen. If this happens the bad guy can
create valid blocks and force the system administrator to write them
to the shared folder, causing Lisa to be blamed for fraud.

2. The sources containing Lisa's public key, for example the billboard
or the intranet, may be compromised and the public keys replaced by
the bad guy's public key. If this happens some verifiers will be
tricked into accepting blocks signed by another key than Lisa's block
signing key. The bad guy can fool some portion of the verifiers. A
coworker shouldn't trust just the note on the billboard, because
it is easy for someone to replace the note with another false
public key. Coworkers need to get the public key from different
sources, like the billboard, the intranet and ask fellow workers. A
single source is too easily manipulated by bad guys.

[.inbitcoin]
.Block rewards
****
The block reward is 50 bitcoins for each block during the first 4
years. This reward will decrease by 50% every 210000 blocks (4 years).
****

The first transaction in each block is a coinbase transaction, but the
coinbase transactions of the blocks create 50 cookie tokens per block
instead of 7200 cookie tokens as was the case in <<ch05>>. The idea is
that Lisa produces a new block every 10 minutes, which means that the
rewards of 7200 CT per day are spread out over 144 blocks, since there
are 144 intervals of 10 minutes in 24 hours, and 7200/144=50. We will
talk more about block rewards in <<ch07>>.

==== How does this protect us from deletes?

Suppose that Lisa wants to eat a cookie without paying for it. She
creates a transaction and puts it in the block she's currently working
on, block height 21. She creates the block header, signs it and writes the block to a new file, `block_21.dat`, on the shared folder.

.Lisa creates a block containing her payment for a cookie.
image::{imagedir}/lisa-tries-to-fool-cafe.svg[{big-width}]

The cafe watches the shared folder for incoming blocks. When Lisa
writes the block file into the shared folder, the cafe will download
the block and verify it. To verify a block involves verifying that

* the previous block header is the expected, the block id of block 20
  in this case.
* all transactions in the block are valid. The same validation as in
  <<ch05>> is used, by using a private UTXO set.
* the combined hash of all transactions matches the merkle root in the
  block header.
* the timestamp is greater than the timestamp of the previous block
  and within reasonable limits.
* the block header signature is valid. The signature is verified using
  Lisa's public key obtained from the billboard or intranet.

Lisa have paid for a cookie and the cafe have downloaded the block
that contains Lisa's transaction and verified it. They give Lisa the
cookie and she eats it. Yummy.

[.gbfaq]
.Why not just delete block?
****
If she deletes a block she must eventually replace it with another
version of block 21 to not break the chain of blocks.
****

Can Lisa undo this payment without being proven a fraud? Her only
option is to make another, changed version of block 21, that doesn't
include her transaction and overwrite the file block_21.dat on the
shared folder with it.

.Lisa creates an alternative block at height 21 that doesn't contain her transaction.
image::{imagedir}/change-block.svg[{half-width}]

The new version is like the old version but without Lisa's
transaction. Because she tampers with the transactions in the block,
she has to update the merkle root in the header with a merkle root
that matches the new set of transactions in the block. When the header
is changed, the signature is no longer valid and the header needs to
be re-signed. To make the changed block available to verifiers, she
needs to replace the file `block_21.dat` on the shared folder with the new
fraudulent block file.

The cafe has already downloaded the first version of block 21. When
Lisa adds the new block file, the cafe will at some point, discover
that there's another version of the block in the shared folder.

.The cafe sees two versions of block 21. One with Lisa's transaction and one without.
image::{imagedir}/different-block-version.svg[{half-width}]

Now the cafe sees two different blocks at height 21, one that contains
the payment of 10 CT to the cafe and one that doesn't. Both blocks are
equally valid and none of the blocks are more "accurate" than the
other from a verification perspective. But the good thing is that the
cafe can prove that Lisa is playing dirty tricks because Lisa has
created two different, _signed_, versions of the block. The signatures
proves that Lisa cheated, and we no longer have a word against word
situation. Lisa would get fired or at least get removed from her
powerful position as a transaction processor.

What if there were other blocks after block 21 when Lisa cheated?
Suppose that block 22 and 23 were already created when Lisa decided
that she wanted to delete her transaction.

.Lisa needs to create alternative versions of the block containing her transaction and all subsequent blocks.
image::{imagedir}/replace-many-blocks.svg[{big-width}]

****
image::{imagedir}/2ndcol-replace-many-blocks.svg[]
****

Now she needs to make three alternative blocks: 21, 22
and 23. Changing anything in a block causes that block and all
subsequent blocks to be invalid and they must all be replaced by valid
blocks. This is because each block header contains a pointer to the
previous block, the previous block id, which will change if the
previous block changes. Three new alternative block files must be
created in the shared folder. Lisa would get caught in the same way as
above.

////
Delete enabled:

Lisa can still claim that the block was never on the shared
folder. Just as she previously could claim that the transaction was
never in the spreadsheet in ch05.

Delete disabled:

Lisa can't deny that block wss published on the shared folder, because it's actually there.

How about this instead:

Everyone has write access to the SF but only Lisa's signatures are
valid at this point and you can't delete files from the SF.

This would mean that as soon as anyone gets their hands on a
Lisa-signed block, they can publish it and it is as good as any other
block on the SF. Forks are persistent on the SF.

Lisa can delete transactions from spreadsheet
---> Introduce blockchain and add-only shared folder

Lisa can create multiple blocks at same height
---> Proof that she cheats

Lisa can censor transactions
---> Multiple Lisas drawing random numbers

Actors can cheat with the random numbers
---> Proof-of-work

Admin of shared folder can delete/censor blocks (Lisa and Admin can collude)
---> Peer-to-peer network
////

==== Why use a blockchain at all?

The blockchain is a very complicated way to sign a bunch of
transactions. Wouldn't it be much simpler if Lisa just signs all
transactions ever made in one big chunk every 10 minutes? That would
accomplish the same goal. There are a number of problems with that approach:

* As the number of transactions grows, the time it takes for Lisa to
  sign the whole set of transactions will increase
* The same goes for verifiers, the time it takes to verify a signature
  increases with the total number of transactions.
* It's hard for verifiers to know what's new since last
  signature. That information is valuable when maintaining the
  UTXO set.

By using the blockchain Lisa only have to sign the most recent, yet
unconfirmed set of transactions while still, indirectly via the
previous block id pointer, signing all historic transactions:

.Each block signs all transactions ever made thanks to the previous block id field of the headers.
image::{imagedir}/reincorcing-previous-block-signatures.svg[{big-width}]

Each block's signature reinforces the signatures of the previous
blocks. This will become very important when we replace the signatures
with proof-of-work in the next chapter.

The verifiers can also easily see what's new since last block and update
their UTXO sets accordingly. The news are right there in the block.

The blockchain also provides some nice extra features that we will
duscuss further on, for example the merkle tree.

=== Lightweight wallets

Coworkers that want to verify the blockchain to make sure that they
have valid financial information use software that downloads the whole
blockchain and keeps a UTXO set up to date at all times. This software
needs to run nearly all the time to stay up to date with newly
produced blocks. We call this running software a _full node_. A full
node knows about all transactions since block 0, the _genesis
block_. The company and the cafe are typical users of full nodes. They
don't have to trust someone else with providing them with financial
information. They get their financial information directly from the
blockchain. Anyone is free to run this software as they please.

[.gbinfo]
.Alternative names
****
A lightweight client is sometimes referred to as an SPV client or an
SPV wallet. SPV means Simplified Payment Verification.
****

In <<ch04>> we introduced a mobile app that coworkers can use to
manage their private keys, as well as send and receive money. The
wallet app has now been adapted to the new blockchain system.

Since most wallet users are on a mobile data plan, they don't want to
waste bandwidth on downloading all, for them uninteresting, block
data. The overwhelming majority of the blocks will not contain any
transactions concerning them, so downloading them would only make
their phones run out of data traffic but not provide useful
information to them.

The developers of the full node and the wallet developers cooperate to
let wallets connect to full nodes over the internet and get relevant
block data from the full nodes in a way that doesn't require huge
amounts of data traffic. Wallets are allowed to connect to any full
node and ask for the data they need. This is what we sketched out in
<<ch01>>:

.A Bitcoin wallet gets notified of an incoming payment by a full node.
image::{imagedir}/periscope-lightweight-wallet.svg[{half-width}]

Suppose that John wants to receive notifications from a full node only
on transactions concerning his own wallet, that contains two
addresses, @~a~ and @~b~. He can now make a network connection to any
of the full nodes at the office, for example the cafe's. Then they
start talking:

.Information exchange between a lightweight wallet and a full node. The full node sends all block headers and a fraction of the transactions to the wallet.
image::{imagedir}/spv-node-exchange.svg[{big-width}]

[.inbitcoin]
.BIP37
****
This process is described in full detail in BIP37, found at <<web-bips>>.
****

1. John's wallet asks the full node for all block headers since the wallet's
last known block header and all transactions concerning John's addresses.

2. The cafe's full node sends all requested block headers to the
wallet and at least all transactions concerning John's addresses.

In step 1, the wallet does not send the exact list of addresses in
John's wallet. That would harm John's privacy, because the café would
then be aware of all Johns addresses and possibly sell the information
to Acme Insurances. Not nice. John's wallet instead sends a filter to
the full node. This filter is called a _bloom filter_. It is used by
the full node to determine whether to send a transaction to the wallet
or not. The filter will tell the full node to send all transactions
concerning @~a~ and @~b~, but it will also tell the full node to send
transactions that are not relevant to John's wallet to obfuscate what
addresses actually belongs to the wallet. While bloom filters doesn't
have much to do with the blockchain, we still dedicate a subsection to
bloom filters here because they are used heavily by lightweight
wallets.

In step 2, transactions are sent to John's wallet as well as block
headers, but the complete blocks are not sent (to save network
traffic). John's wallet can't use just a transaction and the header to
verify that the transaction is actually in the block. Something more
is required, a _merkle path_ that proves that a transaction is
included in a block.

The above two steps was performed as a syncronizing phase just after
the wallet connected to the cafe's full node. After this, as Lisa
creates new blocks and the cafe's full node picks them up, the
corresponding block headers are sent to the wallet together with all
transactions concerning John's addresses in about the same way as
above.

The next two subsections will discuss bloom filters and merkle trees
respectively.

=== Bloom filters, obfuscate addresses

John's wallet contains two addresses: @~a~ and @~b~, but John doesn't
want to reveal to anyone that @~a~ and @~b~ belongs to the same
wallet. He has good reasons to be weary, because he has heard rumours
that Acme Insurances pays good money for such information in order to
"adjust" the premiums, based on peoples cookie eating habits.

==== Create the bloom filter

To obfuscate what addresses belongs to John, his wallet will create a
bloom filter to send to the full node:

.The client sends a bloom filter to the full node to obfuscate what addresses belongs to the wallet.
image::{imagedir}/spv-node-send-bloom-filter.svg[{big-width}]

The bloom filter is a sequence of _bits_. A bit can have the value 0
or the value 1. John's bloom filter happens to be 8 bits long. Let's
see how it was created.

.The lightweight wallet creates a bloom filter to send to the full node. Each address in the wallet is added to the bloom filter.
image::{imagedir}/create-bloom-filter.svg[{big-width}]

[.inbitcoin]
****
The number of hash functions can be anything, as well as the size of
the bloom filter. This example uses three hash functions and eight bits.
****

The wallet creates the sequence of bits, and initializes them with
zeroes all over. Then it will _add_ all John's public key hashes to
the bloom filter, starting with @~a~.

It runs @~a~, PKH~a~ really, through the first of the three hash
functions. That hash function results in the value `2`. This value is
the index of a bit in the bloom filter. The bit at index 2 (the third
from the left) is then set to `1`. Then @~a~ is run trough the second
hash function that outputs `0`, and the corresponding bit (the first
from the left) is set to `1`. Finally the third hash function outputs
`6` and the bit at index 6 (7th from the left) is set to `1`.

Next up is @~b~. It is handled in the exact same way. The three hash
functions outputs `5`, `0` and `3`. Those three bits are all set
to 1. Note that bit 0 was already set by @~a~, so that bit is not
modified.

The bloom filter is finished and ready to be sent to the full node.

==== Use the bloom filter

The full node receives the bloom filter from the wallet and wants to
use it to filter transactions to send to the wallet.

Suppose that Lisa just published a new block to the shared folder and
the full node has verified the block. The full node now wants to send
the block header of the new block and all relevant transactions in it
to the wallet. How would the full node use the bloom filter to
determine what transactions to send?

The block contains 3 transactions, Tx~1~, Tx~2~ and Tx~3~:

.The block to send contains three transactions of which only one actually concerns John.
image::{imagedir}/bloom-filter-transactions.svg[{big-width}]

Tx~1~ and Tx~3~ have nothing to do with John's addresses, but Tx~2~ is
a payment to John's address @~b~. Now let's have a look at how the
full node uses the bloom filter.

.The full node use the information in the transactions to determine if the transaction is "interesting" to the wallet.
image::{imagedir}/use-bloom-filter.svg[{big-width}]

The full node tries to figure out what transactions to send to the
wallet. If any public key hash of a transaction matches the filter,
then the transaction might be interesting to the wallet, so the node
should send that transaction.

For each output in a transaction the node tests whether any public key
hash matches the filter. It starts with Tx~1~. Tx~1~ has a single
output to PKH~V~. To test whether PKH~V~ matches the filter, it runs
PKH~V~ through the exact same three hash functions as John's wallet
did when the filter was created. The hash functions output the indices
`5`, `1` and `0`. The bits at index `5` and `0` are both `1`, but the
bit at index `1` is `0`. A zero bit means that PKH~V~ is definately
not interesting to John's wallet. If John's wallet was interested in
PKH~V~, it whould have added it to the filter, thus setting bit `1` to
`1`. Since PKH~V~ was the only public key hash in Tx~1~, it means that
John's wallet is not interested in this transaction.

Next transaction is Tx~2~. It contains two public key hashes: PKH~b~
and PKH~X~. The node will test each of these in turn. It begins with
PKH~b~. Running this PKH through the hash functions gives the indices
`5`, `0` and `3`. All those three bits have the value `1`. This means
that the node cannot say for sure if the transaction is interesting to
the wallet, but it cannot say that it's definately not
interesting. There is no point in testing any further public key
hashes in this transaction because we have already determined that it
might be interesting. The node decides that Tx~2~ should be sent to
the wallet.

The last transaction has two outputs to PKH~Y~ and PKH~Z~. It starts
with PKH~Y~. That happens to point at `2`, `7` and `4`. Both bits `4`
and `7` are `0`, which means that PKH~Y~ is definately not interesting
to the wallet. Let's continue with the next, PKH~Z~. This results in
bits `2`, `3` and `0`. All three bits have the value `1`. This again
means that Tx~3~ _might_ be interesting to the wallet, so the node
will send that transaction too. John's wallet doesn't actually contain
PKH~Z~, but the purpose of the bloom filter is to match more than
needed to preserve some degree of privacy. We call this a _false
positive_ match.

The result of this is that the node will send Tx~2~ and Tx~3~ to the
wallet. How the transactions are sent is a totally different story,
described in the next subsection.

The above is a simplification of what really happens. We only tested
public key hashes of the transaction outputs above, which would
capture all transactions that pays cookie tokens _to any of John's
addresses_. But what about transactions that are spending _from John's
addresses_? One could argue that the full node doesn't need to send
those transactions to the wallet, because the wallet already knows
about them, since it created them in the first place. But
unfortunately, we do need to send those transactions too for two
reasons:

* It might not be this wallet app that created the transaction. John
  can have multiple wallet apps that generate addresses from the same
  seed. For example, do you remember in <<ch04>> how a wallet can be
  restored from a mnemonic sentence? That sentence can be used by
  multiple wallet apps at the same time. John might want to make a
  payment from one of the wallet apps and be notified of the payment
  in the other wallet app, so that John can monitor the total balance
  in that app.

* John wants to be notified when the transaction is confirmed. The
  wallet app may already have the transaction, but it is still marked
  as _unconfirmed_ in the app. John wants to know when the transaction
  has been included in a block, so he needs the node to send him this
  transaction when it's in a block.

What really _is_ tested by the node are the following items:

.Several things in a transaction are tested through the bloom filter to determine if the tx is possibly interesting 
image::{imagedir}/bloom-filter-what-to-test.svg[{quart-width}]

The node will test

* the txid of the transaction
* all transaction output (TXO) references in the inputs
* all data items in scriptSigs
* all data items of the outputs

So for John's wallet to be notified of spends it needs to add either
all its public keys to the bloom filter or all its unspent transaction
output references.

==== Throttle privacy and data traffic

****
image::{imagedir}/2ndcol-bloom-filter-tradeoff.svg[]
****

The purpose of the bloom filter is to enhance privacy for the
user. The level of privacy can be controlled by tuning the ratio
between the number of `1`s in the bloom filter and the bloom filter
size. The more `1`s in the bloom filter in relation to the bloom
filter size, the more false positives. More false positives means that
the full node will send more unrelated transactions to the
wallet. More unrelated transactions means more wasted data traffic,
but also improves privacy.

Let's do some back-of-the-envelope calculations. Feel free to skip
this part and jump to <<merkle-trees>>

The bloom filter in the example above has 8 bits of which 5 are
ones. A single hash function's output has the probability 5/8 to hit
a 1. For a single test, the probability that all three hash functions
hit a `1` is then (5/8)^3^. The probability that a single test is
negative, at least one of the three hash functions point to a `0`, is
then 1-(5/8)^3^. The full node will perform several tests on each
transaction, typically 9 for a transaction with two inputs and two
outputs. Let's check against the list of tests performed by the full
node:

* the txid of the transaction (1)
* all transaction output (TXO) references in the inputs (2)
* all data items in scriptSigs (public key and signature x 2 = 4)
* all data items of the outputs (2)

The probability that all 9 tests is negative is (1-(5/8)^3^)^9^≈
0.08. This means that almost all, 92/100, transactions will be sent to
the wallet. This shows that having only 3 zeroes of eight bits in the
bloom filter will not help reduce the data very much.

To get less false positives, John's wallet must use a larger bloom
filter. so that the ratio (number of ones / bloom filter size)
decreases.

Let's define some symbols:

 t = the number of tests performed on a transaction (9)
 p = the probability of transaction being deemed uninteresting
 r = the ratio of number of `1`s / bloom filter size

Let's generalize the calculation above:

[stem] 
++++
(1-r^3)^t=p \Rightarrow lg_{10}(1-r^3)=\frac{lg_{10}(p)}{t}
\Rightarrow 1-r^3 = 10^{ \frac{lg_{10}(p)}{t}} \\

\Rightarrow r^3 = 1 - 10^{ \frac{lg_{10}(p)}{t}}
= 1 - (10^{ lg_{10}(p) })^{\frac{1}{t}} = 1 - p^{\frac{1}{t}} \\

\Rightarrow r=\sqrt[3]{1-p^{\frac{1}{t}}}
++++

Let's say that we only want to get of 1/10 of all transactions (given that all
transactions are like the transaction above with 2 inputs and 2
outputs). How big do we have to make the bloom filter?

[stem]
++++
t = 9, p = \frac{9}{10} \\
r = \sqrt[3]{1-p^{\frac{1}{t}}}
  = \sqrt[3]{1-(\frac{9}{10})^{\frac{1}{9}}} ≈ 0.23
++++

[.inbitcoin]
****
The bloom filter size must be a multiple of 8 bits, so 26 bits is not
allowed. We can round upwards to 32 bits.
****

This means that the bloom filter should be about 6/0.23 ≈ 26 bits in
order to get only 1/10 of all transactions. Remember that these are
very rough calculations based on somewhat false assumptions regarding
the characteristics of transactions. We alse don't take into account
that the number of ones in our example is not strictly 6, but can be
anywhere from 3 to 6 since both John's addresses could have generated
the same set of indices. But it should help you get an idea on how big
a bloom filter must be.

[id=merkle-trees]
=== Merkle trees

Now that the full node has determined what transactions to send to the
wallet it needs to send the new block header and all transactions that
John's wallet might be interested in.

.The full node feeds the lightweight wallet with block headers and relevant transactions
image::{imagedir}/spv-node-receive-merkle-block.svg[{big-width}]

From the block above, it has determined that transactions Tx~2~ and
Tx~3~ need to be sent to the wallet. If the node sends only the header
and the two transactions, then John's wallet will not be able to
verify that the transactions actually belong to the block. The merkle
root depends on three transactions, Tx~1~, Tx~2~ and Tx~3~, but the
wallet only gets Tx~2~ and Tx~3~ from the full node. The wallet cannot
recreate the merkle root in the block header. It needs more
information to verify that the transactions are included in the block.

First of all, remember that we want to save data traffic, so simply
sending all transactions in the block is not good enough.

==== Create the merkle root

It's time to reveal how Lisa creates the merkle root. Suppose that
Lisa needs to create the block header above. She needs to make the
combined hash of all transactions that we call the merkle root. The
merkle root is calculated by creating a hierarchy of cryptographic
hashes, a _merkle tree_.

.Lisa creates a merkle root from the transactions in a block.
image::{imagedir}/merkle-tree.svg[{big-width}]

The transactions are ordered in the same order as in the block. If the
number of items is odd, the last item is duplicated and added
last. This item is not added to the block, it's only duplicated
temporarily for the merkle tree calculation.

Each item (transaction in this case) is hashed with double
SHA256. This results in four hash values, of 256 bits each.

The hash values are pair-wise _concatenated_, meaning that two hashes
are merged by appending the second hash after the first hash. For
example `abc` concatenated with `def` becomes `abcdef`.

[.inbitcoin]
.Security vulnerability
****
There is a weakness in this scheme. The transactions Tx~1~, Tx~2~,
Tx~3~ will have the same merkle root as the transactions Tx~1~, Tx~2~,
Tx~3~, Tx~3~. The latter is of course not allowed because it is a
double spend attempt, but it could cause serious issues anyway in
older versions of the bitcoin core software.
****

The four hash values have now become two concatenated values. Since
two is an even number, we don't add any extra item at the end. If we
would have three items we would have to copy the last item and put it
last so that we get an even number. The two concatenated values are
each hashed separately resulting in two 256 bit hashes.

These two hash values are concatenated into a single 512 bit
value. This value is hashed, witch results in the 256 bit merkle
root. This merkle root is written into the block header.

If any transaction is added, deleted or changed, the merkle root will
change.

.A change in the transactions will cause a change in the merkle root, making the signature invalid.
image::{imagedir}/mekle-tree-change.svg[{half-width}]

This is nice, because if Lisa signs a block header, she knows that no
one can tamper with the transactions in it without making the
signature invalid. There is an annoying exception to this, see the
note in the margin.

==== Prove that a transaction is in a block

The full node wants to send Tx~2~ and Tx~3~ to John's wallet, because
it thinks those transactions might be interesting to John's wallet.

How can the full node provide a proof to the wallet that Tx~2~ is
included in the block? It can do so by providig a _merkle path_ that
connects Tx~2~ to the merkle root in the block header.

.The full node constructs a merkle path that connects Tx~2~ to the merkle root in the block header.
image::{imagedir}/merkle-path.svg[{big-width}]

[.inbitcoin]
****
This is not exactly how it is done in Bitcoin. But this is close
enough to grok what's happening. To see the exact algorithm, please
read BIP37.
****

The merkle path consists of the path elements of the tree that is
needed to connect Tx~2~ to the merkle root. A path element consists of

* a hash value for a branch of the merkle tree
* an indication of if it's a left or a right branch

In this example the full node needs to provide two path elements,
"Left A" and "Right B", where A and B are marked in the diagram above.

The full node then needs to send the following items to the wallet:

* The block header
* The merkle path connecting the transaction to the merkle root:
** Right B
** Left A
* The transaction, Tx~2~.

To verify that the transaction is part of the block, the wallet starts
with the last of these things, Tx~2~, and hashes it. It then combines
that hash with the branch "Left A" of the merkle path.

.The wallet generates an intermediary branch of the merkle tree using stuff received from the full node.
image::{imagedir}/merkle-path-verify-a.svg[{half-width}]

The "Left" part tells the wallet that the hash A is to the left of the
hash of Tx~2~, so that the wallet can combine the two branches in the
correct order. To get to the next level towards the root, the wallet
needs to hash the combined value. The new hash value is an
intermediary branch of the merkle tree, because there are still items
left in the in the merkle path. We have now used one path element of
the merkle path. It's time to use then next (and last) element, "Right
B".

image::{imagedir}/merkle-path-verify-b.svg[{half-width}]

The word "Right" means that the hash in the path element is a right
branch. The wallet knows that it needs to combine the result of the
previous step with the "Right B" branch and hash that combination. The
hash value is a merkle root, because there is no more items to use in
the merkle path.

Now the wallet has to compare the calculated merkle root with the
merkle root in the block header, the given merkle root, and verify
that they are the same.

.The wallet checks that the given and the calculated merkle roots match. If so, Tx~2~ is proven to belong to the block.
image::{imagedir}/merkle-path-verify-compare-root.svg[{half-width}]

If they are the same the full node has proven that Tx~2~ is part of
the block.

The wallet has now received a chain of block headers and transactions
relevant to the wallet, plus some unrelated transactions to obfuscate
to the full node what addresses belong to the wallet.

==== Handle thousands of transactions in a block

The block in the example above contained only three transactions. We
didn't save much space sending the header, the merkle path and
Tx~2~. We could just as well send just the block header and all three
transactions as is. That would be much simpler. But let's check some
rough numbers on how the merkle proofs compare in size to the full
block as the number of thansactions grows.

[%autowidth]
.Size of merkle proofs compared to the block size for different block sizes
|===
| Number of tx in block | merkle path length | Block size  [bytes] | Merkle proof size [bytes]

| 1 | 0 | 330 | 330
| 2 | 1 | 580 | 362
| 3 | 2 | 830 | 394
| 4 | 2 | 1080 | 394
| 5 | 3 | 1330 | 426
| 6 | 3 | 1580 | 426
| 7 | 3 | 1830 | 426
| 8 | 3 | 2080 | 426
| 9 | 4 | 2330 | 458
| 10 | 4 | 2580 | 458
| 100 | 7 | 25080 | 554
| 1000 | 10 | 250080 | 650
| 10000 | 14 | 2500080 | 778
| 100000 | 17 | 25000080 | 874
| 1000000 | 20 | 250000080 | 970
|===

[.inbitcoin]
.Why 80 byte header?
****
Bitcoin's block header is always 80 bytes. The cookie token block headers are slightly bigger, because of the signature. In the next chapter we will fix our block header to match Bitcoin's exactly.
****

The table assumes that all tranactions are 250 bytes. The block size
is calculated as 80 bytes block header plus number of transactions
times 250. The merkle proof is calculated as 80 bytes block header plus merkle path length times 32 plus 250 bytes.

The merkle proofs don't grow as fast as the total block size, because
the merkle proof grows _logarithmically_ with the number of
transactions, while the block size grows _linearly_ with the number of
transactions.

=== Summary

This chapter has descibed the blockchain and how it enables full nodes
to independently verify all transactions. The blockchain is a sequence
of blocks that are interconnected through cryptographhic hashes

.The blockchain connects the blocks by the previous block id value in the block headers. The transactions are committed to by the merkle root.
image::{imagedir}/summary-blockchain.svg[{big-width}]

The merkle root in the block header is the combined hash of all
contained transactions. This hash is created by hashing transactions
in a merkle tree structure. Transactions hashes are concatenated
pair-wise and hashed agein to get one step closer to the root.

.Transactions are hashed in a tree structure, merkle tree, and the root of the tree is the merkle root written in the block header. 
image::{imagedir}/summary-merkle-tree.svg[{big-width}]

A full node can prove to a lightweight wallet that a transaction is in
a block by sending a block header and a merkle proof to the
wallet. The merkle proof consists of the transaction and the merkle
path. The merkle path is a series of hashes and whether the hash is a
left hash or a right hash. The merkle path grows logarithmically with
the number of transactions.

For privacy reasons, wallets don't want just the transactions they are
actually interested in. To obfuscate what addresses actually belongs
to the wallet, it "subscribes" to more transactions than the ones that
are actually interesting using bloom filters. It creates a bloom
filter and sends it to the full node.

.A wallet creates a bloom filter and sends it to a full node. The full node uses the bloom filter to determine which transactions to send.
image::{imagedir}/summary-bloom-filter.svg[{half-width}]

The full node hashes various stuff from the transactions, for example
public key hashes in outputs, using the three hash functions. If all
bits on those indices are `1` then it will send the transactions. If
not, it will not send the transaction.

==== New release - 6.0!

[%autowidth,options="header"]
.Release notes, cookie tokens 6.0
|===
|Version|Feature|How

.2+|image:{commonimagedir}/new.png[role="gbnew"]*6.0*
| Prevent Lisa from deleting transactions
| Signed blocks in a blockchain

| Fully validating nodes
| Keeps a copy of the whole blockchain

| Lightweight wallet saves data traffic
| Bloom filters and merkle proofs

.3+|5.0
| Spend multiple "coins" in one payment
| Multiple inputs in transactions

| Anyone can verify the spreadsheet
| Make the signatures publicly available in the transactions

| Sender decides criteria for spending the money
| Script programs inside transactions

.3+|4.0
|It is now easy to make payments and create new addresses.
|Mobile app "Wallet"

|Simplify backups
|HD wallets are generated from a seed. Only the seed, 12-24 English
 words, needs to be backed up.

|Create addresses in insecure environments
|HD wallets can generate trees of public keys without ever seeing any of the private keys
|===

Problems:

* Stolen Lisa-key: Can steal rewards and/or "prove" that Lisa is a fraud
* Lisa can censor transactions from entering the blockchain
* Wallets can't verify transaction history, they trust full nodes to do that for them
* Full nodes can censor transactions in the blockchain to wallets

== Exercises

1. The hash functions used to create the bloom filter is not _cryptographic_ hash function. Why not?

////
Caused problem:

Transactions will not be visible until a block is published. No one
wants to wait 10 minutes for a cookie. For now they cc the cafe on
their email to Lisa.

We will solve that in <<ch08>> by having users broadcast their transactions
to the network. Then everyone can see all pending transactions.


Remaining problem:

Transactions are visible on tx@company.com, but Lisa might censor transactions.


Remaining problem: Everybody need to trust the shared folder. An email
administrator can delete transactions and tamper with published blocks
before they are published. But let's trust email for now.

Pruning
////
