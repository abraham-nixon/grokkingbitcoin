[[ch11]]
== Bitcoin upgrades - change consensus rules
:imagedir: {baseimagedir}/ch11

This chapter covers

* Understanding hard forks and soft forks
* Upgrading Bitcoin safely
* Understanding that users make the rules

To understand this chapter you should be comfortable with concepts
like the blockchain (<<ch06>>) , proof-of-work (<<ch07>>) and the
peer-to-peer network (<<ch08>>). If you had difficulties with these
chapters, I suggest that you revisit them before continuing with this
chapter. Of course, you can just try to read on anyway.

When Bitcoin's consensus rules change, it can happen in two
ways. Either via a soft fork or via a hard fork. These two types of
changes are fundamentally different. In <<bitcoin-forks>> We will
learn about the differences between hard and soft forks as well as
understand what happens when different nodes run different consensus
rules. This is very important to understand before starting to learn
how to safely roll out changes in the consensus rules.

Rolling out a consensus rule change over the Bitcoin network can be a
very difficult task. Each Bitcoin node is sovereign and no one
dictates what software people should run. The users decide for
themselves what software to run. This fact makes it very hard to roll
out, or _deploy_, consensus rule changes without having broad user and
miner support. The _deployment mechanisms_ have evolved over time and
we will go through that evolution and explore the current state of
deployment mechanisms.

As of writing, most (non-critical) updates to Bitcoin's consensus
rules have been made via so called _miner activated soft forks_ where
miners signal support and eventually start enforcing the new
rules. However, this comes with some issues, for example a big miner
can veto an upgrade in spite of broad user adoption. People are
looking to solve that with so called _user-activated soft forks_. This
means that power is where power belongs: With the people using
Bitcoin, the _economic majority_.  It is the economic majority that
ultimately and collectively decides the consensus rules, and that
insight is put into practice with user-activated soft forks.

[[bitcoin-forks]]
=== Bitcoin forks

Open source software is software that is free to download, use,
inspect, change, and redistribute as you please. A lot of the software
you use on a daily basis is probably open source. Maybe you use the
Google Chrome web browser or and Android mobile phone? Those are
examples of software built on open source projects.

Open source projects can be _forked_. If you make a copy of the source
code for Linux, make some changes to it, and distribute your new
version of the Linux source code, you have created a _fork_ of the
project.

Bitcoin is an open source project that can be forked just as any other
open source project, like Linux.

Suppose that you want to make a change in the Bitcoin Core
software. You create your own fork of Bitcoin Core. Depending on the
change you make in your fork, the nodes running your forked version
will behave differently.

[.gbinfo]
.Differing definitions
****
There are a few different definitions of a "fork". In this book we use
the definition that the author finds best, which is "a change in the
consensus rules".
****

[.important]

In the context of Bitcoin, we use the term _fork_ to mean a change in
the consensus rules. The consensus rules is the set of rules that
define what a valid blockchain is. When some set of nodes use the same
consensus rules, consensus emerges among them about what the current
UTXO set, "who owns what", is.

For example, the rule that limits the block weight to 4,000,000 WU is
part of the consensus rules. But a _relay policy_ on a node, for
example one that prevents transactions with tiny fees from being
relayed by that node, is not part of the consensus rules.

Your fork can be done in Bitcoin Core, or in a copied version of Bitcoin
Core, or in any alternative Bitcoin full node software program. If
someone runs a full node with your changed consensus rules compared to
other people's full nodes, that person is running a fork.

We generally categorize forks in Bitcoin as

Hard forks:: A hard fork relaxes the consensus rules. Some blocks that
was considered invalid by Old nodes, will be considered valid by New
nodes. Doubling the maximum allowed block weight would be a hard fork.

Soft forks:: A soft fork tightens the consensus rules. All blocks that
New nodes consider valid will also be considered valid by Old nodes,
but some blocks considered valid by Old nodes will be considered
_invalid_ by New nodes. Reducing the maximum allowed block weight
would be a soft fork.

.Soft forks tighten the consensus rules while hard forks widens them, compare with decreasing the maximum block weight and increasing it respectively.
image::{imagedir}/hard-vs-soft-fork.svg[{full-width}]

Changes that don't change the consensus rules, for example changing
the color of the graphical user interface or adding a new feature to
the peer-to-peer networking protocol, are not Bitcoin forks.  However,
they could be forks of a software project in the traditional
sense. From now on we will only use the term _fork_ to mean a change
of consensus rules.

As an analogy of soft and hard forks, imagine a popular vegetarian
restaurant where lots of vegetarians go to eat. This restaurant only
have one dish on their menu. Think of the restaurant as a miner, the
guests as full nodes and the meals served as blocks. The restaurant
produces meals that guests eat - the miner produces blocks that
full nodes accept.

Imagine that the restaurant changes their dish as follows.

****
image::{imagedir}/hard-vs-soft-fork-restaurant.svg[]
****

[%autowidth]
.The restaurant can make a hard fork by adding meat to their dish or a soft fork by restricting the food to vegan.
|===
| Restaurant serves | Will guests accept it? | Fork type | Why

| Vegetarian food | Yes | None | Vegetarians eat vegetarian food.
| Non-vegetarian food | no | Hard fork | The rules are *relaxed*. Vegetarians can't eat here any more
| Vegan food | Yes | Soft fork | The rules are *tightened*. Vegetarian rules still apply.
|===

If you create a fork, soft or hard, you risk having a chain-split if
anyone runs your forked computer program. Some nodes will follow the
strongest chain that is valid according to their old rules and some
nodes, the ones running your software, follow the strongest chain that
is valid according to your new rules. The result might be a split in
the blockchain.

We will work through a few examples to illustrate what happens in
different scenarios. We will start with the simplest case, which is a
change that doesn't affect the consensus rules. We will use the name
_Bitcoin Old_ to refer to the previous version of the program and
_Bitcoin New_ to refer to the changed version of the program.

==== Non-consensus-rule changes

Suppose that you want to add a new "feature" to the networking code of
Bitcoin Core. You want to add a new network message type called
`kill`, that one Bitcoin node can send to another Bitcoin node. The
recipient node of this message will immediately shut itself down. Only
nodes running Bitcoin New would know how to deal with an incoming
`kill` message. Bitcoin Old nodes will just ignore the, for them,
unknown message.

.Your new message will be accepted by Bitcoin New and ignored by Bitcoin Old.
image::{imagedir}/kill-message.svg[{big-width}]

Most people consider your change a huge security risk. They don't want
their nodes shut down by a random stranger on the Internet. You will
have a hard time convincing them to use Bitcoin New. You can't force
this software upon anyone, people will have to actively want it and
install it for Bitcoin New to get adoption across the network.

Stupid changes like the `kill` message will not make it in the world
of open source.

===== Make something useful instead.

[.inbitcoin]
.BIP152
****
This was implemented in Bitcoin Core during 2016 and greatly improved
the block propagation time in the Bitcoin network. BIP152, "Compact
Block Relay", describes this in detail. We only describe a simplified
version here.
****

Suppose that you invent something useful instead. You invent something
called compact blocks. Compact blocks allows a peer to send a block to
another peer, but without sending the full block. Instead, it uses the
fact that the recipient node already has received most of the
transactions in the block. Remember that a transaction first travels
the network during transaction propagation, and then it travels the
network again during block propagation once the transaction is
confirmed.

.Qi gets a transaction twice. First during transaction propagation, second during block propagation.
image::{imagedir}/qi-gets-the-transaction-twice.svg[{full-width}]

When Rashid sends the block to Qi, wouldn't it be great if the block
didn't have to contain all transactions that Qi already has. The
bandwidth requirements would drop dramatically. Rashid can instead
send just the block header and a list of transaction id:s. Qi can then
reconstruct the block from the transactions it already has in memory
and the message from Rashid. In case Qi doesn't have one of the
transactions, Qi will request them from Rashid.

.Compact blocks in action. Rashid sends just the necessary data to Qi.
image::{imagedir}/compact-blocks.svg[{big-width}]

The protocol starts with Rashid sending Qi a `cmpctblock` message. Qi
will use that message to recreate the block using the transactions she
already has in memory. If she succeeds, she's done and can start
verifying the block. If she misses some transactions, she will request
them from Rashid using a `getblocktxn` message containing a list of
indexes of the missing transactions. Rashid will then reply with a
`blocktxn` message containing the missing transactions.

Note that this is a very simplified version of how it actually
works. The main differences are:

1. The `cmpctblock` message can also include some complete
transactions, for example the coinbase transaction of the block.
2. Compact blocks can work in two different modes:
.. High bandwidth mode, `cmpctblock` messages are sent unsolicited
instead of first using an `inv`,
.. Low bandwidth mode, the `cmpctblock` is sent only upon request after
an `inv` has been received.
3. The list of txids sent in the `cmpctblock` messages are not full
txids, but shortened versions to save data traffic, but still long
enough to almost always uniquely identify the actual transactions
used.

This is a really useful change that many people find valuable. You
release your software and people tend to start using it. Everybody
doesn't have to upgrade to this version. If only one of your peers use
it, you will benefit by running it yourself, because the bandwidth
requirements between you and that one peer will decrease. As more and
more nodes start adopting compact blocks, your total bandwidth
requirement will drop even more.

You have not made any changes to the consensus rules. Blocks are
verified using your software exactly as before. The blocks Bitcoin New
produce will be accepted by Bitcoin Old nodes, and vice versa, blocks
produced by Bitcoin Old nodes will be accepted by Bitcoin New
nodes.

==== Hard forks

.Hard fork
****
image::{imagedir}/2ndcol-hard-fork.svg[]
****

As described in <<bitcoin-forks>>, a hard fork is a software change
that relaxes the consensus rules. Blocks created by new nodes might be
rejected by old nodes. In the example with the vegetarian restaurant,
a hard fork would be when the vegetarian restaurant starts to serve
meat.

Suppose that you create a fork that changes the maximum allowed block
weight, discussed in <<increasing-the-block-size-limit>>, from
4,000,000 weight units (WU) to 8,000,000 WU. This would allow for more
transactions to be stuffed into each block. But on the other hand, a
higher limit may have a negative impact on some nodes in the Bitcoin
network as we talked about in <<block-size-limit>>.

Anyhow, you make this change and start using it in the Bitcoin
network. When your node receives a block from a Bitcoin Old node, you
will accept it because the block is definitely ≤ 8,000,000 WU; The
Bitcoin Old node will not create blocks larger than 4,000,000 WU.

Suppose that you're a miner running Bitcoin New and you are lucky
enough to find a valid proof of work, you publish your block. This
block will definitely be ≤ 8,000,000 WU, but it may or may not be ≤
4,000,000 WU. If it is ≤ 4,000,000 WU, it will be accepted by Bitcoin
Old nodes. But if not, your block will be rejected by Bitcoin Old
nodes. Your blockchain will diverge from the Bitcoin Old
blockchain. You have caused a blockchain split.

.Your node running Bitcoin New is a loser against the Bitcoin Old nodes. Bitcoin Old will discard all your blocks that violate the ≤ 4,000,000 WU rule.
image::{imagedir}/hard-fork-single-new-node.svg[{full-width}]

When your Bitcoin New node mines a new block, it might get rejected by
the Bitcoin Old nodes depending on whether it is ≤ 4,000,000 WU
or not. For the blocks that get rejected, you will have wasted a lot
of electricity and time on mining blocks that don't make it into the
main chain.

But suppose that a majority of the hash rate likes your new Bitcoin
New program and start using it instead of Bitcoin Old. What happens
then? Let's see how it plays out:

.A majority of the hash rate runs Bitcoin New. It seems to have caused a permanent chain split.
image::{imagedir}/hard-fork-majority-new-node.svg[{big-width}]

When a New node has mined a big block, all Bitcoin New nodes will try
to extend that new block, but all Bitcoin Old nodes will keep on
trying to extend the latest valid, according to Old rules, block.

The New nodes win more blocks over time than the Old nodes because
they collectively have more hash rate than the Old nodes. It seems
like the New nodes' branch will stay intact because it gets a
reassuring lead in accumulated proof of work.

The new nodes have created a lasting chain split, it seems. But if
some miners decide to go back to running Bitcoin Old, or if additional
miners enter the race using Bitcoin Old nodes, so that Old gets a
majority of the hash rate again, the New chain may be facing problems:

.The New chain is wiped out because the Old chain becomes stronger.
image::{imagedir}/hard-fork-new-chain-reorg.svg[{full-width}]

When Bitcoin Old nodes have a hash rate majority they will outperform
the Bitcoin New nodes and eventually catch up with the New nodes and
surpass them. New nodes acknowledge that fact by switching back to
mining on the Old chain. We say that the branch created by the New
nodes was wiped out by a chain reorganization, commonly known as a
_reorg_.

===== Wipe-out protection

Blocks created by Old nodes in the hard fork above are always
compatible with with New nodes. This means that there is a risk for a
reorg of the Bitcoin New chain.

This is not the case in all hard forks. Suppose for example that you
want to change the proof of work hash function from double SHA256 to
single SHA256. Then your Bitcoin New blocks will always be rejected by
Old nodes, and conversely, blocks created by Bitcoin Old will always
be rejected by Bitcoin New nodes. A change like this is therefore
guaranteed not to get reorged by the Bitcoin Old branch. It's wipe-out
protected by nature, but many changes are not wipe-out protected by
nature.

[.gbinfo]
.Replay protection
****
Bitcoin Cash also implemented something called _replay protection_
that we will cover in <<replay-protection>>. It is used to protect
transactions to appear on both branches of a chain split and
effectively also serves as wipe-out protection.
****

An example of a change that's not wipe-out protected by nature is an
alternative cryptocurrency called _Bitcoin Cash_. It was created
through a hard fork of Bitcoin Core at block height 478559, on
2017-08-01. The main thing they did was to increase the maximum base
block size and remove segregated witness from the code. This would
make the Bitcoin Old chain compatible with Bitcoin New nodes, so they
would be vulnerable to wipe-out. In order to protect against Bitcoin
New being wiped out in a reorg, they _added wipe-out protection_ by
requiring the forking block to be greater than 1,000,000 bytes (1 MB).

.Bitcoin Cash protects against wipe-out by requiring the first block after the chain split to be >1MB.
image::{imagedir}/bitcoin-cash-hard-fork.svg[{big-width}]

The result is that Bitcoin New nodes _cannot_ move back to the the
Bitcoin Old branch, because that branch has a block less than or equal
to 1 MB at height 478559.

==== Soft forks

.Soft fork
****
image::{imagedir}/2ndcol-soft-fork.svg[]
****

We have discussed soft forks several times throughout this book. A
soft fork is a change in the consensus rules where blocks created by
Bitcoin New nodes are accepted by Bitcoin Old nodes. The consensus
rules are tightened. In the case with the vegetarian restaurant, a
soft fork would be when the restaurant changes its food to vegan.

Segregated witness is an example of a soft fork. The change was
carefully designed so that old nodes don't fail in verifying blocks
that contain segregated witness transactions. So all Bitcoin Old nodes will
accept any blocks from Bitcoin New nodes and incorporate them into the
blockchain.

On the other hand, a Bitcoin Old node *could* create a block that is
not valid according to Bitcoin New. For example, a non-segwit miner
could include into its block a transaction that spends a segwit output
as if it was an anyone-can-spend output.

.An Old miner regards a segwit output as anyone can spend and adds a transaction that spends it as such to the block.
image::{imagedir}/spend-segwit-as-anyone-can-spend.svg[{full-width}]

Suppose that there is only a single miner with a small hash rate
running Bitcoin New. Also assume that the Old miners produce a block
that's invalid according to New nodes, as in the example with the
segwit transaction above. The result would be that the Bitcoin Old
nodes build a block that's not accepted by the New miner. The New
miner would reject the invalid Old block. This is the point where the
blockchain splits in two:

.The soft fork may cause a chain split if the Old nodes produce a block that New miners don't accept.
image::{imagedir}/soft-fork-single-new-node.svg[{big-width}]

In this situation, the Bitcoin Old chain is in risk of being wiped out
by a reorg. Suppose that some more miners decide to upgrade to Bitcoin
New and cause a hash rate majority to support the New
blockchain. After a while we will probably see a reorg:

.As people adopt Bitcoin New, your branch will cause a reorg for Bitcoin Old nodes.
image::{imagedir}/soft-fork-majority-new-node.svg[{full-width}]

The Bitcoin New branch will become the stronger branch and therefore,
the remaining Bitcoin Old will abandon their branch and start working
on the same branch as the Bitcoin New nodes. However, as soon as a
Bitcoin Old node creates a block that is invalid on New nodes, it will
will lose out on the block reward, because it will not be accepted on
the Bitcoin New branch.

==== Differences between hard and soft forks

Let's have a look at what differs soft forks from hard forks. As a general rule:

* A Hard fork _relaxes_ the rules. Bitcoin Cash is a hard fork.
* A soft fork _tightens_ the rules. Segregated witness is a soft fork.

This is a very simple, yet true, distinction. The effects of a chain
split caused by a hard fork vs a soft fork can be summarized as
follows:

Hard fork:: The New branch might get wiped out in a reorg. Use wipe-out
  protection to avoid this. The Old branch can not be wiped out.
Soft fork:: The Old branch might get wiped out in a reorg. You can't
  protect the Old branch from wipe-out because that would make this
  fork a hard fork. Remember that the definition of a soft fork is
  that Old nodes accept New blocks.

=== Transaction replay

Regardless the cause of a chain split, its effects are the same. Users
end up with two versions of their UTXOs. One version is spendable on
Old chain and one version is spendable on New chain. We effectively
have two cryptocurrencies, Bitcoin Old and Bitcoin New.

.After a chain split you effectively have two versions of your UTXOs.
image::{imagedir}/utxos-in-chain-split-before-book-purchase.svg[{half-width}]


Suppose that the above chain split has occurred and you want to pay for
a book at an on-line book store.

[.gbinfo]
.Value swings
****
If a chain split occurs it may have severe impact on the value of the
Bitcoins on the Old branch. The value per coin on the Bitcoin New
branch may or may not be known, it depends on if those coins are
widely traded yet.
****

You want to do this using Bitcoin Old, because that's what the book
store wants.

You create your transaction as you've always done and
broadcast it. Your transaction will be accepted by the Bitcoin Old
nodes in the network because you spend a UTXO that exists on those
nodes. But your transaction is _also valid on the Bitcoin New nodes_
because you have the same UTXOs there as well.

.Your transaction to the book store is valid on both the Old branch and the New branch.
image::{imagedir}/old-new-utxo-sets.svg[{big-width}]

If your transaction propagates to a Bitcoin New miner and a Bitcoin
Old miner, it will probably end up in both branches of the blockchain.

.Transaction replay causes you to pay in both currencies
image::{imagedir}/utxos-in-chain-split.svg[{big-width}]

This is not what you intended. Your transactions has been _replayed_
on the Bitcoin New branch.

[[replay-protection]]
==== Replay protection

To protect users against replay during a chain split due to a hard
fork, the transaction format on the new chain can be changed in such a
way that the transaction is only valid on at most one branch.

When Bitcoin Cash did their hard fork, they made sure that
transactions made by Old wallets were not valid on New nodes and that
transactions made by New wallets were not valid on the Bitcoin Old
nodes.

.With replay protection, a transaction is only valid on one of the branches.
image::{imagedir}/bitcoin-cash-replay-protection.svg[{full-width}]

To achieve this, a transaction on the New branch has to use a new
SIGHASH type, FORKID, in all signatures of the transaction. This
SIGHASH type doesn't actually do anything, but using it makes the
transaction invalid on the Old chain and valid on the New chain. If a
transaction doesn't use FORKID, the transaction is valid on the Old
chain and invalid on the New chain.

Using a new SIGHASH type for signatures is of course not the only way
to achieve replay protection. Any change that makes transactions valid
on at most one chain will do. You can for example require that New
transactions subtract `1` from the input txid. Suppose that the UTXO
you want to spend has the txid

[subs=normal]
 6bde18fff1a6d465de1e88b3e84edfe8db7daa1b1f7b8443965f389d8decac**08**

If you want to spend the UTXO on the Old chain, you use that hash in
the input of your transaction. If you want to spend the UTXO on the
New chain, you would use

[subs=normal]
 6bde18fff1a6d465de1e88b3e84edfe8db7daa1b1f7b8443965f389d8decac**07**

instead. Note that this is just a silly example, not a fully fledged
proposal.

// BIP 115 ????		Generic anti-replay protection using Script


[[deployment-mechanisms]]
=== Upgrade mechanisms

All non-urgent upgrades of Bitcoin so far has been made using soft
forks. Doing a soft fork safely is a hard problem, and the mechanisms
used to do them have evolved over time.

The main worry when doing a soft fork is that the blockchain splits in
two and stays that way over a significant amount of time. If that
happens, we effectively have two cryptocurrencies.

This would cause confusion: Exchanges would need to decide which
branch they consider to be "Bitcoin" and which branches to support for
their exchange service. Users must be made aware that a split has
happened so that they can take precaution to not send money on the
wrong branch. Merchants need to make sure that they charge the
currency or currencies they intend to. A blockchain split would
probably also cause the value of the cryptocurrency to change
dramatically.

==== Using coinbase signaling: BIP16

When pay-to-script-hash, p2sh, was introduced in 2012, the Bitcoin
community had no experience in upgrading. They had to come up with a
way to avoid a blockchain split. They implemented soft fork
_signal-ling_ using the coinbase; New miners signal support for p2sh by
putting the string `/P2SH/` into the coinbase of the blocks they
produce.

.A miner signals support for pay-to-script-hash by writing "/P2SH/" in the coinbase's signature script.
image::{imagedir}/p2sh-support-signalling.svg[{half-width}]

[.inbitcoin]
.User-activated soft fork
****
A deployment method where users start enforcing rules has become known
as a User-Activated Soft Fork. We'll talk about this later in this
chapter.
****

On a specific day the Bitcoin developers checked if at least 550 of
the last 1000 blocks contained `/P2SH/`. It did, so they made a new
software release that would start enforcing the p2sh rules on April 1
2012, the so called flag-day.

This worked out well and miners quickly adopted the soft fork and the
whole network upgraded within reasonable time. No split occurred
because at least 50% of the hash rate had upgraded prior to the
flag day.

==== Using incremented block version number signaling: BIP34, 66, 65

We haven't talked about it much before but the block header comes with a
version. The version is encoded in the first four bytes before the
previous block hash.

.The block header contains a block version. The first blocks used version 1. 
image::{imagedir}/header-version-1.svg[{half-width}]

The version is the only thing missing from our previous block
headers. This is the actual 80 byte Bitcoin block header:

----
4 bytes  version
32 bytes previous block id
32 bytes merkle root
4 bytes  timestamp
4 bytes  target
4 bytes  nonce

Total 80 bytes
----

The block version can used to signal support for certain new features.

[.inbitcoin]
.BIP34
****
This BIP, "Block v2, Height in coinbase", describes both how to store
the height in the coinbase and how to deploy the change using version
numbers.
****

The first soft fork deployment using block version was done in
2013. This soft fork added a rule that all new blocks must contain the
height of the block in its coinbase transaction.

.BIP34 requires that all blocks contain the block height in the coinbase.
image::{imagedir}/height-in-coinbase.svg[{full-width}]

The _activation_ of the soft fork was performed in steps using block
version _signaling_ to avoid a blockchain split:

. Miners and full nodes gradually started running the soft fork. The
soft fork increase the block version from 1 to 2. Note that its only
miners that run the soft fork that increase the block version.
+
.Miners that run the soft fork signal support for it by increasing their block version.
image::{imagedir}/header-version-2.svg[{half-width}]

****
image::{imagedir}/relative-hash-rate-75.svg[]
****

[start=2]
. Wait until 750 of the last 1000 blocks have version at
least 2. When this threshold is reached, the New miners probably have
about 75% of the hash rate.

. Start rejecting newly produced version 2 blocks that don't contain
the height in the coinbase. These blocks are falsely signaling for
BIP34.

****
image::{imagedir}/relative-hash-rate-95.svg[]
****

[start=4]
. Wait until 950 of the last 1000 blocks have version >= 2. When this
happens, the New miners have about 95% of the hash rate.

. Start rejecting all new blocks with version 1. All miners producing
version 1 blocks will be losers because 95% of the hash rate rejects
those blocks. The hope is that miners that still haven't upgraded
would do so quickly to not lose too much money on mining worthless
blocks.

During step 1, nothing has changed. Only Old rules are in effect. But
when 750 of the last 1000 blocks have version 2, we enter the next
step. Here, nodes running the soft fork start ensuring that every new
block of version 2 has the height in the coinbase. If not, the block
is dropped. On reason for this is there might be nodes deliberately or
accidentally using block version 2 for other purposes than this soft
fork. The 75% rule removes "false positives" when evaluating the 95%
rule.

From this point, some Old miner _could_ cause a chain split by
creating a block of version 2 that violates the "height in coinbase"
rule.

.The Old nodes could cause a chain split, but it probably won't last for long.
image::{imagedir}/soft-fork-bip34-chain-split.svg[{big-width}]

The Old miners would build on top of that block while the New miners
would build on top of the previous block. However, the New miners
_probably_ (depending on the amount of "false" version 2 signaling)
have more hash rate and will outperform the Old miners and wipe out
their Old branch.

When a greater portion of the blocks, 95% of the last 1000, signals
support with version 2 blocks, the last step, 5, is entered. From this
point forward, all new blocks with version <2 will be dropped.

Why did we go through these stages? It's not entirely clear why the
75% rule was used, but it does remove false positives as described
above. The deployment might have worked fine with just the 95%
rule. We will not explore the rationale behind the 75% rule, just
accept that it was used for this deployment and a few other
deployments. The following soft forks were introduced using this
mechanism:

[[block-version-number-deployments]]
.Features deployed using incremented block version
|===
| BIP | Name | Date | Block version

| BIP34 | Block v2, Height in Coinbase | March 2013 | 2
| BIP66 | Strict DER Encoding | July 2015 | 3
| BIP65 | OP_CHECKLOCKTIMEVERIFY | December 2015 | 4
|===

The upgrade mechanism used above is called a _miner activated_ soft
fork. That's because it's the miners that start enforcing the new
rules and all or most full nodes will follow, because the New blocks
are accepted by both Old and New full nodes.

==== Using block version bits signaling, BIP9

[.inbitcoin]
.BIP9
****
This BIP specifies a standard for how to use the version field of the
block header to perform multiple simultaneous deployments.
****

The developers of Bitcoin collected a lot of experience from previous
soft forks. A few problems needed to be addressed:

* You can only deploy one soft fork at a time.
* Used block versions can not be reused for new purposes.

The most annoying problem is that you can't roll out multiple soft
forks at once. This is because previous deployment mechanisms, for
example the one used for BIP34, checked if the version of a block were
greater than or equal to a certain number, for example 2.

Suppose that you wanted to deploy both BIP34 and BIP66
simultaneously. BIP34 would use block version 2 and BIP66 would use
block version 3. This would mean that you can't selectively signal
support for only BIP66, because you would also have to signal support
for BIP34, because your block's version 3 is greater than or equal
to 2.

===== Solution

They came up with a bitcoin improvement proposal, BIP9, that describes
a process for how to deploy several soft forks simultaneously.

This process also uses the block version, but in a different way. They
decided to change the way the block version bytes are
interpreted. Block versions that has the top 3 bits set to exactly
`001` will be treated differently.

First of all, all such block versions are greater that 4 because the
smallest such block version is `20000000` which is a lot bigger than
`00000004`, so the blocks using BIP9 will always support the already
deployed BIP34, 66 and 65. Good.

Next, the 29 bits to the right of the leftmost `001` bits can be used
to signal support for at most 29 simultaneous soft forks.

.The block version is treated differently. Each of the right 29 bits can signal for different proposals.
image::{imagedir}/version-bits.svg[{full-width}]

Each of the version bits, the 29 right-most bits, can be used to
independently deploy a single feature or a group of features. If a bit
is set to `1`, it means that the miner that produced the block support
the feature represented by that bit number.

A number of parameters need to be defined for each deployable feature:

name:: A short, but descriptive name for the feature.
bit:: The number of the bit to use for signaling.
start time:: What time to start monitoring for miner support.
timeout:: A time when the deployment will be considered failed.

The deployment goes through a number of _states_. The state is updated
_after each retarget period_ as follows:

.State transitions happens every 2016 blocks.
image::{imagedir}/bip9-states.svg[{full-width}]

When comparing block times to the start time and timeout, we always
use median time past as described in <<timestamp-rules>>. This is to
make it harder for miners to manipulate the state transitions and to
make sure that the time to compare for each successive block is
greater than the time to compare of the previous block.

`DEFINED`:: This is the starting state. It means that a retarget
hasn't happened after the start time yet.
`STARTED`:: Wait until at least 1916 (95%) blocks in the last retarget
period signals support.
`LOCKED_IN`:: This state is a grace period to give the remaining
non-signaling miners a chance to upgrade. If they don't, their blocks
might be rejected.
`ACTIVE`:: The new rules are in effect.
`FAILED`:: The timeout occurred before the deployment got
`LOCKED_IN`. Timeout has precedence over other conditions, for example
the 95% rule in case they happen simultaneously.

When the deployment is `ACTIVE` or `FAILED`, the bit used to signal
support should be reset to `0` so that it can then be reused for other
deployments.

==== Use BIP9 to deploy relative lock time

[.inbitcoin]
.BIPs 68, 112, 113
****
This "feature" is actually a group of BIPs that collectively make the
relative lock time work.
****

Let's look at an example of how a deployment using version bits can
play out. We will look at how relative lock time was deployed. The
developers of this new feature defined the following BIP9 parameters:

----
name:       csv
bit:        0
start time: 2016-05-01 00:00:00
timeout:    2017-05-01 00:00:00
----

The timeout was one year after the start time, which gave the miners
about one year to upgrade to the soft fork implementing this feature.

Here are the state transitions that occurred:

.BIP9 deployment of csv. It went well.
image::{imagedir}/bip9-relative-lock-time-states.svg[{full-width}]

/////
let's look at it in a bit finer detail:

.States of the BIP9 deployment of relative lock time.
[%autowidth,role="widetable"]
|===
| State | Date (median time past) | Block height | Why?

| *DEFINED* | 2009-01-03 18:15 | 0    	  | All features are, by definition in BIP9, DEFINED since block 0
| ...     | ...              | ... | ...
| DEFINED | 2016-05-01 00:11 | 409643   | Median past time has passed start time, but retarget period need to finish
| DEFINED | 2016-05-11 04:18 | 411263 | The last block before retarget
| *STARTED* | 2016-05-11 04:29 | 411264 | The first retarget causes state to change to STARTED
| STARTED | 2016-05-24 21:02 | 413280 | Stay in STARTED, because < 1916 (95%) of last 2016 blocks signal support for csv
| STARTED | 2016-06-08 02:02 | 415296 | Stay in STARTED, because < 1916 (95%) of last 2016 blocks signal support for csv
| *LOCKED_IN* | 2016-06-21 04:49 | 417312 | LOCKED_IN because the last retarget period has >= 1916 blocks supporting csv
| *ACTIVE* | 2016-07-04 21:44 | 419328 | Active because it's exactly one retarget after LOCKED_IN
|===
/////
This deployment went fast and smooth. It took only 3 retarget periods
for 95% of the miners to upgrade to the new software.

Unfortunately, all deployments aren't as smooth.

==== Use BIP9 to deploy SegWit

****
image::{imagedir}/segwit-lets-deploy.svg[]
****

The deployment of segregated witness, described in <<ch10>>, also used
BIP9 for its deployment, but things didn't work out as anticipated. It
started out the same way as with csv above. The parameters selected
for this deployment was:

----
name:       segwit
bit:        1
start time: 2016-11-15 00:00:00
timeout:    2017-11-15 00:00:00
----

A new version of Bitcoin Core was released with the above segwit
deployment parameters. Users adopted this new version pretty quickly,
but for some reason, miners seemed hesitant. The signaling plateaued
at around 30% and the deployment process got stuck in the `STARTED`
state:

.The segwit deployment didn't proceed as anticipated.
image::{imagedir}/bip9-segwit-stuck-started.svg[{full-width}]

The deployment of segwit was in risk of failing, entering the `FAILED`
state after timeout. If that happens, a whole new deployment cycle has
to be put in place and executed which may take yet another year.

===== Conflicts of interest

****
image::{imagedir}/segwit2x-double-size.svg[]
****

Another proposal was also discussed in parallel. This proposal was
known as _Segwit2x_. This was a proposal to first activate segwit _and
then_ increase the maximum block weight via a hard fork. This proposal
would use BIP9 with version bit 4 to signal support. Bitcoin Core
didn't show any interest in this proposal, but the Bitcoin Core
software repository was forked under the name btc1 by a group of
people where the proposal was implemented. The threshold would be 80%
of the last 2016 blocks in order to lock in segwit.

There seemed to be a discrepancy between what full nodes wanted and
what miners wanted. Some rumors and theories floated around about
what actually cased this discrepancy. We will not go into that here,
but stick to what we know.

===== A user-activated soft fork

****
image::{imagedir}/uasf.svg[]
****

In the midst of all this, another proposal, BIP148, surfaced that
would start dropping blocks that didn't signal bit 1, segwit, on
2017-08-01. The effect of this would be that nodes running BIP148
would experience a 100% adoption of BIP141, and that would cause
BIP141 to lock in after at most two retargets. This is what's known as
a _user-activated soft fork_. Users, the ones running full nodes,
collectively decide that they will start applying new rules, and if
miners don't comply, their blocks will be discarded. We will talk a
bit more about user-activated soft forks towards the end of this
chapter.

This was an attempt at forcing the deployment of segwit in spite of
hesitant miners.

Some groups, especially the Bitcoin Core team, thought this proposal
was too risky. It could cause a chain split if not a majority of the
hash rate would signal for segwit. But there was also a group of
people wanting to move forward with BIP148 regardless. This caused
some worry in the Bitcoin community.

===== A proposal to bridge the groups

****
image::{imagedir}/2ndcol-bip91-kumbaya.svg[]
****

We had the stalled segwit deployment, an alternate segwit2x fork
coming that many miners seem to want and a group of impatient users
wanting to enforce segwit using BIP148.

To avoid a timeout of the segwit deployment, which would further delay
segwit, and to avoid a possible blockchain split by BIP148, and to
please the segwit 2x crowd, a new BIP was written. BIP91 would satisfy
all of the above groups. It would use BIP9 with a custom threshold:

----
name:       segsignal
bit:        4
start time: 2017-06-01 00:00:00
timeout:    2017-11-15 00:00:00
Period:     336 blocks
Threshold:  269 blocks (80%)
Ceases to be active when segwit (bit 1) is LOCKED_IN or FAILED.
----

This BIP does it a bit differently than normal BIP9 deployments. It
uses a shorter period, 336 blocks instead of 2016 blocks, and it
uses a lower threshold, 80% instead of 95%.

While active, this BIP will behave like BIP148. This means that all
blocks that don't signal bit 1 (segwit) will be rejected. Note how
this is compatible with both BIP148 and segwit2x. It will signal using
bit 4 which is the same bit as segwit2x would use, and it will enforce
segwit lock-in by rejecting non-bit-1-signaling blocks.

The BIP was not implemented in Bitcoin Core, but in a forked version
of Bitcoin Core. This version quickly got broad adoption among miners
and on 2017-07-21 the BIP got LOCKED_IN.

.BIP91 updates its state every 336 blocks instead of the usual 2016. This went fast.
image::{imagedir}/bip91-states.svg[{full-width}]

It activated three days after `LOCKED_IN`. Note that it was mainly
miners who adopted BIP91. Normal users typically used Bitcoin Core
that didn't implement BIP91.

When miners activated BIP91, they started dropping blocks that didn't
signal bit 1 which is the bit for the `segwit` deployment. The result
was that non-bit-1 blocks didn't make it into the strongest chain,
which quickly forced the remaining miners to upgrade to segwit to
avoid mining invalid blocks.

Miners were quickly starting to signal segwit, the original segwit
proposal using bit 1 for its deployment, and it got LOCKED_IN at
2017-08-09 and ACTIVE on 2017-08-24:

.Segwit finally activates thanks to BIP91.
image::{imagedir}/bip9-segwit-active.svg[{full-width}]

Normal non-mining users, merchants and exchanges didn't have to do
anything particular to stay on the strongest chain, since their
software (normal segwit-enabled software) will follow the strongest
valid chain. This means that BIP141 would get LOCKED_IN and ACTIVE for
all users and miners at the same time.

===== Lessons learned

The events that occurred during segwit deployment were not
anticipated. Few people thought that miners would refuse to adopt
BIP141. Yet, that's what happened.

It became clear that BIP9 is not an ideal way to deploy a soft
fork. It gives 5% of the hash rate a veto against it . Since several
miners each control more that 5% of the total hash rate, it means that
any one of these individual entities can block a system upgrade.

[.important]

As we noted in <<trust-in-lisa>>, we pay miners to perform correct,
honest confirmations of transactions. We don't pay them to decide the
rules, we pay them to _follow_ the rules. The rules are decided
collectively by everyone, you and me, by running our Bitcoin software
of choice.

Think about that.

==== User-activated soft forks

To underscore the importance of the economic majority (you, me and
everyone else using Bitcoin), and to avoid having miners vetoing
proposals that the economic majority wants, people started thinking
more about user-activated soft forks.

Let's look at a fictitious example of a user-activated soft fork:

Suppose that 99% of the Bitcoin users (end-users, exchanges,
merchants, etc) want a rule change, for example smaller blocks, which
would be a soft fork. Also suppose that no miner wants smaller blocks
so they all refuse to comply. Suppose also that 99% of the non-mining
full nodes change their software to reject all big blocks after a
certain block height.

What would happen when that block height has passed? Miners that
produce big blocks will build a blockchain that the users will deem
invalid.

.Users start rejecting big blocks. They see no new valid blocks, but plenty invalid (too big) blocks.
image::{imagedir}/uasf-start.svg[{half-width}]

The value of the block rewards in the "miner" chain will be
unknown, because the exchanges don't deal with the miner chain. Miners
will not be able to exchange their block rewards to pay their
electricity bills. Even if the electricity provider takes Bitcoin, the
miners would not be able to pay with their block rewards because the
electricity provider won't accept the miner's blocks as valid. The
electricity provider is also a Bitcoin user, remember?

But if a single miner decides to comply with the users' demand the
blocks produced by that miner will be the only blocks actually
accepted by users.

.One miner decides to go with the users' will and only build small blocks. That miner will be able to pay the bills.
image::{imagedir}/uasf-single-miner.svg[{big-width}]

This single miner will be rewarded for the block it created, because
the economic majority accepts the block. The blocks on the miner (big
block) chain are still pretty worthless since no users accepts
them. On top of that, the single small block miner will be able to
charge more fees than before, because the total amount of block space
is smaller. Not only because the maximum block weight is smaller but
also because the total amount of blocks is smaller.

Some more big block miners will probably realize that they are quickly
running out of money and decide to switch to the user-accepted branch.

.A few more miners realize that it's more profitable to work on the users' branch.
image::{imagedir}/uasf-more-miners.svg[{full-width}]

When more miners move over to the users' branch, that branch will
eventually grow stronger than the big blocks branch. When that
happens, the big blocks branch will get wiped out and the remaining
miners will automatically switch to the small blocks branch, because
the change is a soft fork.

.The users' branch is stronger and wipes out the big blocks branch.
image::{imagedir}/uasf-wipeout-miners.svg[{full-width}]

Users win.

One of the very first soft forks in Bitcoin, the deployment of BIP16
(pay-to-script-hash) was actually a user-activated soft fork. The
deployment was manual in the sense that developers, on a specific day,
manually counted the number of blocks that signaled support and then
decided on a flag-day that they put in the next release of the Bitcoin
software. Then after this date all blocks that didn't comply with the
new rules were rejected by nodes running this software.

To make use of the insights in the recent segwit deployment, a new
deployment mechanism is in the making as of writing. It's generally
called user-activated soft fork. The general idea is to start with a
BIP9-like deployment but with the exception that if the deployment
doesn't get LOCKED_IN well before the timeout, blocks that don't
signal for the fork will be dropped. This will effectively cause 100%
support because non-compliant blocks don't count anymore, and the
deployment would soon get LOCKED_IN.

=== Summary

This chapter has taught you about hard forks and soft forks, and how
to deploy soft forks without splitting the blockchain. We have talked
about several miner-activated soft forks and a few user-activated soft
forks.
////
The difference between hard and soft forks is defined as

[%autowidth]
|===
| Fork type  | Definition                      | Block compatibility | Risks wipe-out

| *Hard* | The consensus rules are *relaxed*   | A New node can create a block that's invalid on Old nodes | New branch
| *Soft* | The consensus rules are *tightened* | An Old node can create a block that's invalid on New nodes | Old branch
|===

The above table is illustrated by the following diagram:
////

Hard forks and soft forks can be illustrated with the following diagram:

.Hard and soft forks compared.
image::{imagedir}/summary-hard-vs-soft-fork.svg[{full-width}]

In a *hard fork* the rules are *relaxed* so that a New block may be
invalid according to Old rules. This means that in case of a
blockchain split, the New branch may get wiped out by the Old branch.

In a *soft fork* the rules are *tightened*. Old blocks may be invalid
according to New rules. In case of a blockchain split, the Old branch
is in risk of a wipe-out.

You can protect a hard fork against wipe-out by deliberately making
the New branch incompatible with the Old branch. For example, Bitcoin
Cash requires the the first block after the split must have a base
size >= 1,000,000 bytes which is invalid according to the Old
rules. You can't protect the Old branch in a soft fork from wipe-out.

To roll out a soft fork, care must be taken not to split the
blockchain. If a split happens and both branches remain active over a
significant amount of time, it will cause a lot of pain for users,
exchanges, miners, etc.

In a miner-activated soft fork (MASF), miners signal support and when for
example 95% of the blocks signal support, the new rules start being
enforced after a grace period. BIP9 standardized this process:

.BIP9 states 
image::{imagedir}/bip9-states.svg[{full-width}]

In a user-activated soft fork (UASF), users start enforcing the rules on a
specific day (or block height). A standard for this is being developed
as of writing, and it will probably be a hybrid of BIP9 and
user-activated soft fork:

.User-activated soft fork states 
image::{imagedir}/uasf-states.svg[{full-width}]

The difference from a pure BIP9 deployment is that the UASF process is
guaranteed to proceed to `ACTIVE` once the node has entered the
`STARTED` state. In the `STARTED` state, the miners have a chance to
move the deployment to `LOCKED_IN` state, but if they don't and the
timeout has passed then the supporting full nodes (including miners
that support the upgrade) will start enforcing the rules anyway.

UASF has been used for deployment of BIP16, pay-to-script-hash, but it
was done manually. Other than that, the community has no real-world
experience with user-activated soft forks.

=== Exercises

==== Warm up

. A soft fork is a change of the consensus rules, but what
characterizes the changes made in a soft fork?

. Suppose that a hard fork causes a blockchain split and the New
branch have 51% of the hash rate. Further suppose that the hash rate
on the New branch drops to about 45%.

.. What event will eventually happen?
.. Why did we say that the event will _eventually_ happen? When does
the event occur?
.. What can the developers of Bitcoin New do to prevent the event from
happening?

. Suppose that an Old node causes a blockchain split due to a soft
fork where 80% of the hash rate runs Bitcoin New. Will the Old branch
of the split last for long? Explain your answer.

. Suppose that you try to deploy a soft fork using BIP9. Your
deployment has just reached the `LOCKED_IN` state. How long do you
have to wait before your rules start being enforced?

==== Dig in

[start=5]
. Suppose that a fork changes the consensus rules such that Old nodes
can create blocks invalid to New nodes, and New nodes can create
blocks invalid to Old nodes:
+
.Some blocks are only valid on Old nodes and some blocks are only valid on New nodes.
image::{imagedir}/ex-hard-soft-fork.svg[{quart-width}]
+
What nodes, (New, Old, both or none), would be able to cause a
blockchain split when this fork is deployed?

. Why is it desirable to have a reassuring majority of the hash rate
supporting Bitcoin New in a soft fork before starting to enforce the
New rules?

. Suppose that a hard fork has caused a permanent blockchain split and
that you are about to make a payment using Bitcoin New. Why is replay
protection desirable in this scenario?

. Suppose that you want to deploy a soft fork using BIP9 with the
following parameters:
+
----
bit:        12
start time: 2027-01-01 00:00:00
timeout:    2028-01-01 00:00:00
----
+
Also assume that the deployment is in `STARTED` state and all blocks
in the current retarget period signal support using bit 12. The last
block, B~1~, in the current retarget period has the following
properties:
+
[subs="normal"]
----
timestamp T~1~:          2027-12-31 23:59:59
median time past MTP~1~: 2027-12-31 23:59:58
----
+
Will this deployment eventually get to the `ACTIVE` state?

. Suppose that you want to make a user-activated soft fork. You find
it hard to convince other users to install your software. What would
happen on the flag-day if just a small percentage (<30%) of the
economy chooses to run your software?

. Suppose that you want to make a user-activated soft fork. Lots of
other users seem to like your soft fork. Say that 80% of the economy
install your fork. Why would miners (even those that don't like your
change) switch to the New rules during this user-activated soft fork?

. In the previous exercise, your soft fork had support from 80% of the
economy. Suppose also that a majority of the hash rate decides to
follow your New rules. What happens with the non-mining nodes that
don't run your fork?

=== Recap

In this chapter you learned that

* We don't want a blockchain split when deploying a fork, because that
  would cause disruption in the Bitcoin economy.

* A hard fork is a consensus rule change that requires every miner to
  upgrade. Otherwise the blockchain will split.

* A soft fork is a consensus rule change that doesn't require
  simultaneous upgrade of the whole network.

* A hard fork will lead to a blockchain split if a majority runs the
  New software, which will cause confusion among users and miners.

* During a blockchain split due to a hard fork you want wipe-out
  protection to make sure the New branch isn't deleted by old nodes.

* In a blockchain split, you want replay protection to let you select
  what branch you want your transactions applied to.

* A miner-activated soft fork, for example one using BIP9 for
  deployment, lets miners deploy a non-controversial soft fork.

* A user-activated soft fork lets users enforce deployment of a soft
  fork. If a hash-rate majority eventually follows, the soft fork
  succeeds without a lasting blockchain split.

////

=== NOTES

BIP141:
Deployed using BIP9
name: segwit
bit: 1
start time: 2016-11-15
timeout: 2017-11-15
LOCKED_IN: 2017-08-09 479808
ACTIVE: 2017-08-24 481824

BIP148:
If segwit not locked in before 2017-08-01, this BIP will be active
2017-08-01 -- 2017-11-15. Not active after segwit locked_in. While
active bit 1 is required. Other blocks will be dropped.

BIP149:
Sets service bit 5 "NODE_UAWITNESS".
Deployed with BIP8 using "segwit" bit 1.
start time: 2017-11-16
timeout: 2018-07-04

NYA (segwit2x):
First signal intent with "NYA" in coinbase.
Then:
BIP9 deployment of segwit
bit: 4
threshold 80%
Double max base block size within 3 months from segwit activation.

BIP91:
Threshold: 269/336 (80%)
name: segsignal
bit: 4
start time: 2017-06-01
timeout: 2017-11-15
LOCKED_IN: 2017-07-21 
ACTIVE: 2018-07-23 477120
Not active after LOCKED_IN
While active, drop non-segwit-signaling (bit 1) blocks

00000020 version
43e5b896e096647ec482ee5724fd474162d5f92a85e808000000000000000000 prevBlock
10d805440f29e72daff5539ac02c3455065b32e42d94f087f7b8909c279c794e merkleRoot
c7529d5a timestamp
a3895517 target
4412ae89 nonce

////
