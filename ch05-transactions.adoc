[[ch05]]
== Transactions - Reducing trust in Lisa
:imagedir: {baseimagedir}/ch05

This chapter covers

* Bitcoin, or cookie token, transactions
* Creating, confirming, verifying transactions
* Programming money, fancy payment types

The payments so far have some serious problems. The worst of them is
that Lisa can steal, which worries some new people. They are hesitant
to use the system if they know Lisa can steal from them.

The main focus of this chapter will be on transactions. Transactions,
which replace our old "Email to Lisa", are pieces of data that
formalizes how users send their payments to Lisa. The transactions
will be stored as-is in the spreadsheet instead of the "To", "From",
"Amount CT" scheme we currently use. This makes it impossible for Lisa
to steal other peoples money, because anyone can now verify all
payments in the spreadsheet.

.Bitcoin transactions
image::{imagedir}/visual-toc-transactions.svg[{big-width}]

We will go deep on transactions and explore how transactions are
programmable, meaning that they are very flexible in what you can do
with them. For example, multi-signature transactions can require two
signatures out of three possible to spend money shared by three
people.

After this chapter the system will have changed a lot: How wallets
create payments, how Lisa verifies payments, and how payments are
stored. And most important, everyone will be able to verify payments
in the spreadsheet.

=== Problems with old system

Lisa is performing valuable work. She makes sure no one cheats. She
does that by verifying digital signatures and checking the balance of
the PKH before confirming a payment. A payment is confirmed by adding
it to the cookie token spreadsheet.

There are a number of problems with this old approach:

* Lisa is getting tired of calculating the balance before approving a
  payment. The ledger is growing and each check becomes more time
  consuming as new payments are added.

* If you have two addresses with 5 cookie tokens each, you need to
  make two separate payments to pay 10 for a cookie. This lays
  unnecessary burden on the sender as well as Lisa. It also bloats the
  spreadsheet with excessive rows.

* Since the company has grown and some people don't know Lisa very
  well, trust in her begins to fade. Some people fear that Lisa will
  steal CT from them in the spreadsheet. Only Lisa can verify
  signatures because only she sees the emails sent to her. So she
  _could_ increase the "Amount CT" column of a payment to her or add a
  row with a false payment from, say John, to Lisa. No one could prove
  Lisa has committed fraud. It doesn't matter that Lisa is the most
  trustworthy human on earth. If people don't know that, they are
  going to assume that Lisa is as greedy as everyone else.

.Bad stuff Lisa *could* do. She wouldn't, but she could.
image::{imagedir}/lisa-could-steal.svg[{big-width}]

[.inbitcoin]
.Minimize trust
****
Minimizing trust between people is what Bitcoin is all about. This is
one step closer to a trustless system, where everyone can verify
everything.
****

Lisa hates that people distrust her. She knows there's not much she
can do to change the coworkers trust in her. An interesting
alternative is to _minimize the trust needed_. She concludes that the
best way to do that is to make everything super-transparent so that
everyone can verify payments. At the same time she will improve how
she verifies that people don't spend money they don't have and how to
spend from multiple addresses at the same time. She invents the cookie
token _transaction_ to solve the three problems outlined above.

=== Pay using a transaction

Transactions will replace both how a user's wallet sends a payment to
Lisa and what is stored in the spreadsheet. It will not change how
wallets behave from a user's perspective, the wallet app will look
exactly the same.

Suppose that John wants to buy a cookie in the cafe. John will not
make a "Email to Lisa" as he has done so many times before. The wallet
software now uses _transactions_, so his wallet will create a
transaction instead. The purpose of the transaction is to pay 10 CT to
the Cafe's CT address.

.The payment process is the same for users, but very different for Lisa and the spreadsheet.
image::{imagedir}/wallet-payment-process-transactions.svg[{big-width}]

John scans the cafe's payment URI and his wallet creates a transaction
and asks John to accept it. He clicks OK, and the wallet signs the
transaction. John's wallet then sends the signed transaction as an
attachment in an otherwise empty email to Lisa.

The transaction contains information on where to send money. But it
also contains information on _what money_ to spend by referencing
specific "coins", called _unspent transaction outputs_, that John has
received in previous transactions.

Lisa verifies that the coins the transaction spends exist and that
they are not already spent. She also verifies that the signatures,
there may be several in a transaction, are valid. If all checks pass,
Lisa confirms the transaction by appending it, exactly as she
received it, to the end of the spreadsheet.

Once the transaction hits the spreadsheet, anyone can make the exact
same verification of that transaction as Lisa did. They do this to
verify that Lisa doesn't steal money from someone else, or otherwise
mess with other people's money.

We will dig deeper into the three phases create, confirm, and verify
in the next three subsections.

==== Create the transaction

****
.John's transaction
- [ ] *create (John)*
- [ ] confirm (Lisa)
- [ ] verify (anyone)
****

Let's dive in and have a closer look at how John's transaction is
created.

.John's wallet prepares to pay 10 CT for a cookie. He uses both his keys with funds to cover the cost. He pays himself the change of 3 CT to a fresh address. The transaction is not yet signed.
image::{imagedir}/transaction.svg[{big-width}]

John's wallet has created a new transaction. The new transaction has
two _inputs_ and two _outputs_. Inputs specify what outputs of
previous transactions to spend. Outputs specify where the money goes.

===== Inputs

The inputs specify what transaction outputs to spend. John has two
unspent transaction outputs, one with 8 CT and one with 5 CT. The
unspent outputs belongs to two different previous transactions,
transaction 1 and transaction 2 that payed money to John. Now John
wants to spend these unspent transaction outputs.

****
image::{imagedir}/txid.svg[]
****

A transaction input references a previous transaction using its
_transaction id_ (txid). The txid of a transaction is the double
SHA256 hash of the transaction. It is called a transaction _id_
because this hash is often used to refer to the transaction, as in the
case with inputs in the picture above.

His first input, with index 0, contains

* the txid of transaction 1
* the index, 1, of the output in transaction 1 to spend.
* an empty placeholder for signatures

His second input, with index 1, contains

* the txid of transaction 2
* the index, 0, of the output in transaction 2 to spend.
* an empty placeholder for signatures

John will fill in the signatures last after the transaction is
otherwise complete.

===== Outputs

A transaction output contains an amount and a public key hash, PKH. In
John's transaction there are two outputs. Output at index 0 pays 10 CT
to PKH~C~, the Cafe, for the cookie. The output at index 1 pays 3 CT
back to one of John's own keys, PKH~3~. We call this _change_ because
it resembles traditional change where you pay $75 with a $100 bill and
get $25 back as change: John pays with 13 CT and gets 3 CT back to his
change address PKH~3~. Change is needed because you cannot partly
spend a transaction output. You either spend it completely, or you
don't spend it.

The outputs and inputs are a bit more advanced that just specifying a
PKH in an output and a signature in the input. In reality the output
contains a tiny computer program that will verify the signature in the
spending input. We will talk more about that later.

[.inbitcoin]
.Transaction fee
****
Normally you need to pay a transaction fee in order for the Bitcoin
network to process your transaction.
****

For a transaction to be valid, the sum of the amounts of the inputs
must be greater than or equal to the sum of the output amounts. The
difference, if any, is called a transaction fee, which we will discuss
in <<ch07>>. For now, John pays no transaction fee, so his output sum
matches the input sum exactly.

The transaction is now created, but it is not yet signed. Anyone could
have created this transaction because it is based completely on public
information. The inputs just refer to transactions in the spreadsheet
and indexes within those transactions. But only John will be able to
sign this transaction because only he has the private keys
corresponding to PKH~1~ and PKH~2~.

[[sign-transaction]]
===== Sign the transaction

John clicks OK in his wallet to approve the signing of the
transaction. The wallet now needs to make two signatures, one
signature for PKH~1~ and one signature for PKH~2~. This is because
John must prove that he has both the private key for PKH~1~ and the
private key for PKH~2~.

.John's wallet signs the transaction. Each input gets its own signature. The public key is also needed in the inputs because anyone should be able to verify the signature.
image::{imagedir}/sign-transaction.svg[{big-width}]

Each of the inputs needs to be signed individually. For example, the
private key corresponding to PKH~1~ must be used to sign the input at
index 0, because that input spends money addressed to
PKH~1~. Similarly, the private key corresponding to PKH~2~ must be
used for the signature of input at index 1, because it spends money
addressed to PKH~2~.

Each signature will _commit to_ the whole transaction, excluding
signatures. This means that the whole transaction (excluding
signatures) will be hashed by the signing algorithm. So if anything
changes in the transaction, any signature made for this transaction
will become invalid.

We sign a cleaned version of the transaction to make verification
easier. You can not put a signature in input 0 and _then_ sign
input 1. Verification would become hard if the person verifying don't
know in what order the signatures were made. If you make _all_
signatures from a cleaned transaction and _then_ add all signatures to
it, then it doesn't matter in what order the signatures were made.

When all signatures have been made, they are added to the
transaction. But there's still one piece missing. How can someone, for
example the cafe, verifying the transaction know what public key to
use for verification of a signature? The cafe can only see the PKH in
the spent output and the signature in the spending input. They cannot
get the public key from the PKH, because cryptographic hashes are
one-way functions, remember? John's wallet must explicitly add the
corresponding public key to the input. The signature in input 0 that
spends money from PKH~1~ needs to be verified with the public key that
PKH~1~ was generated from. Similarly, input 1 gets the public key
corresponding to PKH~2~.

==== Lisa confirms the transaction

****
.John's transaction
- [x] create (John)
- [ ] *confirm (Lisa)*
- [ ] verify (anyone)
****

The transaction is ready to be sent to Lisa. It is sent to Lisa as an
attachment in an email. Lisa picks up the transaction and verifies that

* the transaction spends outputs of transactions that actually exist
  in the spreadsheet
* the spent outputs are not already spent by some other transaction in
  the spreadsheet.
* the total value of the transaction outputs doesn't exceed the total
  value of the transaction inputs. Otherwise the transaction would
  create new money out of thin air.
* the signatures are correct

Note that Lisa don't have to calculate the balance of the
PKH anymore, but she needs to check that the spent output exist and
that it's not already spent.

How does she check that an output of a transaction is unspent? Doesn't
she have to search through the spreadsheet to look for transactions
that spend this output? Yes she does. That seems about as cumbersome
as searching through the spreadsheet to calculate balances. Don't
worry, Lisa has a plan for that.

===== Unspent transaction output set (UTXO set)

[.inbitcoin]
.UTXO set
****
All computers in the Bitcoin network maintain a private UTXO set to
speed up verification of transactions.
****

To make the unspent checks easier she creates a new, private, database
that she calls the _unspent transaction output set_ (UTXO set). It is
a set of all _unspent transaction outputs_ (UTXOs).

.Lisa verifies that John doesn't double spend by using her UTXO set.
image::{imagedir}/utxo-set.svg[{big-width}]

An entry in the UTXO set consists of a transaction id (txid), an index
(idx) and the actual transaction output. She keeps her UTXO set
updated while verifying transactions.

[.gbinfo]
.Double spend
****
Double spend means to spend the same output twice. Lisa can easily
prevent double spends by consulting her UTXO set.
****

Before Lisa adds John's transaction to the spreadsheet she makes sure
that all outputs that the transaction spends are in the UTXO set. If
not, it means that John is trying to spend money that either

* never existed in the spreadsheet.
* or are already spent. We usually refer to this as a double spend
  attempt.

For each input in John's transaction, she uses her UTXO set to look up
the txid and the output index. If all spent outputs were present in
the UTXO set it means that no double spend attempt or spending of
non-existent coins was detected. In this case Lisa finds both outputs
in her UTXO set and starts verifying signatures.

Lisa needs to verify the signatures of both inputs of John's
transaction.

.Lisa verifies the first signature of John's transaction.
image::{imagedir}/verify-signatures.svg[{full-width}]

She has already looked up the unspent transaction outputs in her UTXO
set, so she grabs the PKH from the output spent by the first input and
verifies that it matches the hash of the public key in the input. She
then proceeds to verify the actual signature in the input using the
public key, the signature and the transaction itself. It's good. Then
she verifies the second input's signature in the same way. Both
signatures are good.

Lisa then adds the transaction to the spreadsheet. She has now
_confirmed_ the transaction.

.Lisa adds the transaction to the spreadsheet and removes the spent outputs from the UTXO set.
image::{imagedir}/utxo-set-update.svg[{big-width}]

When she confirms the transaction, she must remove the newly spent
outputs from the UTXO set and add the outputs of John's transaction to
the UTXO set. This is how she keeps it updated to reflect the contents
of the transaction spreadsheet.

[.gbinfo]
.UTXO set can be rebuilt
****
The UTXO set is built from the transactions in the spreadsheet
only. It can be recreated at any time and notably by anyone with read
access to the spreadsheet.
****

Lisa keeps this UTXO set up-to-date at all times by updating it like
above for every incoming transaction. But we should note that if she
loses the UTXO set, she can recreate it from the spreadsheet by
starting with an empty UTXO set and re-apply all transactions in the
spreadsheet to the UTXO set one by one.

It's not only Lisa who can create a UTXO set. Now, anyone with access
to the spreadsheet can do the same. This is going to be important in
later chapters when we replace Lisa with multiple persons doing
Lisa's job. It's also important for people just wanting to verify the
spreadsheet to convince themselves that the information in it is
correct.

==== Anyone verifies the transaction


****
.John's transaction
- [x] create (John)
- [x] confirm (Lisa)
- [ ] *verify (anyone)*
****

Now that John's transaction is stored in the spreadsheet exactly as he
created it, anyone with read access to the spreadsheet can
verify it. Anyone can create a _private_ UTXO set and work through all
transactions and end up with the exact same UTXO set as Lisa.

[role="important"]
This means that anyone can make the same checks as Lisa
does. They can verify that Lisa is doing her job. These verifiers are
very important to the system because they make sure that updates to
the spreadsheet obey the agreed-upon rules.

In Bitcoin these verifiers are called _full nodes_. Lisa is also a
full node (a verifier), but she does more than a full node, she
updates the spreadsheet. A full node is also called a verifying node,
or more casually a _node_, in Bitcoin.

****
.John's transaction
- [x] create (John)
- [x] confirm (Lisa)
- [x] verify (anyone)
****

Lisa can no longer steal someone else's money because that would make
the spreadsheet invalid. For example suppose that she tried to change
a recipient of an output of John's transaction PKH~C~ to PKH~L~. She
effectively tries to steal 10 CT from the cafe.

.Lisa cannot steal someone else's money anymore. The signatures will become invalid and disclose her immoral act.
image::{imagedir}/lisa-steals-from-transaction.svg[{half-width}]

Now, since Lisa have changed the contents of John's transaction, the
signatures of that transaction will no longer be valid. Anyone with
access to the spreadsheet will be able to notice this because
everything is super-transparent in the spreadsheet.

===== Security consequences of public signatures

The good thing with public signatures is that anyone can verify all
transactions. But there is a slight drawback. Remember in <<ch03>>
when we introduced public key hashes? One of the good things of using
public key hashes was that the public key is not revealed in the
spreadsheet. This protects money by two layers of security: the public
key derivation function and a cryptographic hash function
(SHA256+RIPEMD160). If the public key was revealed, we rely solely on
the public key derivation function to be secure. It was like a belt
and suspenders type of thing. But now, when an output is spent, the
public key is revealed in the input of the spending transaction. Look
 at John's transaction again:
 
.The input reveals the public key. We made extra effort to avoid just that in chapter 3.
image::{imagedir}/input-reveals-pubkey.svg[{big-width}]

[.gbinfo]
.Don't reuse addresses
****
Bitcoin addresses should not be reused. Address reuse degrades both
security and privacy.
****

The input contains the public key. But it only reveals the public key
once the output is spent. This brings up a very important point: Don't
reuse addresses! If John would have other unspent outputs to PKH~1~,
those outputs are now less secure, because they are no longer
protected by the cryptographic hash function; Only the public key
derivation function.

While address reuse degrades the security of your private keys, it
also degrades your privacy, as discussed in <<ch03>>. Suppose again
that John would have other outputs to PKH~1~. If Acme insurances
forces the cafe to reveal that it was John who bought the cookie, Acme
would also know that all outputs to PKH~1~ belongs to John. This goes
for change outputs too.

Luckily, the wallets will automate key creation for you, so you
usually don't have to worry about key reuse. Most Bitcoin wallets on
the market today, will use unique addresses for all your incoming
payments.

==== Account based and value based systems

Let's reflect a bit on the changes we have made. We have moved from a
so-called _account based_ system to a so-called _value based_ system.

An account based system keeps track of how much money each
account has. This is the type of system we had before this
chapter. Lisa had to calculate the balance of a public key hash before
deciding whether to allow a payment.

A value based system keeps track of "coins" instead. In this chapter
Lisa needs to verify that the specific coins (unspent transaction
outputs) exists before deciding whether to allow the payment. She
doesn't have to verify the balance of any public key hash. Bitcoin is
also a value based system.

=== Script

I haven't been totally honest about what a transaction contains. An
output of a transaction does not just contain a PKH. Instead, it
contains part of a small computer program. This part is called
pubkey script. The input that spends the output contains the other part
of this program. This other part, the signature and the public key in
John's transaction, is called signature script.

.The signature script is the first part of a program. The pubkey script in the spent output is the second part. If the complete program results in "OK", then the payment is authorized to spend the output.
image::{imagedir}/script.svg[{big-width}]

This tiny program, written in a programming language called Script,
contains the instructions to Lisa on how to verify that the spending
transaction is authentic. If Lisa performs all instructions in the
program without errors and the end result is "OK", then the
transaction is authentic.

The ability to write a computer program inside a transaction is very
useful for various use cases. We will cover several use cases of
customized programs throughout this book.

Now Suppose that Lisa wants to verify input 0 of John's
transaction. She will run this program from top to bottom. A _stack_
is used to keep track of intermediate calculation results. The stack
is like a pile of stuff. You can add stuff on top of the stack and you
can take stuff off from the top of the stack.

Let's start

image::{imagedir}/execute-script-1.svg[{big-width}]

The first (top) item in the program is a signature. A signature is
just data. When we encounter ordinary data, we will put it on the
stack. Lisa puts the signature on the previously empty stack. Then she
encounters a public key which is also just data. She puts that on the
stack as well. The stack now contains a signature and a public key,
with the public key being on top.

image::{imagedir}/execute-script-2.svg[{full-width}]

The next item in the program is `OP_DUP`. This is not just data, this
is an operator. An operator makes calculations based on items on the
stack, and in some cases the transaction being verified. This specific
operator is simple, it means "Copy the top item on the stack (but keep
it on the stack) and put the copy on top". Lisa follows orders and
copies the public key on the stack. Now we have two public keys and a
signature on the stack.

The next item is also an operator, `OP_HASH160`. This means "Take the
top item off the stack and hash it using SHA256+RIPEMD160 and put the
result on the stack.". Cool, Lisa takes the top public key from the
stack and hashes it and puts the resulting PKH on top of the
stack. This happens to be John's PKH~1~ because it was John's public
key that was hashed.

image::{imagedir}/execute-script-3.svg[{full-width}]

The next item is just data. It's PKH~1~, which is the rightful
recipient of the 8 CT. Data is just put on top of the stack, so Lisa
puts PKH~1~ on the stack.

Next up is another operator, `OP_EQUALVERIFY`. This means "Take the
two top items from the stack and compare them. If they are equal,
continue to next program instruction, else quit the program with an
error. Lisa takes the two PKH items from the top of the stack and
verifies that they are equal. They are equal, which means that the
public key John has provided in his transaction's signature script
matches the PKH that was set as recipient in the output.

.John's cleaned transaction
****
image:{imagedir}/2ndcol-unsigned-tx.svg[]
****

The last operator, `OP_CHECKSIG`, means "Verify that the top public
key on the stack and the signature that's next on the stack correctly
signs the transaction. Put `true` or `false` on top of the stack
depending on the verification outcome". Lisa takes John's transaction
and cleans out all the signature script from all inputs. She uses the top two
items from the stack, which is John's public key and his signature, to
verify that the signature signs the cleaned transaction. When John
signed this transaction, he signed the transaction without any
signature data in the inputs. This is why Lisa must first clean out
the signature script data from the transaction before verifying the
signature. The signature was good, so Lisa puts `true`, meaning "OK",
back on the stack.

Look, the program is empty! There is nothing left to do. After running
a program, the top item on the stack reveals whether the spending of
the output is authentic. If `true`, "OK", then it means that the
spending is authorized. If `false`, meaning "not OK", then the
transaction must be declined. Lisa looks at the top item on the stack,
and there is an "OK". Lisa now knows that John's input with index 0 is
good.

.The first input is verified.
image::{imagedir}/script-ok.svg[{half-width}]

Lisa does the same checks for the other input, with index 1, of John's
transaction. If that program also ends with "OK", then the whole
transaction is valid and she can add the transaction to the
spreadsheet.

==== Why use a program?

[role="important"]
The pubkey script part of the program stipulates exactly
what the spending transaction needs to provide to spend the
output. The only way to spend an output is to provide a signature
script that makes the program finish with an "OK" on top of the stack.

In the example above, the only acceptable signature script is a valid
signature followed by the public key corresponding to the PKH in the
pubkey script.

[.inbitcoin]
.Operators
****
There are a lot of useful operators that can be used to create all
kinds of fancy programs. Check out <<web-op-codes>> for a complete list.
****

We have already mentioned that "pay to PKH" is not the only way
to pay. You can write any program in the pubkey script. For example,
you can write a pubkey script that ends with "OK" only if the
signature script provides two numbers whose sum is 10. Or a program
that ends with "OK" only if the signature script contains the SHA256
pre-image of a hash. Consider this example:

 OP_SHA256
 334d016f755cd6dc58c53a86e183882f8ec14f52fb05345887c8a5edd42c87b7
 OP_EQUAL

This will let anyone who knows an input to SHA256 that result in the
hash `334d016f...d42c87b7` to spend the output. We happen to know from
<<ch02>> that the text "Hello!" will give this specific
output. Suppose that your signature script is

 Hello!

Run the program to convince yourself that it works, and that all
signature scripts that doesn't give the specific hash fails.

==== Why signature script and pubkey script?

[.inbitcoin]
.Odd names
****
Bitcoin developers commonly use the term scriptPubKey for the pubkey
script and scriptSig for the signature script because that's how they
are named in the Bitcoin Core source code.
****

You may wonder why we call the output script part pubkey script when
it usually doesn't contain a public key? Likewise the input script is
called signature script, but it doesn't only contain a signature.

Historically, the pubkey script in Bitcoin transactions used to
contain an actual public key and the signature script used to contain
the signature only. It was more straight forward then. A typical
pubkey script looked like this:

 <public key> OP_CHECKSIG

and the signature script like this:

 <signature>

Things have change since then but the names signature script and
pubkey script remains. Most developers today look at it in a more
abstract way: The pubkey script can be regarded as a public key and
the signature script can be regarded as a signature, but not
necessarily ordinary public keys and signatures. In a normal payment
today the "public key" is the script that needs to be satisfied by the
"signature", the signature script. Of course the "public key" here
contains some operators an a PKH, but we can still view it as a public
key on a conceptual level. The same goes for the signature script that
can be viewed as a signature on a conceptual level.

=== Where were we?

****
image::{commonimagedir}/periscope.gif[]
****

This chapter covers most aspects of transactions. Look at this picture
from <<ch01>> to recall how a typical transaction is sent:

.This chapter covers transactions. Right now we are exploring different ways to authenticate transactions.
image::{imagedir}/periscope-transactions.svg[{half-width}]

We have gone through the anatomy of the transaction and now we are
discussing different ways to authenticate, "sign", transactions.

=== Fancy payment types

.Pay to hash
****
 OP_SHA256
 334d...87b7
 OP_EQUAL
****

John's transaction just spent a so called pay-to-public-key-hash
(p2pkh) output. But as noted earlier, other types of payments are
possible. For example, pay-to-hash, where you pay to a SHA256 hash. To
spend that output you need to provide the pre-image of the hash. We
will explore some more interesting and useful ways to authenticate
transactions.

==== Multiple signatures

In p2pkh, the recipient generates a cookie token address that is
handed over to the sender. The sender then makes a payment to that
address.

But what if the recipient would like her money secured by something
other than a single private key? Suppose that Faiza, Ellen and John
wants to raise money for charity from their coworkers.

They could use a normal p2pkh address that their supporters donate
cookie tokens to. They can let, say, Faiza have control over the
private key, so only she can spend the funds. There are a few problems
with this approach:

****
image::{imagedir}/flyer-p2pkh-address.svg[]
****

. If Faiza dies, the money might be lost forever. Ellen and John will
not be able to recover the funds.
. If Faiza is sloppy with backup, the money might get lost. Again,
Ellen and John will not be able to recover the funds.
. If Faiza is sloppy with her private key security, the money might
get stolen.
. Faiza might run away with the money.

There seems to be a lot of risks with this setup, but what if Faiza
gives the private key to her two charity partners? Then all partners
can spend the money. That will solve 1 and 2, but problem 3 and 4
would be three orders of magnitude worse, because now any of the three
partners may be sloppy with private key security or run away with the
money.

The organization consists of three people. It would be better if the
three persons could _share the responsibility and the power over the
money_ somehow. Thanks to the Script programming language, this can be
accomplished.

They can create one private key each and demand that two of the three keys
must sign the transaction.

.Multisignature setup between Faiza, Ellen and John. Two of the three keys are needed to spend money.
image::{imagedir}/multisig-transaction.svg[{half-width}]

This brings some good properties to their charity fund raising account:

* If one of the three keys is stolen, the thief cannot steal the
money.
* If one of the three keys is lost due to sloppy backups or death,
then the other two keys are enough to spend the money.
* No single person of the three partners can single-handedly run away
  with the money.

Let's have a look at how a script program that enforces the 2-of-3
rule looks:

[.inbitcoin]
.Bug
****
There is a bug in Bitcoin software that causes `OP_CHECKMULTISIG` to
need an extra dummy item first in the signature script.
****

.A program that enforces 2 signatures out of 3 possible keys. The secret sauce is OP_CHECKMULTISIG.
image::{imagedir}/multisig-program.svg[{half-width}]

The `OP_CHECKMULTISIG` operator instructs Lisa to verify that the two
signatures in the signature script are made with the keys in the
pubkey script. Lisa follows the instructions and runs the program as
follows:

image::{imagedir}/execute-multisig.svg[{big-width}]

The top 8 data items in the program are put on the stack and then the
only operator, `OP_CHECKMULTISIG` is run. `OP_CHECKMULTISIG` takes a
number, 3 in this case, from the stack, then it expects that number of
public keys from the stack followed by another number. This second
number dictates how many signatures are needed to spend the money. In
this case it is 2. Then the expected number of signatures are taken
from the stack followed by a dummy item mentioned earlier. We don't
use the dummy item. The `OP_CHECKMULTISIG` uses all this information
and the transaction itself to determine if enough signatures are made
and verifies those signatures. If everything is OK, it puts "OK" back
on the stack. This is where the program ends. Since the top item on
the stack is "OK", the spending of the output is authorized.

****
image::{imagedir}/flyer-scriptpubkey.svg[]
****

Coworkers that want to donate cookie tokens need to write the
pubkey script above into their transaction outputs. There are a few problems
with this:

* The coworkers' wallets only knows how to make p2pkh outputs. The
  wallets need to be modified to understand multi-signature outputs
  and to include a user interface to make this kind of output
  understandable to users.
* Senders usually don't need to know how the money is protected. They
  don't care if it's multi-signature, p2pkh, or anything else. They
  just want to pay.
* Transactions usually need to pay a fee to get processed (more on
  this in <<ch07>>). This fee depends on how big, in bytes, the
  transaction is. A big pubkey script causes the sender to pay a
  higher fee. That's not fair, because it's the recipient that wants
  to use this fancy expensive feature. It should be payed for by the
  recipient, not the sender.

All this can be fixed with a small change to how the programs
are run. Some developers invent something called pay-to-script-hash,
p2sh.

[[pay-to-script-hash]]
==== Pay to script hash (p2sh)

We have previously discussed how p2pkh hides the public key to the
sender. The sender gets a hash of the public key to pay to, instead of
the public key itself.

Pay to script hash (p2sh) takes that idea even further, it hides the
script program itself. Instead of giving a big, complicated script
pubkey script to the sender, you give just the hash of the script to
the sender. The sender then makes a payment to that hash, and leave it
up to the recipient to provide the script later when the recipient
wants to spend the money.

Suppose, still, that Faiza, Ellen and John wants to raise money for
charity and they want a multi-signature setup to protect their money.

[.inbitcoin]
.BIP16
****
This type of payment was introduced 2012 in BIP16. It could be
introduced smoothly; Old software would allow these transactions
because running the program would leave the top stack item with "OK".
****

.Overview of pay-to-script-hash. The pubkey script is very simple. The signature script is special, because it contains a data item that contains program.
image::{imagedir}/p2sh-overview.svg[{big-width}]

You need new software in order to verify this transaction in full. We
will talk about how this transaction is verified by new software in a
moment. But first, let's see how old software would handle this
transaction.

===== Old software

What if the person verifying the transaction hasn't upgraded her
software to the bleeding edge version that supports verifying
pay-to-script-hash payments? The developers made this forward
compatible, meaning that old software will not reject these new
transactions.

[.gbinfo]
.Why verify
****
The cafe is not involved in this transaction, why would the cafe want
to verify this transaction? The cafe wants to know if Lisa is doing
her job. It's in the cafe's interest to know if something fishy is
going on.
****

Let's pretend the cafe runs old software to verify this transaction in
the spreadsheet. Old software will do what it has always been doing;
Push the stuff in the signature script and then run the pubkey script:

image::{imagedir}/execute-p2sh-old-client.svg[{full-width}]

The program is finished and the top item on the stack is `true`, or
"OK". This means that the payment is valid according to this old
software.

You may recognize the pubkey script from our example earlier when you
can pay money to a pre-image of a hash. That's what happened here too,
but with a different cryptographic hash function. The old software
interpret this program as a payment to a hash. Whoever can show a
pre-image of this hash gets the money. The actual multi-signature
program contained in the redeemScript is never run.

It's important for Lisa that she runs the latest software. If Lisa
would run old software she would only verify that the hash of the
redeem script matches the script hash in the pubkey script. This means
that anyone that happens to know the redeem script (but can't single
handedly sign), for example Faiza, would be able to take the money in
the spreadsheet. Lisa would gladly confirm that transaction. This
would cause problems if a any verifying nodes run new software. Those
nodes will not accept the transaction in the spreadsheet because it is
invalid according to the new rules. The whole spreadsheet would then
be invalid and unacceptable for new nodes from that point forward. We
will discuss this situation more in <<ch11>>.

[[p2sh-new-software]]
===== New software

Now suppose that the Cafe just upgraded their software and wants to
verify this transaction again. Let's see how that happens.

The new software looks at the pubkey script to determine if this
transaction is spending a p2sh output. It looks for the pattern

 OP_HASH160
 20 byte hash
 OP_EQUAL

If the pubkey script has this exact pattern, the p2sh pattern, the
program will be treated differently. First, the exact same seven steps
as the old software above are performed, but the stack is saved away
after step 2. Let's call this the "saved stack". If the first seven
steps result in "OK", then the stack is replaced by the saved stack
and the top item, the redeem script, is taken off the stack:

image::{imagedir}/execute-p2sh-new-client-1.svg[{big-width}]

This redeemScript is a data item that contains a program as previously
described. This program is now entered into the program area and
begins to execute.

image::{imagedir}/execute-p2sh-new-client-2.svg[{full-width}]

It executes from now on as if it was an old style payment.

==== Pay to script hash addresses

Faiza, Ellen and John have created their 2-of-3 multi-signature
redeemScript:

 2
 022f52f2868dfc7ba9f17d2ee3ea2669f1fea7aea3df6d0cb7e31ea1df284bdaec
 023d01ba1b7a1a2b84fc0f45a8a3a36cc7440500f99c797f084f966444db7baeee
 02b0c907f0876485798fc1a8e15e9ddabae0858b49236ab3b1330f2cbadf854ee8
 3
 OP_CHECKMULTISIG

Now they want people to pay to the SHA256+RIPEMD160 hash of the
redeemScript, specifically

 04e214163b3b927c3d2058171dd66ff6780f8708

****
image::{imagedir}/flyer-pay-to-what.svg[]
****

How do Faiza, Ellen and John ask people to pay them? What do they
print on the flyers so that coworkers can pay to their script hash?
Let's look at a few of their options:

* Print the script hash as-is and inform them that this is a hash of a
redeemScript, but then they would expose coworkers to unnecessary
risks of typing errors, just as with payments to raw public key
hashes, as discussed in <<ch03>>.
* Base58check encode the script hash just as in <<ch03>>, that would
generate an address like `1SpXyWt143RceMvcHidnZSVfEuZRMmEMZ`. If this
address was printed on the flyers, they would also need to inform the
users that they must create a p2sh output instead of a normal
pay-to-public-key-hash (p2pkh).

In both of the above cases, if the donor erroneously makes a p2pkh
payment using the printed hash or address, the money cannot be spent
by anyone, because there is no private key corresponding to this false
"public key hash".

The above options seems neither safe nor practical. Instead, let's
introduce a new address format for p2sh, which we call a
_pay-to-script-hash address_. This format is very similar to normal
cookie token addresses. It uses the base58check encoding scheme just
as normal p2pkh addresses did.

.Create a p2sh address. The difference from normal addresses is the version which is 5 for p2sh addresses instead of 0.
image::{imagedir}/p2sh-address-encoding.svg[{big-width}]

This process is almost the same as for pay-to-public-key-hash, p2pkh,
addresses. The only difference is that the version is changed from
`00` to `05`. This will cause the address to begin with a `3` instead
of a `1`.

Because of this change and the way the base58 works, using integer
division by 58 successively, the last remainder will always be 2. For
the interested reader, we provide the base58 encoding of the versioned
and checksummed script hash of Faiza's, Ellen's and John's
redeemScript.

.Encode a versioned and checksummed script hash with base58. The result will _always_ start with the character `3`.
image::{imagedir}/base58-encode-p2sh.svg[{big-width}]

This last remainder '2' will translate to `3` in the character lookup
table of base58. This `3` character will become the first character
when the reverse step is performed by the base58 process. This causes
all p2sh addresses to start with a '3'. That's how users identify them
as p2sh addresses and not for example a p2pkh address.

****
image::{imagedir}/flyer-p2sh-address.svg[]
****

Faiza, Ellen and John can now print
 `328qTX1KYxMohp4MjPPEDBoRomCGwrB2ag` on their flyer.

When a coworker scans this flyer's QR code, their wallet will
recognize the address as a p2sh address because it starts with a
`3`. The wallet will base58check decode the address and create a
proper p2sh output:

 OP_HASH160
 04e214163b3b927c3d2058171dd66ff6780f8708
 OP_EQUAL

This concludes our sections on programmable transactions. We have
learned that transactions can express a lot of different rules for how
to spend money. Note that we cannot constrain where spent money goes,
only what's needed in the input to spend the money. pubkey script make
the rules for what's required in the signature script. Later in the book we
will revisit transactions to talk about more fancy stuff you can do
with transactions, for example make spending impossible until a
certain date in the future.

[[lock-time-and-sequence-numbers]]
=== More stuff in transactions

We still haven't covered all the contents of a transaction. There are
a few more pieces of information in the transactions: version, lock
time and sequence numbers.

image::{imagedir}/sequence-number-lock-time.svg[{half-width}]

Version:: Each transaction has a version. There are two versions
as of writing, 1 and 2.

Sequence number:: A four byte number on each input. For most
transactions this is set to its maximum value `ffffffff`. This is an
old disabled feature that's being re-purposed for new functionality.

Lock time:: A point in time that must have passed before it's allowed
to add the transaction to the spreadsheet. If Lock time is 0, it means
that the transaction is always allowed to be added to the spreadsheet.

We include this sparse information here just for completeness. These
features will be discussed in <<ch09>> when we know more about the
fundamentals of Bitcoin.

=== Rewards and coin creation

You might be wondering where all the cookie tokens come from in the
first place. Remember in <<ch02>> when we described how Lisa gets
rewarded 7,200 new cookie tokens every day? She would insert a new row
in the spreadsheet every day paying 7,200 new cookie tokens to
herself:

image::{imagedir}/lisa-is-rewarded.svg[{quart-width}]

She still rewards herself 7,200 cookie tokens per day, but in a
slightly different way. Every day she adds a special transaction to
the spreadsheet called a _coinbase transaction_.

[.inbitcoin]
.Rewards
****
Rewards in Bitcoin are paid using coinbase transactions roughly every
10 minutes to the nodes securing the Bitcoin blockchain. This will be
covered in <<ch07>>.
****

.Lisa rewards herself every day with a coinbase transaction.
image::{imagedir}/coinbase-transaction.svg[{big-width}]

The input of the coinbase transaction is called the _coinbase_. The
only way to create new coins is to add a coinbase transaction to the
spreadsheet. New coins are created as rewards to Lisa for performing
her valuable work.

[role="important"]
All transactions can be traced back to one or more coinbase
transactions by following the txid references in inputs of
transactions. The transactions form a _transaction graph_. They are
interconnected through the txids.

.The transaction graph. All transactions descend from one or more coinbase transactions.
image::{imagedir}/transaction-graph.svg[{full-width}]

John's transaction stems from four different coinbase transactions. To
verify John's transaction, you need to follow all txids from John's
transaction and verify all the transactions along the way until you
have reached the four coinbase transactions. This is what the UTXO set
helps verifiers with. The UTXO set keeps track of all already verified
unspent transaction outputs. The verifiers only have to follow the
txids (usually only one step) until it reaches an output that's in the
UTXO set.

The coinbase transactions must also be verified, so that there are
exactly one coinbase per 24 hours and each coinbase creates exactly
7,200 new cookie tokens.

==== Transition from version 4.0

You may also be wondering how the coworkers updated from the system
with "Emails to Lisa" as it was in release 4.0, to the one with
transactions. What happened to all already existing cookie tokens in
the spreadsheet?

They all agreed on a time-slot when the upgrade would take
place. During this time-slot Lisa created a single huge transaction
with one output per public key hash in the spreadsheet. This
transaction looks like a coinbase transaction but with a lot of
outputs. Anyone could keep a version of the old spreadsheet and verify
that this new transaction contains the exact same outputs as the old
UTXO set. New verifiers can't be sure it went well though, they will
have to trust Lisa with that.

Note that this is not at all how it happened in Bitcoin. Bitcoin was
designed for transactions from the beginning. The "initial state" in
Bitcoin was an empty UTXO set. No one had any bitcoins.

[[trust-in-lisa]]
=== Trust in Lisa

In this chapter the payment process has become more formalized, for
example, the transaction from the wallet must be sent as an attachment
in an email to Lisa. Lisa can take advantage of this formal process to
automate all her work. She writes a computer program that reads
transactions from her email inbox and automatically verifies the
transactions, maintains the UTXO set, and adds transactions to the
spreadsheet. Lisa can relax and just watch her computer program do the
job for her. Nice.

But now you may wonder if she's still worth the 7,200 CT per day in
rewards. She doesn't work actively with verification anymore, she's
just sitting there rolling her thumbs. Let's take a moment to reflect
on what we reward her for. We reward her not to perform boring manual
work, but to perform correct, honest confirmations of transactions and
not censor transactions. That's what gives us, the coworkers,
value. If she writes a computer program to do the heavy lifting, it
doesn't make the processing of payments less correct or honest.

Transactions solve the problem with Lisa arbitrarily changing stuff in
the spreadsheet. The only thing we have to trust Lisa with now is to

[.gbinfo]
.We trust that Lisa doesn't
****
* censor transactions
* revert transactions
****

* not censor transactions. She must add any valid transactions that
  she receives on email to the spreadsheet.
* not revert transactions. To revert a transaction is to remove it
  from the spreadsheet.

If Lisa decides that she doesn't like Faiza, and she also happens to
know some of Faiza's UTXOs she can refuse to process Faiza's
transactions that tries to spend those UTXOs. That means that Faiza is
unable to spend her money. Lisa censors Faiza's transactions.

If Lisa reverts a transaction from the spreadsheet, it may be noticed
by already running verifiers. But verifiers that started after the
reverting will not notice, because the spreadsheet is still valid
according to the rules.

Suppose that Lisa reverts Johns transaction from
<<_pay_using_a_transaction>>. Lisa simply removes John's transaction
from the spreadsheet. No one has spent any of the outputs of johns
transaction yet, so the spreadsheet doesn't contain any transactions
that becomes invalid when John's transaction is deleted.

An already running verifier, for example the Cafe, will not notice
this, because they just watch the spreadsheet for added transactions
at the end of the spreadsheet. They have already verified John's
transaction and updated their private UTXO sets. They trust Lisa to
not delete transactions, so they never recalculate their UTXO set.

Further suppose that a new coworker, Vera, starts to build her own
UTXO set from the spreadsheet, which now lacks John's
transaction. This UTXO set will differ from the cafe's UTXO set. From
Vera's point of view, John still has the money and has not paid 10CT
to the Cafe. The outputs that John spent in his transaction appears
unspent to Vera because they are in Vera's UTXO set.

Now we have Vera who thinks John still has the money, Lisa who deleted
the transaction and the Cafe that thinks it got 10 CT from John. So
far no one has noticed Lisa's crime. This will remain unnoticed as
long as nobody tries to spend an output from John's. That could be the
cafe spending their 10 CT or John spending his 3 CT change.

Let's say that the Cafe wants to pay for rent to the company. They
need to spend, among other outputs, the output of John's
transaction. The cafe creates a transaction that spends the output,
signs it and sends it to Lisa. Lisa knows that she has deleted John's
transaction and that her crime will now be noticed. If Lisa decides to
confirm the cafe's transaction, then she would make the whole
spreadsheet invalid and Vera and all other newly started verifiers
will reject the spreadsheet as a whole. Not good. If Lisa decides to
reject the transaction, which is the more sensible thing for her to
do, the cafe will notice because their transaction never confirms.

When the cafe notices, they can not prove that John's transaction has
ever been in the spreadsheet. Also, Lisa cannot prove that John's
transaction never was in the spreadsheet. It's words against
words. This problem will be solved in <<ch06>>.

It's not obvious why Lisa would delete John's transaction. Maybe John
pays Lisa to do it. It would probably make more sense to Lisa to cheat
with her own money instead. Let's say that she buys a cookie in the
cafe and when the cafe has seen the transaction from Lisa to the Cafe
in the spreadsheet, they give a cookie to Lisa. Yummy. Then Lisa walks
back to her desk and simply removes her transaction. Now she got a
cookie _and_ got to keep the money. This will of course be noticed
when the cafe tries to spend the output from the removed transaction,
or the next time Lisa tries to double-spend the outputs spent by the
removed transaction. But as with John's transaction, its word
against word. Lisa can claim that the transaction was never in the
spreadsheet, and the cafe can claim it was. No one can prove anything.

=== Summary

Transactions makes it impossible for Lisa to steal cookie tokens from
others. It solves the problem by making all signatures public in the
spreadsheet.

.The payment process. A wallet creates a transaction that Lisa verifies and appends to the spreadsheet.
image::{imagedir}/wallet-payment-process-transactions.svg[{big-width}]

Users' wallets create and sign transactions that Lisa verifies and
appends to the spreadsheet.

Transactions have inputs and outputs. An output of a transaction
contains the last part of a Script program. When the output is spent,
the input spending the output must provide the first part of the
program.

.A transaction spending output 1 of another transactions. The program consists of a signature script followed by a pubkey script.
image::{imagedir}/script.svg[{big-width}]

The program is run by Lisa. If the program ends with "OK", then the
spending of _that_ output is authorized. If the programs of all inputs
in a transaction ends with OK, the whole transaction is valid and Lisa
adds the transaction to the spreadsheet.

Once the transaction is in the spreadsheet, anyone can make the exact
same checks as Lisa did, because she added the transaction to the
spreadsheet exactly as she received it. If Lisa makes changes to it,
people will notice that the spreadsheet is no longer valid because it
contains an invalid transaction. The only things that we cannot verify
is if transactions are being censored (not added to the spreadsheet)
or deleted from the spreadsheet. We simply have to trust Lisa with
these two things for now.

==== System changes

****
image::{imagedir}/toolbox.svg[]
****

We will add transactions and transaction id to our toolbox. Our
concept mapping table is shrinking by two rows: The emails to Lisa and
the rows in the spreadsheet are replaced by a transactions.

[%autowidth]
.Transactions replace the emails to Lisa and the rows in the spreadsheet.
|===
| Cookie Tokens | Bitcoin | Covered in

| 1 cookie token | 1 bitcoin | <<ch02>>
| The spreadsheet | The blockchain | <<ch06>>
| [.line-through]#*Email to Lisa*# | *[.line-through]#A transaction#* | *[.line-through]#<<ch05>>#*
| *[.line-through]#A row in the spreadsheet#* | *[.line-through]#A transaction#* | *[.line-through]#<<ch05>>#*
| Lisa | A miner | <<ch07>>
|===

The next chapter will take care of replacing the spreadsheet, that now
contains transactions, with a blockchain.

Let's release version 5.0 of the cookie token system:

[%autowidth,options="header"]
.Release notes, cookie tokens 5.0
|===
|Version|Feature|How

.3+|image:{commonimagedir}/new.png[role="gbnew"]*5.0*
| Spend multiple "coins" in one payment
| Multiple inputs in transactions

| Anyone can verify the spreadsheet
| Make the signatures publicly available in the transactions

| Sender decides criteria for spending the money
| Script programs inside transactions

.3+|4.0
|It is now easy to make payments and create new addresses.
|Mobile app "Wallet"

|Simplify backups
|HD wallets are generated from a seed. Only the seed, 12-24 English
 words, needs to be backed up.

|Create addresses in insecure environments
|HD wallets can generate trees of public keys without ever seeing any of the private keys

.2+|3.0
|Safe from expensive typing errors
|Cookie token addresses
|Privacy improvements
|PKH is stored in spreadsheet instead of personal names.
|===

=== Exercises

==== Warm up

. Suppose that all your money are spread over three unspent
transaction outputs, one with 4 CT, one with 7 CT and one with
2 CT. Which of these outputs would you spend if you want to buy a
cookie for 10 CT? What outputs would your transaction have and what
would their CT values be?

. What are transaction ids (txid) used for in a transaction?

. Why do you usually need to add a change output in your transaction?

. Where are the signatures located in a transactions?

. Why is the public key needed in the input of a transaction if it
  spends a pay-to-public-key-hash, p2pkh, output?

. Why is the signature scripts of a transaction cleaned when your wallet signs the transaction?

. Where are the pubkey scripts located in a transaction and what does
it contain?

. What is required from a Script program (signature script + pubkey
script) for and input to be considered authentic?

. How can you recognize a pay-to-script-hash address?

==== Dig in

[start=10]
. Suppose that you have 100 CT in a single output at index 7 of a
transaction. You want to pay 10 CT to the cafe's p2pkh address @~C~
and 40 CT to Faiza, Ellen and John's charity's p2sh address
@~FEJ~. Construct a single transaction that does that. Please cheat by
looking up the exact operators and program templates from this
chapter. You don't have to sign the inputs.

. The UTXO set contains all unspent transaction outputs. Suppose that
it contains 10,000 UTXOs and that you send a transaction to Lisa that
has 2 inputs and 5 outputs. How many UTXOs will the UTXO set contain
after the transaction has confirmed?

. Create a really simple pubkey script that allows anyone to spend the
output. What would the signature script of the spending input contain?

. Create a pubkey script that requires the spender to provide two
numbers in the signature script whose sum is 10 in order to spend the
money. There is an operator called OP_ADD that takes the top two items
from the stack and puts back the sum of those items.

. Suppose that you receive money from Faiza in a confirmed
transaction, but you want to make sure that Lisa doesn't make any
errors, deliberately or accidentally. What do you have to do to make
sure the money from Faiza is real?

. Public keys are visible in inputs that spend p2pkh outputs. What is
the drawback of that?  What can users do to avoid that drawback.

=== Recap

In this chapter you learned that

* Transaction have inputs and outputs, which lets you spend multiple
  "coins" and pay to multiple recipients in a single transaction.

* The outputs of the transactions are "programmable". The sender
  wallet decides what program to put in the output. This dictates
  what's needed to spend the money.

* Anyone can verify the whole spreadsheet, because all signatures are
  public. This greatly reduces trust in Lisa.

* Scripts can be used to enable multisignature capabilities, for
  example 3-of-7 capabilities. Great for companies and charities.

* A new address type, p2sh address beginning with `3`, is used to
  simplify the payment process for a lot of fancy payment types, for
  example multisig.

* All transactions descend from one or more coinbase
  transactions. Coinbase transactions are the only way in which money
  is created.

* Money creation is verified by any coworker, to make sure Lisa
  creates exactly as much as agreed. 7,200 CT per day.

* Lisa can still censor and revert transactions. We still have to
  trust her with that.
