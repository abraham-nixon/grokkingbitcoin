[[ch09]]
== Transactions revisited - Bells and whistles
:imagedir: {baseimagedir}/ch09

This chapter covers

* Making transactions invalid until a certain time
* Swapping coins between different blockchains
* Attaching arbitrary data to transactions
* Bumping the fee of a pending transaction

We are now past the core chapters of the book in which you have
learned the basics of Bitcoin. In this chapter we will dig deeper into
what functionality transactions can offer us.

We will start by exploring time locks. A time lock is a way to make
transactions invalid until a certain point time, or a certain block
height. This means that you can create a transaction that can not be
included in a block until that point in time or block height has
passed. This is useful for digital contracts like atomic swaps covered
later in this chapter.

Sometimes it's useful to store some small amount of data in a
transaction in the blockchain. For example, a car manufacturer may
want to track ownership of a car by putting the chassis number of the
car into a Bitcoin transaction, effectively creating a token on the
Bitcoin blockchain. The current owner can then transfer ownership of
the car by sending that token to the new owner.

As mentioned in <<altcoins>>, there are a lot of alternative
cryptocurrencies. Sometimes you may want to trade for example
namecoins for bitcoins. The most obvious way to do that is to use an
exchange to sell bitcoin and buy namecoins. But there are other more
decentralized ways to do it. _Atomic swaps_ lets you swap your
bitcoins directly with someone holding namecoins without a trusted
third party like an exchange.

If you pay a too small transaction fee, miners may refuse to confirm
the transaction within reasonable time. In this situation it can be
helpful to replace the transaction with another one that pays a little
more in fees. This is known as fee-bumping.

Lastly, we will explore some intricate details of
signatures. Signatures can be made in different ways depending on your
use case. You can tune what the signature should commit to. In other
words, we can change how the signing algorithm hashes the transaction.

[[time-locked-transactions]]
=== Time locked transactions

When you create and sign a transaction it will be valid and ready for
inclusion in any future block. You can broadcast it immediately and
have it mined. This is the normal case.

However, there are times when you want to sign a transaction but be
guaranteed not have it mined until after at least, say one year, have
passed.

Suppose that you have 100 bitcoins, and in case you die, you want your
daughter to get the money to her address @~D~, but only after
you die. You can create a transaction that is time locked:

[.gbinfo]
.No fee?
****
For the sake of simplicity, most examples in this chapter don't pay
any fees.
****

.A payment to your daughter that will become valid after one year has passed.
image::{imagedir}/timelock-to-daughter.svg[{big-width}]

[.gbinfo]
.Sequence numbers
****
The sequence numbers are always included in inputs, but we haven't
showed them because they didn't matter to the transactions we've used
so far.
****

What makes this transaction special are the sequence numbers of the
inputs and the transaction lock time. We briefly mentioned sequence
numbers in <<_lock_time_and_sequence_numbers>>. The sequence numbers
are used to "enable" the lock time: If any input has a sequence number
less than `ffffffff`, for example `fffffffe`, the lock time set on the
transaction will be effective. If all sequence numbers are `ffffffff`,
the lock time doesn't have any effect.

You give this transaction to your daughter. This transaction is
currently invalid, and your daughter stores it on her computer and she
even prints a backup that she keeps in another place. It is not
broadcast; No full node will accept a block containing this
transaction yet. The transaction will become valid in the morning of
2019-04-30. If you die before that, your daughter waits until after
the lock time date and then claim the money by broadcasting the
transaction, which has become valid by then.

If you don't die before that date, you want to make sure that the time
locked transaction becomes useless, so that your daughter can't take
the money once the time lock date has passed.

You can create, but not broadcast yet, a new transaction, Tx~2~, that
double-spends an output that Tx~1~ spends. If Tx~2~ would confirm,
TX~1~ would become forever invalid. Then you create a new time locked
transaction for yet another year:

.Make Tx~1~ invalid by spending an output that Tx~1~ spends and create a new time locked transaction to your daughter
image::{imagedir}/timelock-to-daughter-2.svg[{full-width}]

[.gbinfo]
.Transaction malleability
****
There is a problem here. The txid of Tx~2~ _can_ change while being
broadcast, making Tx~3~ forever invalid. That's called _transaction
malleability_ and is fixed by _segregated witness_ in <<ch10>>.
****

You need to

. Create and sign a transaction, Tx~2~, that spends at least one of
the outputs spent by Tx~1~. Tx~2~ is a normal, not time locked,
transaction. Don't broadcast this transaction just yet.
. Create a new time locked transaction, Tx~3~, that spends all your
outputs. This transaction is locked for another year. Give Tx~3~ to
your daughter.
. Broadcast Tx~2~. Once Tx~2~ is mined, Tx~1~ will become forever
invalid, because one of the inputs of Tx~1~ is spent by Tx~2~.

Note how the order of events are important here. If Tx~2~ is broadcast
_before_ you give Tx~3~ to your daughter, there's a chance that you
die before giving her Tx~3~. Then your daughter will not be able to
receive the funds, because she has no valid transaction to claim them
with. Tx~1~ is invalidated by Tx~2~ in the blockchain, and Tx~3~ is
not in your daughter's possession.

==== Time measurements

There are two ways to express a lock time. The first way is by setting
a date and time as in the example above. The second way is to set a
block height.

===== Block time

In the example above the lock time was expressed as a date and
time. That actually means that the _median time past_ must be greater
than the lock time in the transaction. Remember the rules for the
block timestamps in <<timestamp-rules>>? We said then that a timestamp
of a block must be greater than the past 11 blocks' median timestamp,
or the _median time past_ of the block. We use the median time past to
decide whether a transaction is valid with regards to lock
time. Suppose that you've died on 2019-01-24. Your mourning daughter
can't claim your money until 2019-04-30. More precisely:

.Your daughter may claim your money after the median time past is earlier than your lock time.
image::{imagedir}/locktime-rules.svg[{full-width}]

Your daughter's transaction cannot be mined in any block before the
last one in the figure above. The median time past is strictly
increasing according to the rules in <<timestamp-rules>>. It's not
until the block _after_ the one with timestamp 07:33:21 that she can
get her transaction confirmed. Before that block, the median time past
is too early.

Her transaction will not even propagate through the Bitcoin network
until the lock time has passed. The nodes don't want to keep time
locked transactions in their memories because they think there are
better uses for the precious memory space than to fill them up with
transactions that aren't even valid (yet). It's up to your daughter to
broadcast the transaction after the lock time has passed.

===== Block height

You can also express time using block height. You can say that a
transaction is not valid until after block height 571019. This means
that the following transaction can't be mined until after block 571019
has been mined:

.A time locked transaction based on block height. This transaction is first valid at block height 571020.
image::{imagedir}/height-timelock-to-daughter.svg[{half-width}]

The earliest block that the transaction can be included in is at
height 571020. It's hard to predict exactly when that block will be
mined, but thanks to the difficulty adjustments that keeps the average
block time at about 10 minutes, you can expect about 52596 blocks per
year.

==== Relative time locks

[.inbitcoin]
.BIP68
****
This BIP describes how an input can require a certain distance in time
or blocks from the spent transaction output. This applies to
transactions with version at least 2.
****

The above example showed a use case for absolute time locks on
transactions. But there is also a way to require that a certain amount
of time has passed since a spent output was confirmed. We call this a
_relative time lock_. This is done on a per input basis:

.Relative time locks can be expressed either as a number of blocks or as a number of units of time. The sequence number of the inputs are used for this.
image::{imagedir}/relative-lock-time.svg[{full-width}]

The first input of the transaction has a sequence number of
`004013c6`. This says that the transaction is not valid until 30 days
have passed since the spent output was confirmed.

.The first input locks the transaction for 30 days from the spent output.
image::{imagedir}/relative-lock-time-first-input.svg[{full-width}]

The left-most bit of this sequence number is 0, which means that
relative lock time is enabled. The bit at index 9 from the left is 1,
which means that the right-most 16 bits should be interpreted as
"number of 512 second intervals". The 16 right-most bits are `13c6`
which translates to 5062 in decimal form. 5062 intervals of 512
seconds is 30 days.

The second output has a sequence number of `000003e8`. This means that
the transaction is invalid until 1,000 blocks have been mined since the
spent output was mined.

.The first input locks the transaction for 30 days from the spent output.
image::{imagedir}/relative-lock-time-second-input.svg[{full-width}]

The left-most bit is zero here too, which means that relative lock
time is enabled for this input. The bit at index 9 from the left is 0,
which means that the 16 right-most bits should be interpreted as
number of blocks. `03e8` is hex code for 1,000.

The version of the transaction needs to be at least 2 for relative
time locks to work. If the version is 1, the sequence numbers will not
have any effect on relative lock time, but it will affect absolute
lock time and "Replace by fee". Replace by fee is discussed later in
<<replace-by-fee>>.

=== Time locked outputs

Time locks are not very useful in itself. The only thing you can use
it for is to create a transaction that may eventually become valid.

It may be more useful to be able to say something like "The money in
this output can not be spent before new years eve.", or "The money in
this output can not be spent before 300 blocks have been mined on top
of the block containing this output". These are examples of time
locked outputs. An output can be locked absolutely or relatively and
locks can be time based or height based.

[[absolute-time-locked-outputs]]
==== Absolute time locked outputs

[.inbitcoin]
.BIP65
****
This BIP describes in detail the Script operator, OP_CHECKLOCK-TIMEVERIFY that implements the
absolute time locked output.
****

Suppose that you want to give your daughter 1 BTC allowance on the
first of May. You can then make a transaction as follows:

.Paying allowance in advance to your daughter. She may not spend it before may 1 2019.
image::{imagedir}/absolute-time-locked-outputs.svg[{big-width}]

You can broadcast this transaction immediately to the Bitcoin network
and have it mined. The first output is the interesting part. It says
that this output cannot be spent before May 1 (2019). For the curious,
the exact pubkey script is:

[subs="normal"]
----
<may 1 2019 00:00:00> OP_CHECKLOCKTIMEVERIFY OP_DROP
OP_DUP OP_HASH160 <PKH~D~> OP_EQUALVERIFY 
OP_CHECKSIG
----

This script will make sure that the transaction spending the output is
sufficiently time locked. For example

.Various spending transactions and their validity.
image::{imagedir}/absolute-time-locked-outputs-spending.svg[{big-width}]

The first two transactions will never be valid because their time
locks are not sufficiently late. The first one is not locked at all,
which is illegal according to the pubkey script. The second one is at
least time locked, but it's not late enough. 1 second before May 1 is
too early.

The third transaction on the other hand is OK, because the time lock
is at least as high as the time in the pubkey script, 2019-05-01
00:00:00. So this transaction will be valid on and after May 1. The
last transaction will be valid on new year's eve right before the
fireworks. Note however that both of the two last transactions cannot
be mined, at most one of them can be mined since they spend the same
outputs.

The result of this example is that your daughter will be able to spend
the output as she pleases after May 1.

==== Relative time locked outputs

[.inbitcoin]
.BIP112
****
This BIP describes relative time locked outputs. The script
operator is called OP_CHECK-SEQUENCEVERIFY.
****
A relative time locked output works similar to an absolute time locked
output, but relative locks require that a certain amount of time _has
passed_ between the block containing the spent output and the block
containing the spending transaction.

.Spending a relative time locked output is allowed after a certain amount of blocks has passed.
image::{imagedir}/relative-lock-overview.svg[{big-width}]

Relative time locks are most commonly used in _digital contracts_. A
digital contract can be regarded as a traditional contract between
parties, but they are enforced by the rules of the Bitcoin network
rather than national laws. Contracts are expressed as Bitcoin pubkey
scripts. We will illustrate the use of relative time locked outputs
with an _atomic swap_ in the next subsection. An atomic swap means
that two persons swap coins with each other across different
cryptocurrencies.

==== Atomic swaps

A commonly mentioned digital contract is the _atomic swap_, where two
parties want to swap coins with each other between different
blockchains.

Suppose that John is chatting with Fadime on a public forum on the
Internet. They don't know each other and have no reason to trust one
another. But they both want to trade.

.Atomic
****
In compute science, the word _atomic_ means that a process either
completes in its entirety or not at all. For atomic swaps it means
that either the swap completes or they both get to keep their old
coins. There are no other possible outcomes.
****

They agree that John will trade 2 bitcoins for 100 of Fadime's
namecoins (NMC). Namecoin is an altcoin used as a decentralized naming
system, like DNS. We talked briefly about altcoins in <<ch01>>. It's
not important what Namecoin actually is used for in this example; We
only conclude that it's another cryptocurrency on another blockchain
than Bitcoin's.

The conversation started like this:

[subs="normal"]
.John:
 Do you want to swap 100 NMC for my 2 BTC? My Namecoin public key is
 *02381EFD...88CA7F23*. I've created a *secret random number that has
 the SHA256 hash value H*. I will not tell you the secret number yet.

[subs="normal"]
.Fadime:
 Sure John, let’s do it! My Bitcoin public key is
 *02b0c907...df854ee8*

****
image::{imagedir}/2ndcol-s-and-h.svg[]
****

We will call the secret number S. Only John knows S for now, but he
shares the hash of S, H, with Fadime. Now they both have enough
information to get started.

They create one transaction each. John creates a Bitcoin transaction
that spends 2 of his BTC. Fadime creates a Namecoin transaction that
spends 100 of her NMC. They don't broadcast their transactions yet.

.John and Fadime creates a contract transaction each. The redeem script of this p2sh output contains the contract details.
image::{imagedir}/atomic-swaps-1.svg[{full-width}]

The output of John's contract transaction can be spent in one of two
ways:

1. By providing the pre-image of H, and Fadime's signature. John knows
such a pre-image, namely his secret number S from the conversation
above, but Fadime doesn't.
2. With John's signature after 48 hours.

Likewise, the output of Fadime's contract transaction can be spent in
one of two ways:

1. By providing the pre-image of H, and John's signature.
2. With Fadime's signature after 24 hours.

The relative lock time is enforced by the Script operator
`OP_CHECKSEQUENCEVERIFY`. This operator requires that the output of
John's contract transaction is not spent by John until 48 hours has
passed from the time when the contract transaction was confirmed. In
Fadime's contract transaction, the operator requires that Fadime
doesn't spend the output until after 24 hours.

Fadime knows that John has the secret number. So if Fadime broadcasts
her contract transaction now, John can take the money and not fulfill
his part of the deal. For this reason she will not broadcast her
transaction until she has seen John's transaction safely confirmed in
the blockchain. Since Fadime doesn't know the secret, S, John can
safely broadcast his contract transaction without Fadime running away
with the money.

.p2sh address creation
****
image::{imagedir}/2ndcol-p2sh-address-creation.svg[]
****

So John broadcasts his contract transaction. Remember that the output
of the contract transaction in this example is a pay-to-script-hash,
p2sh, output. The output contains a p2sh address that doesn't say
anything about this being John's contract output. So, in order for
Fadime to identify John's contract transaction on the Bitcoin
blockchain, she will construct the same redeem script as John created
for his contract transaction and generate the p2sh address John's
contract transaction paid to. Then she can look for that p2sh address
in the Bitcoin blockchain.

When Fadime finds that John's transaction is confirmed, she broadcasts
her own contract transaction. John waits until Fadime's transaction is
sufficiently confirmed on the Namecoin blockchain. Then the actual
swap happens in two steps:

.The first step of the actual swap. John claims Fadime's 100 NMC by revealing the secret S.
image::{imagedir}/atomic-swaps-2.svg[{full-width}]

John broadcasts his swap transaction. John's swap transaction spends
Fadime's contract transaction output by providing S and his
signature. Again, note that John is spending a p2sh output, which
means that the first thing that happens is that the redeem script that
John provided in the signature script, will be hashed and compared to the
hash in the pubkey script. Then the actual redeem script will be run.

We won't go through the program in detail. But when the redeem script
starts running, the stack will have "1" on top. This means "true" in
Namecoin, just as in Bitcoin. That value will cause the program to run
the part of the script that requires a pre-image and John's
signature. The other part is not run at all.

The script will leave the stack with a true on top because John
provides both required items in the correct order, his signature and
the pre-image, `S`. He successfully claims his 100 NMC.

As soon as Fadime sees John's swap transaction on the Namecoin
network, she can create her own swap transaction for the Bitcoin
blockchain.

.Fadime completes the atomic swap by sending her swap transaction to the Bitcoin network.
image::{imagedir}/atomic-swaps-3.svg[{full-width}]

She takes the pre-image, S, from John's swap transaction and puts it
into her own swap transaction that pays 2 BTC to Fadime's public key
hash, PKH~F~. When the two swap transactions get confirmed, the atomic
swap is complete. The effect of all this is that John has sent 2 BTC
to Fadime, under the condition that Fadime sends 100 NMC to him, and
Fadime sends 100 NMC to John under the condition that John sends 2 BTC
to her.

===== Failure of atomic swap

The sequence of events in the atomic swap example above illustrated
the case where both parties, John and Fadime, played by the rules. No
one had to actually use the time locked branches of the contract
transaction outputs. This subsection will go through some ways that
the swap might fail.

Fadime doesn't broadcast her contract transaction:: This means that
John can't spend the output of Fadime's contract transaction, which
means that Fadime will never get to see S. Without S, she can't spend
John's contract output. The only possible outcome is that John must
wait 48 hours for the relative time lock to pass and then reclaim his
money.

John doesn't spend Fadime's contract output in 24 hours:: Fadime can
reclaim her coins and John must wait another 24 hours before claiming
his coins back.

John spends Fadime's contract output just after 24 hours has passed but before Fadime claims back her coins::
Thankfully John's contract output has a 48 hour relative lock time as
opposed to 24 hours in Fadime's contract output, so John can't claim
his coins back until he has waited another 24 hours. During this time,
Fadime can claim her BTC from John's contract output at any time using
S and her signature.

Fadime gets hit by a bus just after broadcasting her contract output::
This is no good. John will be able to take his NMC from Fadime's
contract output and then wait 48 hours to also claim back
his BTC. Fadime loses out on this one.

In the last of these cases, one could argue that the swap wasn't
atomic. After all, the swap didn't go through and John ended up with
all coins. This is a somewhat philosophical question. But we can think
of swaps as being atomic under the condition that Fadime is able to
take actions. We don't have this condition for John, though. It's a
matter of who creates the secret, S.

=== Storing stuff in the Bitcoin blockchain

In the early days of Bitcoin, it became clear that people wanted to
put stuff in transactions in the Bitcoin blockchain that doesn't have
anything to do with Bitcoin itself.

.A blockchain tribute to Cryptographer Sassama allegedly posted by Dan Kaminsky. The message is wrapped into 3 columns to save space.
....
---BEGIN TRIBUTE---     LEN "rabbi" SASSAMA     P.S.  My apologies,
#./BitLen                    1980-2011          BitCoin people.  He
:::::::::::::::::::     Len was our friend.     also would have    
:::::::.::.::.:.:::     A brilliant mind,       LOL'd at BitCoin's 
:.: :.' ' ' ' ' : :     a kind soul, and        new dependency upon
:.:'' ,,xiW,"4x, ''     a devious schemer;         ASCII BERNANKE  
:  ,dWWWXXXXi,4WX,      husband to Meredith     :'::.:::::.:::.::.:
' dWWWXXX7"     `X,     brother to Calvin,      : :.: ' ' ' ' : :':
 lWWWXX7   __   _ X     son to Jim and          :.:     _.__    '.:
:WWWXX7 ,xXX7' "^^X     Dana Hartshorn,         :   _,^"   "^x,   :
lWWWX7, _.+,, _.+.,     coauthor and            '  x7'        `4,  
:WWW7,. `^"-" ,^-'      cofounder and            XX7            4XX
 WW",X:        X,       Shmoo and so much        XX              XX
 "7^^Xl.    _(_x7'      more.  We dedicate       Xl ,xxx,   ,xxx,XX
 l ( :X:       __ _     this silly hack to      ( ' _,+o, | ,o+,"  
 `. " XX  ,xxWWWWX7     Len, who would have      4   "-^' X "^-'" 7
  )X- "" 4X" .___.      found it absolutely      l,     ( ))     ,X
,W X     :Xi  _,,_      hilarious.               :Xx,_ ,xXXXxx,_,XX
WW X      4XiyXWWXd     --Dan Kaminsky,           4XXiX'-___-`XXXX'
"" ,,      4XWWWWXX     Travis Goodspeed           4XXi,_   _iXX7' 
, R7X,       "^447^                               , `4XXXXXXXXX^ _,
R, "4RXk,      _, ,                               Xx,  ""^^^XX7,xX 
TWk  "4RXXi,   X',x                             W,"4WWx,_ _,XxWWX7'
lTWk,  "4RRR7' 4 XH                             Xwi, "4WW7""4WW7',W
:lWWWk,  ^"     `4                              TXXWw, ^7 Xk 47 ,WH
::TTXWWi,_  Xll :..                             :TXXXWw,_ "), ,wWT:
=-=-=-=-=-=-=-=-=-=                             ::TTXXWWW lXl WWT: 
                                                ----END TRIBUTE----
....

While this was certainly interesting and funny, it has some
implications for Bitcoin's full nodes.

.Blockchain explorer
****
You can take a closer at this transaction using a blockchain explorer,
see for example <<web-bernanke-ascii-art>>.
****

The above message was written into the blockchain using a single
transaction with transaction id
`930a2114cdaa86e1fac46d15c74e81c09eee1d4150ff9d48e76cb0697d8e1d72`. The
author created a transaction with 78 outputs, one for each 20
character line in the message. Each line ends with a space so only 19
characters are visible.

For example, the very last output's pubkey script looks like this:

 OP_DUP OP_HASH160 2d2d2d2d454e4420545249425554452d2d2d2d20 OP_EQUALVERIFY OP_CHECKSIG

The interesting part is the public key hash. This is not an actual
public key hash, but a made up one. Maybe you can see a pattern when
you compare it to the line ``----END TRIBUTE---- ``:

 2d 2d 2d 2d 45 4e 44 20 54 52 49 42 55 54 45 2d 2d 2d 2d 20
 -  -  -  -  E  N  D     T  R  I  B  U  T  E  -  -  -  -   

This "public key hash" encodes one 20 character line in the
message. It uses the so called _ASCII table_ to encode characters. For
example the character `-` is encoded as the byte `2d`. The characters
A-Z are encoded by the bytes `41`-`5a`, and space is encoded as byte
`20`.

Let's have a look at the public key hashes of the 10 last lines of the
message along with the ASCII-decoded text:

----
20203458586958272d5f5f5f2d60585858582720   4XXiX'-___-`XXXX'
202020345858692c5f2020205f69585837272020    4XXi,_   _iXX7'
20202c2060345858585858585858585e205f2c20   , `4XXXXXXXXX^ _,
202058782c202022225e5e5e5858372c78582020   Xx,  ""^^^XX7,xX
572c22345757782c5f205f2c5878575758372720 W,"4WWx,_ _,XxWWX7'
5877692c202234575737222234575737272c5720 Xwi, "4WW7""4WW7',W
54585857772c205e3720586b203437202c574820 TXXWw, ^7 Xk 47 ,WH
3a5458585857772c5f2022292c202c7757543a20 :TXXXWw,_ "), ,wWT:
3a3a54545858575757206c586c205757543a2020 ::TTXXWWW lXl WWT:
2d2d2d2d454e4420545249425554452d2d2d2d20 ----END TRIBUTE----
----

==== Bloated UTXO set

****
image::{imagedir}/2ndcol-pkh-creation.svg[]
****

Since these public key hashes are made up, there is no known
pre-images to them. This also means that there are no known
public/private key pairs associated with the public key hashes. Thus,
the outputs can never be spent by anyone. They are _unspendable_. The
Bitcoin address of the last PKH is
`157sXYpjvAyEJ6TdVFaVzmoETAQnHB6FGU`. Whoever pays money to this
address throws the money in the trash. The money is lost forever. It
is the equivalent of burning a dollar bill.

Unspendable outputs as the ones above are indistinguishable from
ordinary, spendable, outputs. You cannot prove that they are
unspendable. Full nodes have to treat them as spendable, meaning that
they have to keep these unspendable outputs in their UTXO (unspent
transaction output) set forever. This places an unnecessary burden on
nodes: They need to keep all these outputs in memory.

The developers of Bitcoin came up with a partial solution to this
problem. Instead of sending money to unprovably unspendable outputs,
users can create _provably unspendable_ outputs. If a full node can
determine if an output is unspendable, it doesn't have to insert it
into its UTXO set.

The partial solution involves a new script operator called
`OP_RETURN`. This operator immediately fails when executed. A typical
`OP_RETURN` pubkey script can look like this

 OP_RETURN "I'm Grokking Bitcoin"

If someone would try to spend this output, it would cause the script
to fail when it encounters the `OP_RETURN`. So if the pubkey script
contains this operator, a full node can determine that the output is
not spendable and simply ignore the output. Saving the UTXO set from
being forever bloated with this nonsense. A typical `OP_RETURN` output
pays 0 BTC, but it can also set a value >0 to "burn" money.

There are a few policies regarding OP_RETURN:

* The full pubkey script must not be bigger than 83 bytes.
* There can only be one OP_RETURN output per transaction.

The above two policies are just that, policies. Full nodes adhering to
these policies will not relay transactions violating the policies. But
if they encounter a block that contains transactions that violate the
policies, the block will be accepted and relayed. We will talk more
about policies and _consensus rules_, strict rules that apply to
blocks, in <<ch10>> and <<ch11>>.

==== Create a token in Bitcoin

We talked briefly about tracking ownership on the blockchain in
<<ch01>>. Suppose that a car manufacturer, let's call them Ampere,
decides that they want to digitally track the ownership of their cars
on the Bitcoin blockchain. This can be accomplished by creating a
token in Bitcoin.

Suppose that Ampere wants to create a token for a newly manufactured
car with the chassis number 123456. Then they broadcast a Bitcoin
transaction as follows:

.Ampere creates a new token for a newly built car. They issue the token to themselves because they still own this car.
image::{imagedir}/car-token-1.svg[{big-width}]

This "Ampere token protocol" specifies that a new token is created when

* Ampere spends a coin from PKH~A~.
* the transaction contains an OP_RETURN output with the text `"ampere
  <chassis number>"`.
* the first output is the initial owner of the token.

Ampere has a well known web page at https://www.ampere.example.com/
where they have published their public key corresponding to
PKH~A~. They also pump out their public key through advertisements and
via Facebook and Twitter. They do this so that people can verify that
PKH~A~ actually belongs to Ampere.

Now suppose that Ampere sells this car to a car dealer. The dealer has
a public key hash PKH~D~. This is how Ampere will transfer the digital
ownership to the dealer:

.Ampere sells the car to a car dealer with public key hash PKH~D~.
image::{imagedir}/car-token-2.svg[{full-width}]

According to our simple protocol, ownership of a car is transferred by
spending the old owner's output. The following rules apply:

* The spending transaction spends the old owner's output.
* The first output of the spending transaction is the new owner of
  the car.

Now the car dealer is the new owner because the PKH~D~ is the first
output of the spending transaction. That's it. When the dealer sells
this car to a consumer, Fadime, the dealer transfers the ownership of
the car to Fadime's address, PKH~F~:

.The car dealer transfers the ownership of the car to Fadime's PKH~F~. 
image::{imagedir}/car-token-3.svg[{full-width}]

==== Start the car with proof of ownership

Now, that Fadime is the rightful owner of this car, wouldn't it be
cool if she could start the car by proving that she is the owner?
She can. The car is equipped with an ignition lock that starts the
engine when Fadime sends a proof of ownership to the car.

.Fadime starts her car by signing a challenge with her private key.
image::{imagedir}/car-token-4.svg[{big-width}]

Fadime first asks the car to start. The car will not start if it
doesn't know that Fadime has the private key belonging to PKH~F~. The
car generates a big random number and sends it to Fadime. Fadime signs
this random number with the private key and sends the signature and
her public key to the car.

The car needs the public key to be able to verify that the public key
corresponds to PKH~F~ as written in the blockchain. The car keeps
track of who currently owns the car by running a lightweight wallet
that understands the Ampere token protocol.

When the car has verified that the signature is valid and from the
correct private key it will start the engine.

[[replace-by-fee]]
=== Replace pending transactions

When you send a Bitcoin transaction to buy a book on-line, the book
store will wait for the transaction to confirm before it sends the
book to you. Usually your transaction will get confirmed within an
hour or so, but what if it doesn't? What if no miner ever wants to
include your transaction? This can certainly happen if your
transaction fee is not sufficient.

[id=stuck-transaction]
.You pay for your book and set the transaction fee to 0.00001 BTC
image::{imagedir}/rbf-1.svg[{big-width}]

You may recall from <<_transaction_fees>> that the transaction fee is
the sum of the input values minus the sum of the output values. The
"fee per byte" that miners care about is calculated by dividing that
fee with the size of the transaction. In this case 1,000 satoshis
divided by 225 bytes, which is about 4.4 sat/byte.

If no miner is willing to include the transaction for that fee, your
transaction will be stuck waiting for confirmation. If the transaction
isn't confirmed, you will not get your book. You probably want to do
something about the situation. Maybe you can create a new similar
transaction, but with a higher fee? Let's try.

.You try to replace your old, stuck, transaction with a new one with higher fee.
image::{imagedir}/rbf-2.svg[{big-width}]

That's nice. You have created and signed a new transaction with a 20
times higher fee. This would surely get mined, you think, and
broadcast the transaction.

The problem is just that your new transaction will probably be
regarded as a double spend attempt and be dropped by most nodes. They
think that the first transaction is the one that counts and disregards
any further transactions that spend the same output. It is completely
up to the nodes how to handle the second transaction, but the most
common policy is to drop it. This is what Bitcoin Core does, and
that's the most widely used Bitcoin software. This policy is known as
the _first-seen policy_.

[.gbinfo]
.Hint for exercises
****
Keep this in mind for <<exercise-rbf>>.
****

You may be able to circumvent this policy by sending the second
transaction directly to one or more miners. Miners have different
incentives than full nodes. Mining full nodes want to earn rewards,
subsidy+fees, by providing proof of work to the blockchain, while
non-mining full nodes want to keep their memory and computing resource
consumption down. So if a miner would get hold of the second, high-fee
transaction, it would probably decide to include that despite the fact
that the low-fee transaction was first seen. This way to replace
transactions is very impractical because you don't know the IP address
of any miners unless they publish it somehow, you also reveal your IP
address to the miners, who then become targets for various
surveillance organizations or companies wanting to monetize
information about you.

==== Opt-in replace by fee

[.inbitcoin]
.BIP125
****
This BIP describes how transactions can "declare" themselves as
replaceable. 
****

In 2016 a policy was deployed for transaction replacement. It's
generally called _opt-in replace by fee_, or opt-in RBF. It works by
using the _sequence numbers_ of the inputs of a transaction.

.Use opt-in replace by fee to be able to easily replace your transaction before it's confirmed.
image::{imagedir}/rbf-3.svg[{big-width}]

Suppose again that you want to pay for a book in an on-line book
store. When you create the transaction, you make sure that one of the
inputs (there is only one in this example) has a sequence number less
than `fffffffe`. This signals to nodes that you want this transaction
to be replaceable.

When a node receives this transaction, it will be treated as a normal
transaction but the "replaceability" will be remembered.

When you later notice that your transaction doesn't confirm because of
a too low fee, you can create a new, replacement transaction with a
higher fee. When you broadcast the replacement transaction, the nodes
receiving it will, if they implement the opt-in RBF policy, kindly
replace the old transaction with the new one and relay the new one to
its peers. The old transaction will be dropped. This way, the
replacement transaction will eventually reach all nodes, including
miners, and hopefully this new replacement transaction will get
confirmed within reasonable time.

In the example above you set the sequence number of the input of the
replacement transaction to `ffffffff`. This has the effect that the
replacement transaction is not itself replaceable. If you want the
replacement transaction to also be replaceable you need to set its
sequence number to `fffffffd` or less just as you did on the replaced
transaction.

You may be wondering where these sequence numbers come from. The
intention with sequence numbers from the beginning was to allow for a
kind of transaction replacement. The feature was early disabled in the
software, but the sequence numbers remained in the transaction
inputs. These sequence number have since been re-purposed for absolute
lock time, relative lock time, and replace by fee as described
throughout this chapter. If you feel confused, don't worry. We will
summarize the different uses of the sequence numbers in the summary of
this chapter.

==== Child pays for parent

There is yet another way to bump up a fee. Suppose that you have the
situation from <<stuck-transaction>>:

.You have not paid sufficient transaction fee. Transaction is stuck in pending state because miners don't want to include your transaction in a block.
image::{imagedir}/rbf-4.svg[{big-width}]

If you notice that this transaction gets stuck, you can make another
transaction that spends your change and pays an extra high fee to
compensate for the low fee in your original transaction.

.Spend your change and pay extra fee for the "parent" transaction.
image::{imagedir}/rbf-5.svg[{full-width}]

Suppose that a miner sees these two transactions. If the miner wants
to collect the fee from the child transaction, it has to include both
the parent transaction and the child transaction. If it tries to
include only the child transaction, the block wouldn't be valid
because the child transaction spends money that doesn't exist in the
blockchain.

This trick can be performed both by you and by the book store. Suppose
that you don't bump the fee at all. Then the book store can spend its
output of 10 BTC and pay themselves 9.9998 BTC to in order add 0.0002
BTC to the combined fee.

[[sighash-types]]
=== Different signature types

When you sign a typical Bitcoin transaction you sign the entire
transaction excluding the signature script.

.Normally the whole transaction is signed. All inputs and all outputs are covered.
image::{imagedir}/sign-transaction-all.svg[{half-width}]

This transaction contains two inputs and each input signs the complete
transaction. A signature _commits to_ all inputs and all outputs. If
any of the inputs or outputs change, the signature will become
invalid.

This behavior of signatures can be changed using a parameter in the
signature.

.A signature can commit to different parts of the transaction depending on the so called SIGHASH types. The greyed out parts are not included by the signature in the second input of each transaction.
image::{imagedir}/sign-transaction-combos.svg[{big-width}]

There are three ways to commit to outputs and two ways to commit to
inputs. For the outputs, you can commit to

* all outputs (ALL). No one gets to change any outputs.
* a single output at the same index as the input (SINGLE). I only care
  about the specific output. The rest may change.
* no outputs (NONE). I don't care at all where the money goes. Anyone
  can add any outputs without invalidating my signature.

For the inputs you can commit to

* all inputs (ANYONECANPAY is not set). No one can change any input
  without invalidating my signature.
* only the current input (ANYONECANPAY is set). Other inputs may be
  changed, removed or added. I don't care who pays. Anyone can pay.

Any combination of a input SIGHASH type and output SIGHASH type can be
used which makes 6 different combinations as in the figure.

For the vast majority of signatures, ALL in combination with unset
ANYONECANPAY is used to commit to the whole transaction. This is what
we are used to from all the chapters in this book. Other types are
really rare, and used primarily for specialized digital contracts.

=== Summary

This chapter has been a potpourri of things you can do with
transactions.

Transactions and transaction outputs can be time locked in different
ways to prevent funds from being spent until a certain date or time
span has occurred.

|===
| Do this | Means

| Set Lock Time of a transaction | The transaction will not be valid until a certain time/block height
| Set time lock on an input using the sequence number | The
  transaction will not be valid until a certain amount of time/blocks
  have passed
| Use `OP_CHECK**LOCKTIME**VERIFY` in a pubkey script | The output cannot be spent until a certain time/block height
| Use `OP_CHECK**SEQUENCE**VERIFY` in a pubkey script | The output cannot be spent until a certain amount of time/blocks have passed
|===

All these variants can be expressed in either block height or
time. Time based locks are mostly useful in digital contracts such as
atomic swaps. An atomic swap lets people who don't trust each other
swap coins without using a trusted third party.

image::{imagedir}/summary-atomic-swaps.svg[{full-width}]

The general idea is that John must reveal the secret, S, in order to
claim his coins. Fadime can then use S to claim her coins.

Arbitrary data can be stored in OP_RETURN outputs without placing a
burden on nodes' UTXO sets. This can be used to create tokens. For
example, the ownership of a car can be tracked and verified on the
Bitcoin blockchain.

Transactions can sometimes get stuck in a pending state because no
miner wants to include it in their blocks. This usually happens
because you have paid a too small fee. To prepare for this situation,
you can mark the transaction as replaceable by setting the sequence
number of at least one input to a value lower than `fffffffe`.

The sequence numbers of inputs are used for a variety of purposes. We
have discussed all different uses for sequence numbers in this
chapter, and it's hard to keep track of them. Let's summarize the
meaning of different values of the sequence numbers:

.Sequence numbers are used to enable or disable various features. [.big]#✔#=enabled, [.big]#✘# disabled.
[cols=">1,3*^3",options="header"]
|===
<| Sequence value (descending order)
<| locktime, any input
<| Replace by fee (BIP125), any input
<| relative lock time on input (BIP68). Tx version 2 required.

| `ffffffff` | [.big]#✘# | [.big]#✘# | [.big]#✘#
| `fffffffe` | [.big]#✔# | [.big]#✘# | [.big]#✘#
| `fffffffd` | [.big]#✔# | [.big]#✔# | [.big]#✘#
| `80000000` | [.big]#✔# | [.big]#✔# | [.big]#✘#
| `7fffffff` | [.big]#✔# | [.big]#✔# | [.big]#✔#
| `00000000` | [.big]#✔# | [.big]#✔# | [.big]#✔#
|===

=== Exercises

==== Warm up

1. What is required from the inputs of a transaction to enable absolute lock time?

2. Suppose a transaction is time locked (absolute) to 2019-12-25
  00:00:00. How does a miner check if the transaction is OK to put in
  a block.

3. Where is relative lock time of an input located?

4. How can you express a rule in an output saying "This output must
not be spent within 2048 blocks".

5. Suppose that Adam and Eve want to swap coins with each other using
an atomic swap. How many transactions would be created on each
blockchain upon completion?

6. Why is it bad for the UTXO set to store arbitrary data such as
"HELLO WORLD" as fake public key hashes in outputs as opposed to
storing them in OP_RETURN outputs?

7. Why would you want to replace a broadcast transaction that isn't
confirmed yet?

==== Dig in

[start=8]
8. Explain the differences between absolute lock time and relative lock time.

9. (This exercise is hard, feel free to skip it.) Suppose that you
want to bet 1 BTC that it's going to snow in London on Christmas Eve
and Ruth bets 1 BTC that it's not. You appoint a person, Beth, that
you both trust to solve any conflicts that might occur. You and Ruth
collaborate to create and broadcast a transaction that spend 1 BTC
each to an output of 2 BTC with the following redeem script. Explain
how the redeem script works on a conceptual level.

.The redeem script *can* be made smaller, but to make it simpler to read we use a slightly bigger version.
image::{imagedir}/ex-bet-escrow.svg[{full-width}]

[start=10]
10. If a p2sh output pays to a redeem script that consists solely of
an OP_RETURN with 32 random bytes, would full nodes be able to know
that the output is unspendable?
+
--
.redeem script
 OP_RETURN 53a1e411...b4e6d949
--

11. Please explain how the first-seen policy works. Also, are nodes
obliged to follow the policy?

[[exercise-rbf,Exercise 12]]
[start=12]
12. Opt-in replace by fee offers a method for transaction
replacement. Is there any fundamental security difference between a
transaction with opt-in replace by fee enabled and a transaction that
doesn't opt-in. Explain your reasoning.

=== Recap

In this chapter you learned that

* Transactions can be locked with respect to time or block height
  depending on your application needs. The locks can be either
  absolute or relative.

* A transaction output can require the spending transaction to be time
  locked. This useful in many digital contracts.

* Atomic swaps is a useful way to exchange cryptocurrencies between
  two parties that don't trust each other.

* Arbitrary data, for example a car ownership token, can be stored in
  OP_RETURN outputs without burdening the UTXO set.

* A transaction can be marked replaceable. This allows you to replace
  the transaction in case it doesn't confirm within reasonable time.

* Signatures can commit to different parts of the transaction using
  six combinations of SIGHASH types. This can be handy in certain
  digital contracts.
