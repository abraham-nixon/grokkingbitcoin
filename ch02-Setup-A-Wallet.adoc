== Setup a wallet
:imagedir: {baseimagedir}/ch02

This chapter covers

* installing a Bitcoin wallet
* understanding Bitcoin addresses
* securing your wallet

Now that the introduction is out of the way, let us get more
hands-on. We will walk you through the installation of a Bitcoin
wallet and explain some fundamental concepts that are important for
wallets. Not only for wallets but for the whole Bitcoin system. 

The main objective of this chapter is to teach you how the wallet
manages your private keys and how addresses are generated from those
private keys.

=== What is a wallet?

In section <<overview-wallets>> we noted that a wallet stores its
user's private keys. Now we will look deeper into how that is done. At
it's very core, a Bitcoin wallet is a container for private keys. The
private keys are what Bitcoin users need in order to spend their
money. Anyone that can get their hands on the private keys will be
able to spend the money. A wallet will help the user keep the private
keys safe from prying eyes as well as protect them from loss.

=== Install a wallet

To help you get a feel for what a wallet is, we will start by getting
a wallet installed on your device. There are a few steps involved in
installing a wallet:

. Select your wallet application
. Install the wallet application
. Start the wallet
. Backup your wallet

==== Select a wallet

There are several different wallet applications for a lot of
platforms, like Android phones, iPads, Linux computers and Windows
computers. The following table lists a good option for each major
mobile platform:

.Bitcoin wallet software for different platforms
|===
| Wallet name | Platforms

| Copay | Most platforms, including Windows Phone

| Mycelium | Android, iOS

| breadwallet | Android, iOS

//Should probably add specific app for desktops, to show that there
// are such options.
|===

While all these options are good for beginners, there are several
others on each platform. If you want to delve further into the
plethora of options, please visit http://bitcoin.org to find a wallet
that suits you.

I will use Copay throughout this book. You are free to try any of the
wallet applications, but they might differ a bit from Copay, which can
make it harder to follow the steps in this book. I chose Copay
primarily because it is available on all major platforms, so that you
can easily follow the examples no matter what platform you use. To
make it as easy as possible for you, I recommend that you use Copay as
well.

The instructions in this book will only use Copay. If you chose to use
another wallet, you may have to adjust my steps. The main steps are
usually the same on different wallets, but they may differ in how they
look and what security features they have. If you try one of the other
wallets and later change your mind, don't worry. You can install Copay
later and move your money to the Copay wallet instead.

==== Install your wallet

// TYPESETTER: This image should go to the right of the paragraph.
// Works in HTML, not in PDF.
image::{imagedir}/copay_logo.png[200,200,float="right",align="right"]

If you are on any of the popular mobile platforms, you should be able
to install the app right from where apps are installed on your
platform. Search for "copay" and make sure that the vendor is "BitPay,
Inc". The logotype of Copay is on the right. If you are on a desktop
computer, please go to https://copay.io/ to download a wallet for your
operating system.

==== Start your wallet

Once you have installed your wallet, either on your mobile device or
on a desktop computer, you are ready to start the application. On your
mobile device, start by hitting the icon for Copay. If you use a
desktop computer, follow the instructions on the web site
https://copay.io/.

When the wallet starts you will be presented with the "Terms of
Use". Read them if you want and then click on "I AGREE, GET
STARTED". Shortly after, you will be presented with a screen showing
the balance of your newly created wallet:

.Start screen of your wallet.
image::{imagedir}/startscreen.png[{quart-width}]

There's not much to see here. You have 0 _bits_. This brings us to the
world of Bitcoin units. One bitcoin is, as of writing, worth around 1000
USD, which makes bitcoin an impractical unit for smaller amounts, for
example a soda would cost about 0.001 bitcoin. Different units have emerged
throughout the Bitcoin community over time to overcome this issue:

[%autowidth]
|===
| Unit | Symbol | In bitcoin | Comment
| 1 bitcoin | BTC XBT | 1 | This is the most used unit.
| 1 bitcent | cBTC | 0.01 | Rarely used, but should make sense to people used
  to dollars and cents.
| 1 millibit | mBTC | 0.001 | Commonly used by wallet applications
| 1 bit, 1 microbitcoin | Î¼BTC bit | 0.000001 | Default unit of Copay
| 1 satoshi | sat | 0.00000001 | The smallest fraction possible today,
  named after the creator of Bitcoin, Satoshi Nakamoto.
|===

The default unit of Copay is bits, which is 0.00001 bitcoin. If you
prefer bitcoin instead, you can change the unit in Copay under
Menu->SETTINGS->Unit and select BTC.

I would like to congratulate you for your new wallet now, but there's
one more very important thing left to do before opening the
champagne. Backup.

=== Backup your wallet

Before doing anything at all with your wallet, you should do a proper
backup. In fact, Copay will not let you do anything before making a
backup. A wallet is just another software application on your phone or
computer, and the application's data may get stolen, lost or corrupted
at any time. There is no third party in Bitcoin, like with Google or a
Bank, that you can go to to recover lost funds. If you lose your
wallet data, you lose your bitcoins. Forever. Think of your bitcoins
as cash in a physical wallet.

Luckily, backing up a Bitcoin wallet is usually a smooth process. You
need

* your wallet application
* a pen
* a paper

Now is the time for you to grab the above needed items. When you are
back, please continue reading.

Start your wallet application and click on the little gear in the upper
right corner.

.Backup options is found here.
image::{imagedir}/settings.png[{quart-width}]

Click on "Backup". Your wallet will display twelve English
words. Use your pen to write those twelve words down on your paper. Do
not take a screen shot. Screen shots are saved on your phone or even on
on-line storage like Google Drive or Apple's iCloud.

.Your 12 words phrase.
image::{imagedir}/backup.png[{quart-width}]

.Backup your 12 words phrase.
image::{imagedir}/writing_mnemonic.jpg[{quart-width}]

The words you have written on your paper is your backup. You can
recover all your funds at any time in the future using that
paper. Anyone else who gets access to the paper will also be able to
do it. Just like the wallet, the backup should be thought of as cash.

You have now created your backup. It's time to verify that your backup
is OK. Click "CONTINUE" in your wallet application. Your twelve words
are displayed in alphabetic order. Click on them in the order you
wrote them down and click "CONTINUE".

.Verify your 12 words backup phrase.
image::{imagedir}/verify_backup.png[{quart-width}]

You will be congratulated by the
application. Click "FINISH".

Now, take the paper and store it in a safe place. When the paper is
stored safely, it is time for me to congratulate you to your newly
installed and backed up wallet!

.Congratulations!
image::{imagedir}/congratulations.jpg[{quart-width}]

=== Generate a Bitcoin address

The next step after setting up and backing up your wallet is to create
a Bitcoin address.

You are probably already familiar with email addresses. You can think
of Bitcoin addresses in the same way as email addresses. If you want
to send an email to your friend, you need your friend's email
address. If you want to send bitcoins to your friend, you need your
friend's Bitcoin address.

We will let your wallet create an address for you and in the next
section we will explore what the wallet software actually did to
generate the address. Your wallet will automatically create addresses
for you when you need them. In fact, your first address is already
generated, you just haven't seen it yet. Click on "Receive" in the
lower left corner of your screen in the Copay app.

//TYPESETTER these two images should preferably appear next to
//each other horizontally. Clicking on the "Receive" tab will result in
//the display of the new address.
//image::{imagedir}/generate_address.png[{quart-width},align="left",float="left"]

image::{imagedir}/generate_and_display_new_address.png[{quart-width}]

What you see on this screen is your Bitcoin address. It is displayed
in two ways: As plain text and as a QR code. A QR code is a way to
display text so that machines can easily scan it. Most mobile wallets
are able to scan QR codes of Bitcoin addresses to make payments.

The Bitcoin address in this example is

    1BZRcHHYE56JcX1wvGvoFuAA638Ye3zcUQ

Your Bitcoin address from your wallet will look different from the
above and the length of the address may differ slightly. An address
like this is what Bob needs to send to Alice in order to receive money
from her.

<<<
=== Cryptographic hashing

Cryptographic hashes are used all over the place in Bitcoin. Trying to
learn Bitcoin without knowing what cryptographic hashes are, is like
learning chemistry without knowing what an atom is.

A cryptographic hash function is a function that takes any digital
input data and produces a fixed-length output. The function will
output the exact same value each time the same input is used. But it
will output a totally different value when even the slightest
variation of the input is used.

You can think of a cryptographic hash as a fingerprint. A person will
produce the same fingerprint of her left thumb every time it is taken,
but it is extremely hard to find another person with the same left
thumb fingerprint. The fingerprint does not disclose any information
about the person other than her left thumb fingerprint. You cannot
know what math skills she has or the what eye color she has by looking
at her fingerprint.

Suppose that you want to receive a file from your friend via email,
but you suspect that the file may be accidentaly corrupted during
transfer. How would you and your friend make sure that the file you
receive is exactly the same as the file sent by your friend?

You can solve it by using a cryptographic hash function.

.Checking file integrity. Your friend calculates the cryptographic hash of a file and sends the file and the hash to you. You calculate the cryptographc hash of the received file and compare it to the hash provided by your friend.
image::{imagedir}/email-file-hash.png[{big-width}]

Your friend composes an email to you. He attaches the file to the
email, but he also calculates the cryptographic hash, the digital
fingerprint, of the file. That hash is written down in the body of the
email.

When you receive this email, you save the file to your computer and
calculate the hash of that file. If the result is the same as the hash
in the email, you know for sure that the file is not accidentally
corrupted.

Let us have a look at what properties you can expect from a
cryptographic hash function. We will illustrate the properties using
the SHA256 algorithm, because it is the one that Bitcoin uses the
most. There are several different cryptographic hash functions, but
they all provide the same basic features:

.A cryptographic hash function, SHA256, in action. The input "Hello!" will give you the same output every time, but the slightly modified input "Hello" will give you a totally different output.
image::{imagedir}/cryptographic_hashing.png[{big-width}]

The output of a cryptographic hash function is often referred to as a
_hash_ or a _digest_. I will use the term hash here, but either is
equally valid.

. The same input will always produce the same hash.
. Slightly different inputs will produce very different hashes.
. The hash is always of the same fixed size. For SHA256 it is 256
  bits, that is 32 bytes.
. It is a one-way function. Trial-and-error is the most efficient
known way to find an input that gives a certain hash.

The first three properties are illustrated in the diagram above. The
fourth property of cryptographic hash functions is what makes it a
_cryptographic_ hash function and this needs a bit more elaboration.

There are some variations to the fouth property, all of which are
desirable for cryptographic hash functions:

Collision resistance:: It's very hard to find two inputs that give _the same_ hash.
Preimage resistance:: It's very hard to find an input that gives _a certain_ hash.
Second-preimage resistance:: It's very hard to find an input that
gives _the same hash as a certain other input_.

.Different desirable properties for cryptographic hash functions. For collision resistance, X can be anything, it does not matter as long as the two inputs give the same output.
image::{imagedir}/hash-properties.png[{big-width}]

The term "very hard" in this context means astronomically hard. It is
silly to even try. We will have a look at second-preimage resistance
as an example of what "very hard" means, but a similar example can be
made for any of the three variants.

==== Illustration of "very hard"

Suppose that you want to find an input to SHA256 that results in the
same hash as "Hello!":

 334d016f755cd6dc58c53a86e183882f8ec14f52fb05345887c8a5edd42c87b7

There is no way to change the input just a little bit so that the
function "won't notice". It will notice and output a totally different
hash. Every hash looks random, but they are not actually random, since
they are calculated from the input, and every time you use the same
input, the same hash will be produced. The only way to find an input,
other than "Hello!", that gives the hash
"334d016f755cd6dc58c53a86e183882f8ec14f52fb05345887c8a5edd42c87b7" is
to try different inputs one by one and check if it produces the
desired hash.

Let's try.

.Finding an input with the same hash as "Hello!". Nearly impossible.
[%autowidth]
|===
| Input | Hash | Success? 
| Hello1! | 82642dd9e405f3f4265e2ca3c4c440e8c204f26a1b6f35fdf1ca2a642e366e64  | nope 
| Hello2! | 493cb8b9dcb11590fe2fa72efd0d5f2fa70beda31ad0e5e8a76caa5f83ba14f8  | nope
| Hello3! | 90488e861be3a5b762f40d4d2f1f2f7338f3f76a100ce3e4996dde8164530bae  | nope 
| Hello4! | 86bc15b47d6886637a2e2083ea2f0405c6c8693cad9d1dc4864755ffe1ae748d  | nope 
| ... | ... | nope
| Hello9997! | 243358aaea3d234c09467ef449986bde25b462f5c72d50d655cb28987228646f  | nope 
| Hello9998! | cf0bc6de6fd0aea26e1c68212710eea49ec6e913a7be0748e48cddcee6b0caa4  | nope 
| Hello9999! | df82680f143cb292f46c4d0414b816c926d0fb659884c28df1dab01bef9bc235  | nope 
| Hello10000! | 466a7662d9c183e52eeab8e9a261749d61bafa500101ef2aeed52315ce77859c  | nope 
|===

As you can see, we are not very successful. Let us think about how
much time it would take for a typical desktop computer to find such an
input. It can calculate about 60 million hashes per second and the
expected number of tries needed to find a solution is 2^256^. The
result is 2^256^ / (60*10^6^) s = 1.9*10^69^ s = 6*10^61^ years, or
about

 60000000000000000000000000000000000000000000000000000000000000 years

I think we can stop trying, don't you? I don't think buying a faster
computer will help either. Even if we had 1 trillion computers and ran
them concurrently it would take about 6*10^49^ years.

Preimage resistance, second-preimage resistance and collision
resistance are extremely important in Bitcoin. Most of its security
relies on these properties.

Exercise: Does the file transfer example protect against malicious
modifications during transfer? Suppose that someone with access to
your email service provider can tamper with the email while in
transit, could she modify the email in any way so that you accept a
modified file without noticing? If so, how could you and your friend
prevent that?

<<<

=== The cookie sheet

Suppose that there is a cafÃ© in the office where you work. You and
your coworkers use a spreadsheet to keep track of "cookie
tokens", CT. Cookie tokens can be exchanged for cookies in the cafÃ©.

.The cookie sheet have a column for the sender, a column for the recipient and a column for the amount of Cookie Tokens transferred. New cookie token transfers are appended at the end of the cookie sheet.
image::{imagedir}/cookie-sheet-basic.png[{half-width}]

This spreadsheet is stored on Lisa's computer. The spreadsheet is
shared read-only for everybody on the office network to open and
watch, except Lisa. Lisa is very trustworthy. Everybody
trusts her. She has full access to do whatever she likes with the
spreadsheet. You and all the others can only view the spreadsheet by
opening it in read-only mode.

Whenever Alice wants a cookie, she asks Lisa, who sits right next to
the cafÃ©, to transfer 10 tokens from her to the cafÃ©. Lisa knows who
Alice is and can verify in the cookie sheet that she owns enough cookie
tokens. She will go through all rows in the cookie sheet and sum all
the amounts with Alice's name in the "To" column and subtract all the
amounts with Alice's name in the "From" column. Here is the complete
list of transfers involving Alice:

.Lisa calculates Alices's balance. The sum of her received CT is 100 and the sum of her widthdrawn CT is 30. Alice's balance is 70 CT.
image::{imagedir}/johns-transfers-in-cookie-sheet.png[{half-width}]

Lisa calculates that Alice has 70 CT. That is enough for Alice to pay 10
CT to the cafÃ©. She edits the cookie sheet by adding a row at the end:

image::{imagedir}/john-buys-cookie.png[{half-width}]

The cafÃ© sees this new row in the cookie sheet and hands over a cookie
to Alice.

When you run out of cookie tokens, you can buy tokens for dollars from
someone who has an exessive amount of cookie tokens, possibly Anne or
the Cafe, at a price you both agree on. Lisa will then add a row to
the cookie sheet accordingly. This cookie sheet system works quite
well and everybody eats a helthy amount of cookies.

=== Digital signatures

The company is doing well and grows rapidly. After a while Lisa has a
hard time recognizing everyone. She notices that some people are not
honest. For example Malory says that she is Anne, to trick Lisa into
moving cookie tokens from Anne to the cafe, instead of from Malory to
the cafe.

Things are getting out of hand, so Lisa thinks out a great plan. She
is going to require everybody to _digitally sign_ their cookie token
transfers, by writing a message and a _digital signature_ on a piece of
paper or in an email.

A digital signature is a digital equivalent of a hand written
signature. The difference is that a hand written signature is tied to
a person, while a digital signature is tied to a random number called
a private key. A digital signature is much harder to forge than a hand
written signature.

Digital signatures have been around for decades. You probably already
use digital signatures every day without knowing it. For example, when
you login to your online bank, your web browser will verify that the
web site's authenticity is signed by an authority, with a private key,
that your web browser trusts. If so, you will see a comforting padlock
in the address bar of your browser.

There is a new guy at the office, John. The company gave him some CT
as a welcome gift when he started. Now John wants to make use of those
Cookie Tokens. He needs to digitally sign a cookie token
transfer. This is what he has to do:

.The digital signature process. 1. John creates a keypair and gives the public key to Lisa. 2. John signs a message with the private key. 3. Lisa verifies that the message is signed with the private key belonging to the public key she got from John.
[[generate-key-pair]]
image::{imagedir}/generate-key-pair.png[{big-width}]

There are three phases in this process.

. John prepares by generating a key pair. The private key is kept
secret by John, and the public key is handed over to Lisa. This is a
one-time setup step.
. John wants a cookie. He writes a message and signs it with his
private key. He gives the message and the digital signature to Lisa.
. Lisa verifies the signature of the message using Johns public key
and updates the cookie sheet.

==== Preparation: John generates a key pair

The signing and validation process is based on a pair of a private key
and a public key. John needs a private key in order to sign something
and Lisa will need John's public key in order to verify John's
signatures. John needs to prepare for this by creating a key pair. The
key pair is created by first generating a private key and then
calculate the public key from that private key.

.John creates a key pair. The private key is a huge random number and the public key is derived from that random number. The private key is stored on his hard drive and the public key is handed to Lisa.
image::{imagedir}/create-keypair.png[{big-width}]

John will use a random number generator to generate a huge, 256 bit,
random number. This random number is now John's private key. The
private key is then transformed into a public key using a public key
derivation function. The public key derivation function is a one-way
function, just as the cryptographic hash functions discussed
earlier. You can not derive the private key from the public key. The
security of digital signatures relies heavily on this feature.

How the public key derivation function works exactly is beyond my
knowledge. Luckily, you do not have to be a cryptography expert to
understand how digital signatures works from a user perspective. The
private and public keys are thought of as a pair because they have a
very strong relationship; The public key can be used to encrypt
messages that only the private key can decrypt. It also works the
other way around, the private key can encrypt messages that can only
be decrypted by the public key.

.Encrypting and decrypting with the public and private keys. Left: Encrypt with the public key and decrypt with the private key. Right: Encrypt with the private key and decrypt with the public key.
image::{imagedir}/enc-dec-public-private.png[{big-width}]

Encryption is used to make messages unreadable to parties that don't
hold the proper decryption keys. In the left example, only John would
be able to read the encrypted message because he is the only one with
access to his private key. In the right side example, Lisa can decrypt
the message because she has the public key belonging to Johns
private key. It is not good practice to use the private key to encrypt
messages because the public key is, you guessed it, public. When john
hands his public key to Lisa, someone might overhear the conversation,
or Lisa might leave her table with public keys open on her computer
screen. And that's okay. The public key is not secret in any way. That
is why it is a bad idea to encrypt with the private key and expect the
message to be secure.

To illustrate the relationship between the private and the public
keys, imagine a drawer with a lock. The lock has three states: Left
(locked), Up (unlocked), and Right (locked). There are two keys to
this lock, one key can only turn the lock to the right, clockwise, and
the other key can only turn the lock to the left, counterclockwise.

image::{imagedir}/locked-box.jpg[{quart-width}]

Let's assume that John selects the right-only key to be his
private key. The left-only key is then his public key. He could chose
either one of them to be the private key, it does not matter. He makes
several copies of the public key and hands them out to Lisa, Ellen and
a bunch of other people. He keeps the private key to himself in his
pocket.

Ellen can now encrypt a secret message to John. She writes a note with
the secret message

 Hey, your zipper is down

and puts it in the drawer, closes the drawer and locks it with her
copy of the public key. The public key only turns to the left, so when
she is done the lock is in its leftmost position. The drawer is now
locked. To open the drawer you need a key that can turn the lock to
the right. Only John's private key can do that. None of the copies of
the public key will help, because they can only turn to the left.

John, who is the only one with the private key, can now use his
private key, that only turns right, to unlock the drawer and read the
secret message. He is confident that the message has not been read by
anyone else during its time in the drawer, because he has had his
private key in his pocket all the time. He gently turns around and
zips up.

==== John signs his payment

The previous example was an illustration of the encryption feature of
public and private keys. But while John was able to read the secret
message from Ellen, he could not tell _who_ wrote the message. Anyone
with a copy of the public key could have done that.

But this drawer has another great feature. It can be used by John to
write a message that anyone with the public key can read and be
absolutely sure that it was John who wrote the message. This is an
example of a digital signature.

Say that John wants to send the message

 Lisa, please move 10CT to Cafe. /John

to Lisa. He gave Lisa his public key, that only turns left, in the
previous section. John writes the message on a note and puts it in the
drawer. He closes the drawer and locks it with his private key, that
only turns right. When he is done, the drawer is locked in the
rightmost position. Everyone knows how this drawer works, so everyone
is aware that only the private key can lock the drawer in this way,
because only the private key can turn the lock to the right.

Lisa can now use her copy of the public key to unlock the drawer by
turing it left one step to the upright, unlocked, position. She takes
out the note and reads it. She knows for sure that John put this
message in the box, because he is the only person with the
private key. Lisa can now trust that the message is from John and move
10 cookie tokens from him to the cafÃ©.

Let's leave the drawer analogy and have a close look at how the
signing really happens.

.John digitally signs the transfer of 10 CT to the cafÃ©. The message to Lisa is first hashed and then encrypted with John's private key. The note to Lisa contains both the message in clear text and the signature.
image::{imagedir}/signing-details.png[{big-width}]

The message that John wants to sign is "Lisa, please move 10CT to
Cafe. /John". The signing function will hash this message with SHA256
whose output is a 256 bit number. This hash value is then encrypted
with John's private key. The result is a string that looks like
garbage:

 INxAs7oFDr80ywy4bt5uYPIv/09fJMW+04U3sJUfgV39
 A2k8BKzoFRHBXm8AJeQwnroNb7qagg9QMj7Vp2wcl+c=

This is the signature. If John would have used another private key or
a slightly different message as input, the signature would have looked
completely different. For example, using the input message "Lisa,
please move 10CT to Malory. /John" would render this signature:

 IBkECIzYrfw6pEEdAUbDpD32rq481j6h5a7UrEYG6BBz
 dmZmsFAtT+cvXTZbpwC76/gMES9DCcS5ArjhCDjwbq8= 

This is not even remotely similar to the previous signature. This is
good to know for John, as he knows that his signature cannot be used
for other messages than his intended message.

The last thing that John does is to compose a note to Lisa and give it
to her.

==== Lisa verifies the signature

Lisa does not recognize John. She looks at the note and sees that the
note claims to be from John, so she looks up John in her table of
public keys.

.Lisa uses the message (1), the signature (2) and John's public key (3) to verify that the message is actually signed with John's private key.
image::{imagedir}/verify-signature.png[{big-width}]

The purpose of Lisa's actions in this picture is to determine that the
cookie token transfer was signed by the private key it claims to be
signed with. The message says it is from John. She did receive Johns
public key the other day and she put the public key in her table of
public keys. The things she has at hand is

. The message "Lisa, please move 10CT to Cafe. /John"
. The Signature `INxAs7oFDr8...`
. Johns public key that she just looked up in her table

If the signature is correct, it should be the hash of the message
encrypted with Johns private key. So if Lisa decrypts the signature
(2) with John's _public_ key (3), the result should be the same hash.

Lisa takes the signature (2) and decrypts it with the public key (3)
she looked up in her table of public keys. The decryption outputs a
big number. If this number is equal to the hash of the message (1), it
proves that John's private key was used to sign the message. Lisa
takes the message (1), exactly as written, and hashes that message
just like John did when he created the signature. This message hash is
then compared with the decrypted signature. The message hash and the
decrypted signature match.

Lisa can now be sure that no one is trying to fool her. She updates
the cookie sheet with John's transfer:

.Lisa have added a row for John's cookie token transfer after verifying the signature of John's message.
image::{imagedir}/cookie-sheet-basic-johns-transfer.png[{half-width}]

<<<

=== Digtal signatures in Bitcoin

Bitcoin uses digital signatures to authenticate transfers of bitcoins
from a Bitcoin address. 


==== Public and private keys

==== Digital signatures


Bob loves Alice

* Create a keypair
* Encrypt with private key, decrypt with public key
* Encrypt with public key, decrypt with private key
* Sign

Signs a message that Alice verifies




Alice sends a paymet to Bob. Bob then sends money to Charlie. He signs
with the private key from the address she gave to Alice.

=== The Bitcoin address creation process

This section will go deep on what a Bitcoin address is and how it is
created. The Bitcoin address creation process is complex and some new
pretty hard topics will be introduced, but we will take it slow. I
recommend you to carefully read and understand this section, because
the topics you will learn here is vital for the rest of this book. If
you do not get it, please try again. If you still have a hard time
understanding, you should go to the movies and revisit this section
tomorrow.

Bob wantâs to receive bitcoins from Alice in our example from chapter
1, so he needs to create a Bitcoin address to give to Alice.

==== Overview

The Bitcoin address creation process involves a number of technical
topics. These topics will be covered after this overview section, but
here is a brief intro to the topics.

Public-key cryptography:: A technique using key pairs, a pair of a
private key and a public key, to digitally sign and verify digital
information. During the Bitcoin address creation process a key pair
will be generated, but no signing will take place.

Cryptographic hash function:: This is a family of algorithms that
takes any data as input and outputs a fixed length huge number.

Base58 encoding:: This is a way to translate a series of bytes into a
series of letters and digits, suitable for humans to read.

Let us start with a big diagram of the whole process and then break it
down.

.Bitcoin address creation process. The process goes through three phases: 1) Create a private-public key pair, 2) Hash the public key, and 3) Encode the public key hash into a manageable and error resistant format. The encoding part is reversible, you can move from the Bitcoin address after step 3 to the hash value at step 2.
image::{imagedir}/mental_model_address_creation.png[{full-width}]

The process is divided into three major parts. The first part,
Public-key cryptography, is used to generate a key pair of a private
key and a public key. Public-key cryptography is used in Bitcoin for
signing transactions and verify those signatures. The private key is
used to digitally sign a transaction and the public key is used to
verify the signature. You can easily derive the public key from the
private key through the Public key derivation function, but you cannot
derive the private key from the public key. This property is known as
a one-way function.

The second part, cryptographic hashing, is a way to get a fixed length
"fingerprint" of the public key. The hashing is done in two steps, but
both steps conceptually do the same thing, transform the input into a
fixed length number. The first transforms the public key into a 256
bit number and the second transforms this 256 bit number into a 160
bit number. As with public key derivation, cryptographic hash
functions are also one-way functions.

In the third part we add some meta data to the hashing output and
encode it with base58. We add a version number of the address format,
`00`, and a checksum. The checksum is used to prevent sending money to
a non-existing Bitcoin address due to bad spelling or transfer issues
when sending the address. The versioned and checksummed hash is finally
encoded with base58 to make it human readable.

Let us now dig deeper into these three steps in order of appearance.

==== Create a key pair

:cap: Step 1 of the Bitcoin address creation process. First a huge \
random number, the private key, is created. The private key is then \
transformed by a cryptographic function into a public key.
.{cap}
image::{imagedir}/public_key_cryptography.png[{full-width}]

The key pair is created by first generating a huge random number. This
can be done with a random number generator. A random number generator
is usually provided to applications, for example your wallet, by the
operating system. Its only purpose is to output bytes of random
data. We ask the random number generator for 32 bytes of random
data. This random data is our private key. A private key must not be
shared with any other person. I break that rule in this example, by
disclosing the private key, but I know that I am not going to use it
to store my money.

When you backed up your Bitcoin wallet, you wrote down 12 words on a
piece of paper. That is known as your wallet's random seed. When your
wallet created your first Bitcoin address, it did not directly use the
random number generator, but it was derived from the random seed. This
is a technique used by most modern wallet applications. That process
is not included in this chapter, because it unnecessarily adds to the
complexity. The process works just as fine, and is more easily
explained, by directly using a random number generator. The random
seed technique, called _hierarchical deterministic wallets_ will be
covered in [REFERENCE to chapter 5].

The private key is used as input to the public key derivation
function. It is a one-way function that will output another huge
number called the public key. The public key and private key have a
very special relationship. The private key is used in Bitcoin for
making _digital signatures_ and the public key is used to verify
those signatures.

===== Digital signature example

Let us say that it's Wednesday afternoon and Bob wants to send the
message

 Alice, I love you. /Bob

to Alice. But he fears that someone else might also send messages to
Alice in Bob's name. Not nice. How can Bob send the message so that
Alice can be sure that the message is actually from Bob?

Alice and Bob knows about public-key cryptography. Earlier this
morning, Alice and Bob met up at a cafe for breakfast before Alice
went to work. During breakfast Bob gave Alice his public key. Alice
now knows that this public key belongs to Bob. She also knows that
_only_ Bob have access to the private key.

Now, it is Wednesday afternoon and Alice is working. Bob decides to
send his message to Alice.

.Bob signs his message with his private key and sends the message, his public key and the signature to Alice who verifies it with the public key she knows belongs to Bob.
image::{imagedir}/sign_message.png[{full-width}]

On the left side of the picture, Bob is using his private key that
only he has access to. He uses it to digitally sign the message
"Alice, I love you. /Bob". He then puts the message, his public key
and his newly created signature in an email and sends it to Alice.

Alice reads the message, but she is very concerned with security and
she wants to make sure this message is actually from Bob. So she takes
the public key that she knows belongs to Bob, the one she got at
breakfast, and compares it to the public key in the message. They
match. Using the message, the public key and the signature she can now
verify that only Bob could have created this signature.

The signature function takes the data to sign as input. In this
example it is the text "Alice, I love you. /Bob", but it could be
anything. When Alice verifies the signature she must input the exact
message as Bob was signing, otherwise the verification will fail.

We will look more closely at digital signatures in [REFERENCE chapter
4]. For now we can just conclude that Bob's wallet have created a
cryptographic key pair that can be used to sign and verify stuff. The
wallet have stored the private key for later use. The public key is
passed on to the next step in the Bitcoin address creation process.

==== Hash the public key

Bob's wallet have created a private and a public key in step 1 of the
Bitcoin address creation process. His wallet will now take the public
key and transform it using a process called cryptographic hashing.

.Step 2 of the Bitcoin address creation process. A cryptographic hash is a huge number generated from its input. Different inputs generate different outputs with very high probability. It is extremely hard to find two different inputs with the same outputs.
image::{imagedir}/hash_the_public_key.png[{full-width}]

Two different types of cryptographic hashing will take place. The
public key will first be run through SHA256, which will output a huge
number. The result will further be run through RIPEMD160. Both of
these hashing algorithms have the same principal characteristics:

. The same input will always produce the same output.
. Slightly different inputs will produce very different outputs.
. The output is always of the same fixed size. For SHA256 it is 256
  bits, or 32 bytes.
. It is a one-way function. Trial-and-error is the most efficient
known way to find an input that gives a certain output. This is known
as _Preimage resistance_.

.A cryptographic hash function have some interesting properties: 1. Same input always gives the same output. 2. Different inputs give different outputs. 3. Output has fixed size.
image::{imagedir}/cryptographic_hashing.png[{full-width}]

You can think of a cryptographic hash as a fingerprint. A person will
produce the same fingerprint of her left thumb every time, but it is
extremely hard to find another person with the same left thumb
fingerprint. The fingerprint does not disclose any information about
the person other than her left thumb fingerprint. You cannot know what
math skills she has or how tall she is by looking at her
fingerprint. It is the same with hash functions, you cannot know
anything about the input by looking at the output.

The public key is hashed because we don't want to expose our public
key by giving someone a Bitcoin address. At least not yet. If the
public key is exposed and someone finds a weakness in the public-key
cryptography used, they might find a way to derive the private key
from the public key. But if we only expose a hashed version of the
public key, there must be very serious weaknesses in all three of our
public-key cryptography, SHA256 and in RIPEMD160 at the same time in
order to have a chance at figuring out the private keys.

The first hashing algorithm, SHA256, will output a number of 256
bits. And the second algorithm, RIPEMD160, will output a number of 160
bits. RIPEMD160 is used for two reason:

* The shorter output of RIPEMD160 will result in a shorter, more
  manageable, Bitcoin address.
* If either of RIPEMD160 or SHA256 turns out to be weak, meaning
  property 4 doesn't hold, then the other algorithm will keep the
  public key safe.

The fourth property of cryptographic hash functions, _preimage
resistance_, is what makes it a _cryptographic_ hash function and this
needs a bit more elaboration.

===== Preimage resistance

Suppose that you want to find an input to SHA256 that results in the
same output as "Hello!".

There is no way to change the input just a little bit so that the
function "won't notice". It will notice and output a totally different
number. Every output looks random, but they are not actually
random. They are calculated from the input, and every time you use the
same input, the same output will be produced. The only way to find an
input, other than "Hello!", that gives the output
"334d016f755cd6dc58c53a86e183882f8ec14f52fb05345887c8a5edd42c87b7", as
in [REFERENCE figure 25], is to try different inputs one by one and
check if it produces this output.

Let's try.

.Finding an input with the same output as "Hello!". Nearly impossible.
[%autowidth]
|===
| Input | Output | Success? 
| Hello1! | 82642dd9e405f3f4265e2ca3c4c440e8c204f26a1b6f35fdf1ca2a642e366e64  | nope 
| Hello2! | 493cb8b9dcb11590fe2fa72efd0d5f2fa70beda31ad0e5e8a76caa5f83ba14f8  | nope
| Hello3! | 90488e861be3a5b762f40d4d2f1f2f7338f3f76a100ce3e4996dde8164530bae  | nope 
| Hello4! | 86bc15b47d6886637a2e2083ea2f0405c6c8693cad9d1dc4864755ffe1ae748d  | nope 
| ... | ... | nope
| Hello9997! | 243358aaea3d234c09467ef449986bde25b462f5c72d50d655cb28987228646f  | nope 
| Hello9998! | cf0bc6de6fd0aea26e1c68212710eea49ec6e913a7be0748e48cddcee6b0caa4  | nope 
| Hello9999! | df82680f143cb292f46c4d0414b816c926d0fb659884c28df1dab01bef9bc235  | nope 
| Hello10000! | 466a7662d9c183e52eeab8e9a261749d61bafa500101ef2aeed52315ce77859c  | nope 
|===

As you can see, we are not very successful. Let us think about how
much time it would take for a typical desktop computer to find such
an input. It can calculate about 60 million hashes per second and the
expected number of tries needed to find a solution is 2^256^. The
result is 2^256^ s / (60*10^6^) = 1.9*10^69^ s = 6*10^61^ years, or about

 60000000000000000000000000000000000000000000000000000000000000 years

I think we can stop trying, don't you? I don't think buying a faster
computer will help either. Even if we had 1 trillion computers and ran
them concurrently it would take about 6*10^49^ years.

This preimage resistance is extremely important in Bitcoin. Most of
its security relies on this property.

==== Encode the Bitcoin address

Now that the cryptographic hashing is done, we have come to the last
part, step 3, of the Bitcoin address creation process. Bob's wallet will
encode the hash in a certain way to make it recognizable by the
Bitcoin network and to make typing errors detectable. 

.Step 3 of the Bitcoin address creation process. The hash of the public key is decorated with a version number and a checksum. Then the decorated hash is encoded with base58 to produce the final Bitcoin address.
image::{imagedir}/address_encoding.png[{full-width}]

The first thing that happens is that `00` is added at the beginning of
the public key hash. This is a version number of the Bitcoin address
format. The version is used for future upgrades of the Bitcoin
system. There are other versions as well, but "00" is the most
common one.

This versioned hash is then hashed twice through SHA256, then we take
the first four bytes, `12181e60`, and append them at the end of the
versioned hash. These four bytes functions as a checksum that protects
us from almost all typing errors.

The versioned and checksummed public key hash is now 25 bytes:

 005f2613791b36f667fdb8e95608b55e3df4c5f9eb12181e60

We have displayed all data in this example _hex encoded_, meaning that
every byte is written as two hexadecimal digits, 0-f, 0 means zero and
f means 15. In reality the data is just a sequence of 25 bytes, each
with value 0-255. The last step in the address encoding phase is to
make those 25 bytes readable and writable by humans. It would require 50
characters to hex encode the data. We can do better than that.

Base58 encoding is an encoding scheme that uses printable characters
and avoids confusion over characters that look similar in print, `l` and
`I`, and `0` and `O`.

Let us encode the following 25 bytes from the picture above using the
base58 scheme.

 005f2613791b36f667fdb8e95608b55e3df4c5f9eb12181e60

The result is a newly created Bitcoin address consisting of the
following 34 characters

 19g6oo8foQF5jfqK9gH2bLkFNwgCenRBPD

This is a shorter string than the hex encoded one but we have not
lost any information. It is shorter because every character carries
more information. Instead of 16 different possible values per
character as in hex code, we have 58 different possible values per
character in base58. The characters used by base58 are

 123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz

They consist of all digits, capital letters and lower case letters
except `0`, `O`, `I` and `l`. These four characters are removed
because they can look very similar in certain fonts. Note that the
Bitcoin address starts with an `1`. That is a result of the version
prefix `00` that we added first in this step. This means that all
Bitcoin addresses with version `00` will start with an `1`. You can
distinguish between different Bitcoin address versions by looking at
the first character of the Bitcoin address.

All processes in step 3 are reversible. You can calculate the public
key hash from the Bitcoin address.

We noted above that the checksum protects us from typing errors. Let's
say that Bob gives this address to Alice who enters the address in her
wallet application. Suppose all goes well without typing
errors. Alice's wallet will check the address as follows:

image::{imagedir}/decode_good_address.png[]

The process takes the provided address and decodes it from base58
encoding to a sequence of 25 bytes. The last 4 bytes is supposedly the
checksum, so let's verify that. Remove the checksum and run the
remaining 21 bytes through the checksum just as in the address
encoding phase. Then compare the result with the provided
checksum. They match, which means that the address is good. Very well.

But let's assume that Bob made a typing error when he sent the address
to Alice. He wrote `L` instead of `K` which results in this bad
address instead:

[subs=+quotes]
 19g6oo8foQF5jfq**L**9gH2bLkFNwgCenRBPD

When Alice wants to pay Bob using this bad Bitcoin address, her wallet
will check the address as follows:

image::{imagedir}/decode_bad_address.png[]

The base58 decoding will output a different sequence of 25 bytes as in
the correct address decoding which will produce a different calculated
checksum than the provided checksum. Since the checksums do not match,
the wallet will refuse to send money to that address. Alice will be
warned by the wallet and she will ask Bob to check his address and
send a valid one instead. If checksumming was not used in Bitcoin
people would mistakenly send money into an address that no-one have
the private key for. The money would be lost forever.

==== Summary

Bob have set up his wallet and created a Bitcoin address using the
Bitcoin address creation process.

.Summary of the Bitcoin address creation process
image::{imagedir}/address_creation_summary.png[{quart-width}]

His wallet generated a key pair, a private key and a public key. The
private key is kept secret by the wallet. It will be used later to
sign transactions. The public key is passed to the hashing phase where
it is hashed into a 20 bytes number, the public key hash. This hash is
decorated with a version and a checksum. Finally, the decorated public
key hash is encoded using base58 into a human-readable string
`19g6oo8foQF5jfqK9gH2bLkFNwgCenRBPD` which is the final result. Bob
now has a brand new Bitcoin address that he can give to Alice.

So far, your wallet have not yet had to connect to any service outside
of the wallet. No user account have been created on any web server.
You did not ask anyone for permission. No communication at all has
occurred with any internet servers to setup your wallet and create
your Bitcoin address. This feature is part of the decentralized
architecture of Bitcoin. You could say that your Bitcoin address is
your account, but it is created and managed locally on your mobile
phone.
