[id=ch02]
== Digital signatures - Securing cookie tokens
:imagedir: {baseimagedir}/ch02
This chapter covers

* Creating a simple money system, Cookie Tokens
* Understanding cryptographic hashes
* Authenticating payments using digital signatures
* Keeping your secret codes secret

We will start the chapter by setting the stage for the rest of this
book. We will describe a very simple payment system that we will
improve upon using Bitcoin technologies. By the end of this book the
simple system will have evolved into what we call Bitcoin.

The only fundamental technical skill you need in order to start
learning Bitcoin is cryptographic hashes. Cryptographic hashes are so
important to Bitcoin that you really need to understand them before
starting to learn anything else. The second section of this chapter
will teach you what you need to know about cryptographic hashes.

The rest of the chapter will solve the problem of the imposter,
someone claiming to be someone else to pay money from that someone's
account. We solve that by introducing digital signatures to the simple
system.

=== The cookie token spreadsheet

Suppose that there is a cafe in the office where you work. You and
your coworkers use a spreadsheet to keep track of "cookie
tokens", CT. Cookie tokens can be exchanged for cookies in the cafe.

[.inbitcoin]
.Bitcoin, the currency
****
A cookie token correspond to a bitcoin, the currency unit of
Bitcoin. Bitcoin got its first price point 2010 when someone bought
two pizzas for 10000 BTC. That money would get you 500000 pizzas
today.
****

.The spreadsheet have a column for the sender, a column for the recipient and a column for the amount of cookie tokens transferred. New cookie token transfers are appended at the end of the spreadsheet.
image::{imagedir}/cookie-sheet-basic.png[{half-width}]

This spreadsheet is stored on Lisa's computer. The spreadsheet is
shared read-only for everybody on the office network to open and
watch, except Lisa. Lisa is very trustworthy. Everybody
trusts her. She has full access to do whatever she likes with the
spreadsheet. You and all the others can only view the spreadsheet by
opening it in read-only mode.

Whenever Alice wants a cookie, she asks Lisa, who sits right next to
the cafe, to transfer 10 tokens from her to the cafe. Lisa knows who
Alice is and can verify in the spreadsheet that she owns enough cookie
tokens. She will search for 'Alice' in the spreadsheet and sum all the
amounts with Alice's name in the "To" column and subtract all the
amounts with Alice's name in the "From" column. Here is the complete
search result, there are three transfers, involving Alice:

.Lisa calculates Alice's balance. The sum of her received CT is 100 and the sum of her withdrawn CT is 30. Alice's balance is 70 CT.
image::{imagedir}/alices-transfers-in-cookie-sheet.png[{big-width}]

Lisa calculates that Alice has 70 CT. That is enough for Alice to pay 10
CT to the cafe. She appends a row at the end of the spreadsheet:

image::{imagedir}/alice-buys-cookie.png[{half-width}]

The cafe sees this new row in the spreadsheet and hands over a cookie
to Alice.

[.gbinfo]
.Earn them
****
You may also get cookie tokens as part of your salary.
****

When you run out of cookie tokens, you can buy tokens for dollars from
someone who has an excessive amount of cookie tokens, possibly Anne or
the cafe, at a price you both agree on. Lisa will then add a row to the
spreadsheet accordingly. Lisa have promised never to remove or change
anything in the spreadsheet, just add to it. What happens in the
spreadsheet, stays in the spreadsheet! This spreadsheet system works
quite well and everybody eats a healthy amount of cookies.

This is our starting point for learning how Bitcoin works. We call
this version 1.0 of the cookie token spreadsheet system:

[%autowidth,options="header"]
.Release notes, cookie tokens 1.0
|===
|Version|Feature|How

|1.0
|Simple payment system
|Relies on Lisa being very trustworthy and knowing everyone's face
|===

We will add a lot of fancy stuff to this system and a new version will
be released in every chapter. For example, at the end of this chapter
we will release version 2.0 that solves the problem of the
imposter. Every chapter will take us closer to the end result, Bitcoin.

[id=cryptographic_hashing]
=== Cryptographic hashes

// Fingerprint analogy
// A CHF is computer program
// Hash a cat picture
// Compare size of input and output
// The word "hash"
// Change cat picture
// Compare outputs

// 

Cryptographic hashes are used all over the place in Bitcoin. Trying to
learn Bitcoin without knowing what cryptographic hashes are, is like
learning chemistry without knowing what an atom is.

You can think of a cryptographic hash as a fingerprint. A person will
produce the same fingerprint of her left thumb every time it is taken,
but it is extremely hard to find another person with the same left
thumb fingerprint. The fingerprint does not disclose any information
about the person other than her left thumb fingerprint. You cannot
know what math skills she has or what eye color she has by looking at
her fingerprint.

A fingerprint of a file is called a cryptographic hash. To create a
cryptographic hash of a file, you send the file into a computer
program called a _cryptographic hash function_. Suppose that you want to
create a cryptographic hash, a fingerprint, of your favorite cat
picture.

[.gbinfo]
.Bits? Bytes? Hex?
****
A _bit_ is the smallest unit in a computer. It can take two different
values, 0 or 1. Like a light bulb, it can be either on or off. A
_byte_ is eight bits, that together can take 256 different values. We
often use _hexadecimal_, or _hex_, encoding when we display numbers in
this book. Each byte is printed as two hex digits each in the range
0-f where a=10 and f=15.

image::{imagedir}/bits-bytes-hex.svg[]
****

.Creating a cryptographic hash of a cat picture. Input is the cat picture and output is a big number of 32 bytes.
image::{imagedir}/hashing-a-cat.svg[{big-width}]

The hash in the picture is a 256 bit number. 256 bits equals 32
bytes. It means that to store the number in a file, the file will be
32 bytes big, which is tiny compared to the size of the 1.21 Megabytes
cat picture.

The word "hash" means something that is chopped into small pieces or
mixed up. It is actually a very good description of what a
cryptographic hash function does. It takes the cat picture and
performs a mathematical calculation on it. Out comes a big number that
does not remotely look like a cat. You cannot "reconstruct" the cat
picture from just the hash, a cryptographic hash function is a
_one-way function_. Let's see what happens when you change the cat
picture just a tiny bit and run that cat picture through the same
cryptographic hash function:

.hashing a modified cat picture. Can you spot the difference? The cryptographic hash function certainly did.
image::{imagedir}/hashing-a-modified-cat.svg[{big-width}]

This hash turns out completely different than the first hash. Let's
compare them:

....
Old hash: dee6a5d375827436ee4b47a930160457901dce84ff0fac58bf79ab0edb479561
New hash: d2ca4f53c825730186db9ea585075f96cd6df1bfd4fb7c687a23b912b2b39bf6
....

See how that tiny change to the cat picture made a huge difference in
the hash value?

==== Why are cryptographic hash functions useful?

Cryptographic hash functions can be used as an integrity check, to
detect changes in data. Suppose that you want to send your favorite
cat picture to your friend Fred via email, but you suspect that the
picture may be accidentally corrupted during transfer. How would you
and Fred make sure that the picture Fred receives is exactly the same
as the one you send?

[.gbfaq]
.What about malicious modifications?
****
You don't care about malicious modifications at this stage, we'll talk
about that later.
****

.Checking file integrity. You calculate the cryptographic hash of the cat picture and send the picture and the hash to Fred. Fred calculates the cryptographic hash of the received file and compares it to the hash provided by you in the email.
image::{imagedir}/email-file-hash.png[{big-width}]

You compose an email to Fred and attach the cat picture to the
email. But you also calculate the cryptographic hash, the digital
fingerprint, of the cat picture. That hash is written down in the body
of the email. The cryptographic hash function is standard software and
available on both your computer and Fred's computer.

When Fred receives this email, he saves the cat picture in a file on
his computer and calculates the hash of that file. If the result is
the same as the hash in the email, Fred knows for sure that the file is
not accidentally corrupted.

==== How does a cryptographic hash function work?

The real answer is very complex, so we will not go there. But to help
you understand the operation of a cryptographic hash function, we will
create a very simplistic cryptographic hash function. Well, it is not
really cryptographic, we will come to that later. Let's just call it a
hash function for now.

.Modulo
****
Modulo means to wrap around when a calculation reaches a certain
value. For example:

 0   mod 256 = 0
 255 mod 256 = 255
 256 mod 256 = 0
 257 mod 256 = 1
 258 mod 256 = 2

`258 mod 256` is the remainder of the integer division `258/256`: `258 =
1*256 + 2`. The remainder is `2`.
****

Suppose that you want to hash a file containing the six bytes `a1 02
12 6b c6 7d`. You want the hash to be a one byte number, 8 bits. We
can construct a hash function using _addition modulo 256_, which means
to wrap around to 0 when the result of an addition reaches 256:

.Simplistic hash function using byte-wise addition modulo 256.
image::{imagedir}/simplistic-hash-algorithm.png[{half-width}]

The result is the decimal number 112. What does 112 say about the
original input `a1 02 12 6b c6 7d`? Not much. 112 looks just as random
as any other single byte number.

If you change the input, the hash will change, even though there is a
chance that the hash will remain 122. After all, there are just 256
different possible outputs of this simple hash function. With real
cryptographic hash functions, as the one we used to hash the cat
picture, the chance is unimaginably small. We will soon get a glimpse
of that probability.

==== Properties of a cryptographic hash function

A cryptographic hash function is a function that takes any digital
input data and produces a fixed-length output. In the example with the
emailed cat picture, the input is the cat picture of 1.21 MB and the
output is a 256 bit number. The function will output the exact same
hash each time the same input is used. But it will output a totally
different value when even the slightest variation of the input is
used. The output of a cryptographic hash function is often referred to
as a _hash_ or a _digest_. I am using term _hash_ here, but either
is equally valid.

.Cryptographic hash functions
****
Some cryptographic hash functions are not considered cryptographically secure any more.
|===
| Name | Bits | OK?

| SHA256 | 256 | Yes
| SHA512 | 512 | Yes
| RIPEMD 160 | 160 | Yes
| SHA-1 | 160 | No
| MD5 | 128 | No
|===
****
Let us have a look at what properties you can expect from a
cryptographic hash function. We will illustrate the properties using
the SHA256 (Secure Hash Algorithm with 256 bit output) algorithm,
because it is the one that Bitcoin uses the most. There are several
different cryptographic hash functions, but they all provide the same
basic properties:

. The same input will always produce the same hash.
. Slightly different inputs will produce very different hashes.
. The hash is always of the same fixed size. For SHA256 it is 256
  bits.
. Trial-and-error is the only known way to find an input that gives a
certain hash.

.A cryptographic hash function, SHA256, in action. The input "Hello!" will give you the same output every time, but the slightly modified input "Hello" will give you a totally different output.
image::{imagedir}/cryptographic_hashing.png[{full-width}]

[.inbitcoin]
.Double SHA256
****
We most often use double SHA256 in Bitcoin:

image::{imagedir}/2ndcol-double-sha256.svg[]
****

The first three properties are illustrated in the diagram above. The
fourth property of cryptographic hash functions is what makes it a
_cryptographic_ hash function and this needs a bit more
elaboration. There are some variations to the fourth property, all of
which are desirable for cryptographic hash functions:

.Different desirable properties for cryptographic hash functions. For collision resistance, X can be anything, as long as the two inputs give the same output X.
image::{imagedir}/hash-properties.svg[{big-width}]

Collision resistance:: It's very hard to find two inputs that give _the same_ hash.
Preimage resistance:: It's very hard to find an input that gives _a certain_ hash.
Second-preimage resistance:: It's very hard to find an input that
gives _the same hash as a certain other input_.

==== Illustration of "very hard"

The term "very hard" in this context means astronomically hard. It is
silly to even try. We will have a look at second-preimage resistance
as an example of what "very hard" means, but a similar example can be
made for any of the three variants.

.Second preimage resistance
****
image::{imagedir}/2ndcol-second-preimage.svg[[]
****

Suppose that you want to find an input to SHA256 that results in the
same hash as `Hello!`:

 334d016f755cd6dc58c53a86e183882f8ec14f52fb05345887c8a5edd42c87b7

There is no way to change the input just a little bit so that the
function "won't notice". It will notice and output a totally different
hash. The only way to find an input, other than `Hello!`, that gives
the hash
`334d016f755cd6dc58c53a86e183882f8ec14f52fb05345887c8a5edd42c87b7` is
to try different inputs one by one and check if it produces the
desired hash.

Let's try.

.Finding an input with the same hash as "Hello!". Nearly impossible.
[options="header,nowrap",cols="1l,3m,3m"]
|===
| Input | Hash | Success?
| `Hello1!` | `82642dd9...2e366e64` | nope 
| `Hello2!` | `493cb8b9...83ba14f8` | nope
| `Hello3!` | `90488e86...64530bae` | nope 
| `...` | `...` | nope, nope, ..., nope
| `Hello9998!` | `cf0bc6de...e6b0caa4` | nope 
| `Hello9999!` | `df82680f...ef9bc235` | nope 
| `Hello10000!` | `466a7662...ce77859c` | nope
| image:{imagedir}/grumpy-cat-drawing.jpg[{thumb}] | `dee6a5d3...db479561` | nope
| My entire music collection | `a5bcb2d9...9c143f7a` | nope
|===

[.gbfaq]
.How big is 2^256^?
****
2^256^ is about 3*10^77^ which is almost the number of atoms in the
universe. To find a preimage to SHA256 is like picking an atom in the
universe and hope it's the correct one.
****

As you can see, we are not very successful. Let us think about how
much time it would take for a typical desktop computer to find such an
input. It can calculate about 60 million hashes per second and the
expected number of tries needed to find a solution is 2^255^. The
result is 2^255^ / (60*10^6^) s ≈ 10^68^ s ≈ 3*10^61^ years, or
about

 30000000000000000000000000000000000000000000000000000000000000 years

I think we can stop trying, don't you? I don't think buying a faster
computer will help either. Even if we had 1 trillion computers and ran
them concurrently it would take about 3*10^49^ years.

Preimage resistance, second-preimage resistance and collision
resistance are extremely important in Bitcoin. Most of its security
relies on these properties.

==== Summary

.Can't figure out input
****
image::{imagedir}/preimage-resistance.svg[]
****

A cryptographic hash function is a computer program that takes any
data as input and computes a big number, a cryptographic hash, based
on that input.

image::{imagedir}/cryptographic_hashing.png[{full-width}]

It is astronomically hard to find an input that will result in a
specific output. This is why we call it a one-way function. You have
to repeatedly guess different inputs.

===== Our toolbox

.Toolbox
****
image::{imagedir}/toolbox-cryptographic-hash-function.svg[]
****

We will discuss several important topics throughout this book. When you
have learned about a specific topic, like cryptographic hash
functions, we will put a new tool into our toolbox for later use.

Our first tool to put into the toolbox is the cryptographic hash function.

.Our first tool. The cryptographic hash function is represented by a paper shredder, and the cryptographic hash is represented by a pile of paper stripes.
image::{imagedir}/tool-cryptographic-hash-function.svg[{half-width}]

From now on we will use the paper shredder to represent a
cryptographic hash function. A pile of paper stripes will represent a
cryptographic hash. The text on the shredder tells what kind of
cryptographic hash function we use. You will learn about a few other
cryptographic hash functions later in the book as we need them.

==== Exercises

===== Warm up

. How many bits is the output of SHA256?
. How many bytes is the output of SHA256?
. What is needed to calculate the cryptographic hash of the text "`hash me`"?
. What is decimal and binary representations of the hexadecimal data `a109`?
. Can you modify the text "`cat`" so that the modified text gets the
same cryptographic hash as "`cat`"?

===== Dig in

****
image:{imagedir}/2ndcol-cat-email-to-fred.svg[]
****

[start=6]
. Does the cat picture transfer example protect against malicious
modifications during transfer? Suppose that someone has access to your
or Fred's email service provider and can tamper with the email while
in transit, could she modify the email in any way so that Fred accepts
a modified file without noticing? If so, how could you and your friend
prevent that?

. Our simplistic hash function from the section <<cryptographic_hashing>>
is not a _cryptographic_ hash function. Which two of the four properties
of a cryptographic hash function is it lacking?
+
image::{imagedir}/simplistic-hash-algorithm-exercise.png[{half-width}]

. The paper shredded in our toolbox is not a perfect analogy. Can you
tell why? What properties of a cryptographic hash function does the
shredder lack? Short on better analogies, we will stick to using the
shredder to denote a cryptographic hash function.

=== Digital signatures

****
image::{imagedir}/2ndcol-physical-vs-digital-signature.svg[]
****

A digital signature is a digital equivalent of a hand written
signature. The difference is that a hand written signature is tied to
a person, while a digital signature is tied to a random number called
a private key. A digital signature is much harder to forge than a hand
written signature.

==== Improving cookie token security

It's time to move back to our cookie token spreadsheet. The company is
doing well and grows rapidly. After a while Lisa has a hard time
recognizing everyone. She notices that some people are not honest. For
example Malory says that she is Anne, to trick Lisa into moving cookie
tokens from Anne to the cafe, instead of from Malory to the cafe.

****
image:{imagedir}/note-to-lisa.svg[]
****

Things are getting out of hand, so Lisa thinks out a great plan. She
is going to require everybody to _digitally sign_ their cookie token
transfers, by writing a message and a _digital signature_ on a piece of
paper or in an email.

Suppose that there is a new guy at the office, John. The company has
given him some CT as a welcome gift when he started. Now John wants to
buy a cookie in the cafe for 10 CT. He needs to digitally sign a
cookie token transfer. This is what he has to do:

.The digital signature process. 1. John creates a keypair and gives the public key to Lisa. 2. John signs a message with the private key. 3. Lisa verifies that the message is signed with the private key belonging to the public key she got from John.
[[generate-key-pair]]
image::{imagedir}/generate-key-pair.svg[{big-width}]

There are three phases in this process.

[.gbinfo]
.Key pair reuse
****
A key pair is created once. The same private key can be used several
times to digitally sign stuff. We will see later why this is not
always a good idea for privacy reasons.
****

. John prepares by generating a key pair. The private key is kept
secret by John, and the public key is handed over to Lisa. This is a
one-time setup step.
. John wants a cookie. He writes a message and signs it with his
private key. He gives the message and the digital signature to Lisa.
. Lisa verifies the signature of the message using Johns public key
and updates the spreadsheet.

==== Preparation: John generates a key pair

The signing and validation process is based on a pair of a private key
and a public key. John needs a private key in order to sign payments
and Lisa will need John's public key in order to verify John's
signatures. John needs to prepare for this by creating a key pair. The
key pair is created by first generating a private key and then
calculate the public key from that private key.

.John creates a key pair. The private key is a huge random number and the public key is derived from that random number. John stores his private key on his hard drive and the public key is handed to Lisa.
image::{imagedir}/create-keypair.png[{big-width}]

.One-way
****
image:{imagedir}/2ndcol-key-derivation-one-way.svg[]
****

John will use a random number generator to generate a huge, 256 bit,
random number. This random number is now John's private key. The
private key is then transformed into a public key using a public key
derivation function. The public key derivation function is a one-way
function, just as the cryptographic hash functions discussed
earlier. You can not derive the private key from the public key. The
security of digital signatures relies heavily on this feature.

How the public key derivation function works is a hard topic covered
in <<ch04,chapter 4>>. Luckily, you do not have to be a cryptography expert to
understand how digital signatures works from a user's perspective.

The private and public keys are thought of as a pair because they have
a very strong relationship; The public key can be used to encrypt
messages that only the private key can decrypt. It also works the
other way around, the private key can encrypt messages that can only
be decrypted by the public key.

[id=enc-dec-public-private]
.Encrypting and decrypting with the public and private keys. Left: Encrypt with the public key and decrypt with the private key. Right: Encrypt with the private key and decrypt with the public key.
image::{imagedir}/enc-dec-public-private.svg[{half-width}]

[.gbinfo]
****
We will use the right side to make digital signatures. We will not use
the left side at all in this book.
****

Encryption is used to make messages unreadable to parties that don't
hold the proper decryption keys. In the left example, only John would
be able to read the encrypted message because he is the only one with
access to his private key. In the right side example, Lisa can decrypt
the message because she has the public key belonging to Johns
private key. This is used to make digital signatures. It is not good
practice to use the private key to encrypt messages, like in the right
side of the diagram, because the public key is, well, public. When
john hands his public key to Lisa, someone might overhear the
conversation, or Lisa might leave her table with public keys open on
her computer screen. And that's okay. The public key is not
secret. That is why it is a bad idea to encrypt with the private key
and expect the message to be secret. We will not talk much more about
the left side in this book, because the Cookie Token system or Bitcoin
doesn't use it. But the next section will shed a little more light on
the properties of the key pair.

===== Locked box example

To illustrate the relationship between the private and the public
keys, imagine a box with a lock. The lock has three states: Left
(locked), Up (unlocked), and Right (locked).

image::{imagedir}/locked-box-overview.svg[{half-width}]

There are two keys to this lock, one key can only turn the lock to the
right, clockwise, and the other key can only turn the lock to the
left, counterclockwise.

Let's assume that John selects the right-only key to be his
private key. The left-only key is then his public key. He could chose
either one of them to be the private key, it does not matter. He makes
several copies of the public key and hands them out to Lisa, Ellen and
a bunch of other people. He keeps the private key to himself in his
pocket.

====== Encrypt and decrypt

Ellen can now encrypt a secret message to John. She writes a note with
the secret message

 Hey, your zipper is down

.Encrypt/decrypt
****
.Ellen encrypts with public key
image::{imagedir}/locked-box-locked-left.svg[]
.John decrypts with private key
image::{imagedir}/locked-box-unlocked-private.svg[]
****

and puts it in the box, closes the box and locks it with her copy of
the public key. The public key only turns to the left, so when she is
done the lock is in its leftmost position. The box is now locked. To
open the box you need a key that can turn the lock to the right. Only
John's private key can do that. None of the copies of the public key
will help, because they can only turn to the left.

John, who is the only one with the private key, can now use his
private key, that only turns right, to unlock the box and read the
secret message. He is confident that the message has not been read by
anyone else during its time in the box, because he has had his private
key in his pocket all the time. He gently turns around and zips up.

We have just witnessed the left side process of
<<enc-dec-public-private>>:

.Ellen encrypts a message that only John can read.
image::{imagedir}/encrypt-decrypt.svg[{half-width}]

====== Sign and verify

The above was an illustration of the encryption feature of public and
private keys. But while John was able to read the secret message from
Ellen, he could not tell _who_ wrote the message. Anyone with a copy
of the public key could have done that.

But this box has another great feature. It can be used by John to
write a message that anyone with the public key can read and be
absolutely sure that it was John who wrote the message. This is an
example of a digital signature.

.Sign/verify
****
.Signed by John
image::{imagedir}/locked-box-locked-right.svg[]
.Verified by Ellen
image::{imagedir}/locked-box-unlocked-public.svg[]
****

Say that John wants to send the message

 Lisa, please move 10CT to Cafe. /John

to Lisa. John gave Lisa his public key, that only turns left, in the
previous section, so Lisa knows that this public key belongs to Johns
private key. John writes the message on a note and puts it in the
box. He closes the box and locks it with his private key, that only
turns right. When he is done, the box is locked in the rightmost
position. Everyone knows how this box works, so everyone is aware that
only the private key can lock the box in this way, because only the
private key can turn the lock to the right.

Lisa can now use her copy of the public key to unlock the box by
turning it left one step to the upright, unlocked, position. She takes
out the note and reads it. She knows for sure that John put this
message in the box, because he is the only person with the
private key. Lisa can now trust that the message is from John and move
10 cookie tokens from him to the cafe.

The signing process use the right side of the diagram in
<<enc-dec-public-private>>:

.John signs with his private key and Lisa verifies with Johns public key. She now knows for sure that John wrote this message.
image::{imagedir}/sign-verify.svg[{half-width}]

==== John signs his payment

Let's have a close look at how the signing really happens.

.John digitally signs the transfer of 10 CT to the cafe. The message to Lisa is first hashed and then encrypted with John's private key. The note to Lisa contains both the message in clear text and the signature.
image::{imagedir}/signing-details.svg[{big-width}]

[.inbitcoin]
.Signatures in Bitcoin
****
Bitcoin use this type of signature for most Bitcoin payments
today. But it is not the only way to authenticate a payment.
****

The message that John wants to sign is "Lisa, please move 10CT to
Cafe. /John". The signing function will hash this message with SHA256
whose output is a 256 bit number. This hash value is then encrypted
with John's private key. The result is a string that looks like
garbage:

 INxAs7oFDr80ywy4bt5uYPIv/09fJMW+04U3sJUfgV39
 A2k8BKzoFRHBXm8AJeQwnroNb7qagg9QMj7Vp2wcl+c=

This is the signature. If John would have used another private key or
a slightly different message as input, the signature would have looked
completely different. For example, using the input message "Lisa,
please move 10CT to Malory. /John" would generate this signature:

[.gbminiex]
.Why different?
****
//REF
Can you tell why the signature looks completely different. Use the
figure above.
****

 IBkECIzYrfw6pEEdAUbDpD32rq481j6h5a7UrEYG6BBz
 dmZmsFAtT+cvXTZbpwC76/gMES9DCcS5ArjhCDjwbq8= 

This is not even remotely similar to the previous signature. This is
good to know for John, as he knows that his signature cannot be used
for other messages than his intended message. We will talk more on
that in the next section where Lisa verifies the signature.

****
image::{imagedir}/note-to-lisa.svg[]
****

The last thing that John does is to compose a note to Lisa and give it
to her.

==== Lisa verifies the signature

Lisa does not recognize John. She looks at the note and sees that the
note claims to be from John, so she looks up John in her table of
public keys.

.Lisa uses the message (1), the signature (2) and John's public key (3) to verify that the message is actually signed with John's private key.
image::{imagedir}/verify-signature.svg[{big-width}]

The purpose of Lisa's actions in this picture is to determine that the
cookie token transfer was signed by the private key it claims to be
signed with. The message _says_ it is from John. She did receive Johns
public key the other day and she put the public key in her table of
public keys. The things she has at hand is

. The message "Lisa, please move 10CT to Cafe. /John"
. The Signature `INxAs7oFDr8...`
. Johns public key that she just looked up in her table

.A signature is an encrypted hash
****
image::{imagedir}/2ndcol-encrypted-hash.svg[]
****

John encrypted the hash of the message with his _private_ key. This
encrypted hash is the signature. So if Lisa decrypts the signature (2)
with John's _public_ key (3), the result should be the same hash.

Lisa takes the signature (2) and decrypts it with the public key (3)
she looked up in her table of public keys. The decryption outputs a
big number. If this number is equal to the hash of the message (1), it
proves that John's private key was used to sign the message. Lisa
takes the message (1), exactly as written, and hashes that message
just like John did when he created the signature. This message hash is
then compared with the decrypted signature. The message hash and the
decrypted signature match.

Lisa can now be sure that no one is trying to fool her. She updates
the spreadsheet with John's transfer:

.Lisa have added a row for John's cookie token transfer after verifying the signature of John's message.
image::{imagedir}/cookie-sheet-basic-johns-transfer.svg[{half-width}]

==== Summary

Lisa has solved the problem with people claiming to be someone else
when they make a payment. She requires all payers to digitally sign
the cookie token transfers. Every user of the spreadsheet needs to
have a private key and a public key. Lisa keeps track of which public
key belongs to whom. A payment must from now on be written on a piece
of paper or in an email to Lisa, and the message must be digitally
signed with the person's private key. Lisa can then verify the
signature to make sure she is not being fooled.

image::{imagedir}/digital-signature-summary.png[{big-width}]

The gist of this is that as long as John keeps his private key to
himself, no one will be able to spend his money.

It's time to release version 2.0 of the cookie tokens.

[%autowidth,options="header"]
.Release notes, cookie tokens 2.0
|===
|Version|Feature|How

|image:{commonimagedir}/new.png[role="gbnew"]*2.0*
|Secure payments
|Digital signatures solves the problem with the imposter

|1.0
|Simple payment system
|Relies on Lisa being very trustworthy and knowing everyone's face
|===

Everybody still trust Lisa to not change the spreadsheet in any way
except when executing signed cookie token transfers. If Lisa wanted to
she could steal anyone's cookie tokens by just adding a transfer to the
spreadsheet. But she wouldn't do that, or would she?

===== New tools in our toolbox

.Toolbox
****
image::{imagedir}/toolbox-signatures.svg[]
****

We have three new tools that we will put in our toolbox for
later use: Key pair generation, digital signing, the signature and the verification.

.The tools used for signing and verification.
image::{imagedir}/tool-signing.svg[{half-width}]

The second and third tools to add are digital signing and verification.

==== Exercises

===== Warm up

. How is the private key of a key-pair created?
. What key is used to sign a message?
. The signing process hashes the message to sign. Why?
. If John didn't end his message with "/John", would Lisa be able to
determine who to withdraw money from?  
. What would Malory need in order to steal cookie tokens from John?

===== Dig in

. Recall the example when you wanted to send your favorite cat
picture to Fred. Now that you know about digital signatures, how can
you ensure that the cat picture is not maliciously modified without
using a second channel like text messages? Assume you already created
a key pair and that you have give the public key to Fred.
+
image::{imagedir}/email-file-hash.png[{half-width}]
+
. Are the names in the spreadsheet really needed anymore? Could they
be replaced by something else? If that is possible, suggest how a
typical payment can look?

=== Private key security

John is in control of his cookie tokens because he owns the
private key. No one but John can use John's cookie tokens because he is
the only one with access to his private key. If his private key is
stolen, he can lose any and all of his cookie tokens.

One morning when John came to the office, he took his laptop from his
desk and went straight to the cafe to buy his two morning cookies. He
opened his laptop to write a message to Lisa.

 Good morning Lisa! please move 20 CT to Cafe. /John
 Signature:
 H1CdE34cRuJDsHo5VnpvKqllC5JrMJ1jWcUjL2VjPbsj
 X6pi/up07q/gWxStb1biGU2fjcKpT4DIxlNd2da9x0o=

He sent an email with the message and a signature to Lisa, as
usual. But the cafe didn't hand him any cookies. The guy behind the
desk said that he hasn't seen any incoming payment of 20 CT yet. Lisa
is usually very quick in verifying and executing transfers.

John opens the spreadsheet and searches for "John". This is what he sees:

.Someone stole money from John. Who is Melissa and how was this possible? John did not sign any such transfer.
image::{imagedir}/cookie-sheet-john-pwned.png[{half-width}]

John steps into Lisa's office asking for an explanation. She answers
him that she got a message signed with Johns private key asking her to
send money to this new coworker, Melissa. She even shows him the
message and signature. Of course there is no Melissa at the office,
which has grown rapidly lately. Lisa don't care about names anymore,
only public keys and signatures.

The explanation to all this is that someone has

. managed to copy Johns private key. John's laptop has been on his
  desk all night long. Anyone could have taken out the hard drive from
  the laptop to search for his private key.
. created a new key pair and sent the new public key to Lisa:

 Hi Lisa. My name is Melissa, and I'm new here.
 My public key is
 02c5d2dd24ad71f89bfd99b9c2132f796fa746596a06f5a33c53c9d762e37d9008

. sent a signed message to Lisa

 Hi Lisa, please move 90 CT to Melissa. Thanks, John
 Signature:
 IPSq8z0IyCVZNZNMIgrOz5CNRRtRO+A8Tc3j9og4pWbA
 H/zT22dQEhSaFSwOXNp0lOyE34d1+4e30R86qzEbJIw=

Lisa validated the transfer in step 3 and concluded that it is valid
and executed the transfer. John asks Lisa to revert the, according to
him, fraudulent transfer. But Lisa refuses to do that. She thinks the
transfer is perfectly valid. If John let someone see his private key,
that's his problem, not Lisa's. That's part of why she's so trusted
within the company, she keeps her promises.

John creates a new key pair and ask Lisa to add his new public key
under the name John2.

How can John secure his new private key and still have it readily
available when he wants a cookie? John is pretty sure that he will not
have more than 1000 cookie tokens on that key.

[.gbinfo]
.You are responsible
****
You have the full responsibility for the security of your private keys.
****

The security of the spreadsheet has shifted from a system where Lisa
knows everyone's face to one where Lisa knows everyone's
public key. In a sense, the security could actually be worse now,
because it might be easier for Malory to steal John's private key than
it is for her to trick Lisa into thinking Malory is John. That depends
on how John protects his private key. An important thing to note is
that the security of John's private key is totally up to him. No one
is going to be able to restore John's private key if he loses it. And
Lisa sure is not going to reverse "fraudulent" transfers just because
John is sloppy with security. If he stores it in clear text in a
shared folder on the company's intranet, anyone can easily copy his
private key and use that to steal Johns cookie tokens. But if John
stores the private key in an encrypted file, protected by a strong
password, on his own laptop's hard drive, it's a lot harder to get a
copy of his key, because you must

. get access to Johns hard drive
. know John's password

If John thinks that he will never have more than 50 CT on his private
key, he might not be very concerned with security. But the cafe who
manages about 10000 cookie tokens might be very concerned. John and
the cafe probably need different strategies for storing their private
keys.

There is a trade-off between security and convenience. You can for
example keep your private key encrypted on an off-line laptop in a
bank safe-deposit box. When you want to buy a cookie you need to go to
the bank, take out the laptop from your safe-deposit box, decrypt the
private key with your password, and use the private key to digitally
sign a message to Lisa. Write down the message and signature on a
note, put back the laptop into the safe-deposit box and bring the note
back to the office. Very secure, and very inconvenient.

On the other hand, you can store your private key in clear text on
your mobile phone. Then you have the key at your fingertips and can
sign a message within seconds from when the urge for a cookie starts
to nudge you. Very insecure and very convenient.

Some of the different trade-offs are

.Security considerations against attackers. Note how the more secure options are also more inconvenient.
image::{imagedir}/private-key-security.png[{half-width}]

Online vs offline:: On-line means that the private key is stored on a
device with network access, like your mobile phone or general purpose
laptop. Off-line means that the private key is stored on a piece of
paper, or a computer without any network access. On-line storage is
risky because remote security exploits or malicious software on your
computer, like computer viruses, may send the private key to someone
without you noticing. If the device is off-line, no one can take the
private key without physical access to the device.

Clear text vs encrypted:: If the private key is stored in clear text
in a file on the hard drive of your computer, anyone with access to
your computer, either remotely over a computer network, or physically,
can make a copy of the private key. That includes any viruses that
your computer may be victim to. You can avoid many of these attacks by
encrypting your private key with a password that only you know. Any
attacker would then need both read access to your hard-drive and your
secret password to copy the key.

Whole key vs Splitted key:: Usually people store their entire private
key on a single computer. That's convenient, you only need one
computer to spend your cookie tokens. An attacker need to get access
to your hard drive in order to steal the private key. But if your
private key is splitted into three parts, and you store the three
parts separately on three different computers, then the attacker must
get access to the hard drives of three computers. That's much harder
because she must know what three computers to attack and also
successfully attack them. Making a payment in this setup is a real
hassle, but very secure.

Any combination of the above methods can be used to store your
keys. But as a rule of thumb, the higher the security against
attackers, the higher the risk of you accidentally losing access to
your key. For example, if you store the private key encrypted on your
hard drive, you risk losing your key due to both computer failure and
forgetting your password. So in this sense, the more secure you store
your keys, the less secure it is.

=== Recap

In this chapter you learned that

* You can use cryptographic hash functions to detect changes in a file
  or in a message.
* You can't make up a preimage of a cryptographic hash. A preimage is
  an input that has a certain known output.
* Digital signatures are useful to prove the authenticity of a
  payment. Only the rightful owner of bitcoins may spend them.
* A verifier of a digital signature does not have to know _who_ made
  the signature. She just have to know that the signature was made
  with the private key the signature claims to be signed with.
* To receive bitcoins or cookie tokens, you need a private key, that
  you create yourself in private. You derive the public key from the
  private key.
* There are several strategies to store private keys ranging from
  unencrypted on your mobile phone to splitted and encrypted across
  several safe deposit boxes.
* General rule of thumb: The more secure against theft, the easier to
  accidentally lose the keys.
