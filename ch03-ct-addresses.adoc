[id=ch03]
== CT addresses - Resolving privacy issues
:imagedir: {baseimagedir}/ch03

This chapter covers

* Basic privacy
* Replacing names with public keys
* Replacing public keys with hashes
* Encoding hashes into CT addresses

After this chapter, the spreadsheet will have gotten rid of personal
names and replaced them with hashes of public keys. This is useful
from a privacy perspective. No one can easily see who's
paying who. This makes it harder for others to extract information
from the spreadsheet on how much cookies a certain coworker eats. Lisa
also finds this very useful, because she don't have to maintain a
table of names and public keys.

Coworkers also invent cookie token addresses which protects them from
losing money due to typing errors. Cookie token address are shorter to
write than public key hashes

=== Cookie eating habits undisclosed

.Acme Insurances
****
A highly unethical insurance company that will make serious attempts
at spying on you and your family habits in order to "adjust" your
premium.
****

Alice and many other coworkers have a health insurance at Acme
Insurances. Acme have "persuaded" John to hand over a copy of the
spreadsheet to them. Acme figure that they can adjust premiums or hold
workers' cookie eating habits against them in an eventual insurance
dispute.

.Acme Insurances keeps an eye on Chloe's cookie eating habits.
image::{imagedir}/privacy-issues-names.svg[{half-width}]

Another disturbing fact with the spreadsheet is that every coworker
can easily look up other coworkers' balances, as well as cookie eating
habits.

The coworkers have asked Lisa to come up with a solution to these
problems. Otherwise they will stop using the spreadsheet.

=== Replace names with public keys

****
image:{imagedir}/lisa-pukes.svg[]
****

Lisa has kept the table of names and public keys updated at all times
since they started using the spreadsheet. She is sick of it, so she
comes up with an idea that will benefit both Lisa and all coworkers.

Lisa will replace all names in the spreadsheet with their respective
public keys.

.Replacing the names with public keys. The spreadsheet is now much more unreadable, which is good from a privacy perspective.
image::{imagedir}/replace-names-with-public-keys.svg[{big-width}]

It is now hard to see how many cookies Chloe has eaten without knowing
her public key. If this new spreadsheet is given to Acme Insurances
they will be able to see what payments the different public keys have
made. They will see both sender public key and recipient public key of
each payment.

Lisa can now delete her cumbersome table of names and pubic keys. But
when she does that, users can no longer use names when they make
payments. They must instead use the public key of the sender and
the public key of the recipient.

.Old style
****
image::{imagedir}/pay-to-name-note.svg[]
****

.New style payment using public keys instead of names.
image::{imagedir}/payment-with-pubkey.svg[{half-width}]

The note to lisa contains a few vital parts

* a message containing
** amount
** sender public key
** recipient public key
* signature made with the senders private key

The essential difference is that the payment is pseudonymous; Names
are replaced with the corresponding public keys. Otherwise the payment
looks the same as before.

==== New payment process

Suppose that a new coworker just started at the company. Her name is
Faiza. The company wants to send her 100 CT as a welcome gift. How
can the company send 100 CT to Faiza?

The company needs a public key to send the 100 CT to. Since Faiza
haven't used cookie tokens yet, she needs to create a public key and
give it to the company.

.Faiza creates her public key and gives it to the company. The company creates a payment with Faiza's public key as the recipient.
image::{imagedir}/payment-process-pubkey.svg[{big-width}]

Faiza creates a private and a public key. This is done in exactly the
same way as in <<_improving_cookie_token_security,chapter 2>>, but the
public key is not handed over to Lisa. Now that Lisa don't have the
table of names and public keys, there's no point in giving the public
key to Lisa any more. She don't need it. Instead, Faize hands the
public key to the one who wants to pay her cookie tokens, the company.

The company creates a message that asks Lisa to move 100 CT from `037e944a...36de9496` to `029a726c...ad8f436d`.

The company digitally signs the message and gives it to Lisa. Lisa uses

* the message
* the sender's public key
* the signature

[.inbitcoin]
.In Bitcoin
****
Lisa is performing the duties that the Bitcoin network is doing with Bitcoin payments.
****

to verify that the message is signed with the private key belonging to
the sender's public key. She also verifies that the sender's public
key has enough funds in the spreadsheet. This is done exactly as when
the spreadsheet contained names; She searches for the sender's public
key and calculates the balance.

Lisa has never seen the recipient's public key before, but she doesn't
care. She only cares that the sender has the money to spend and that
the message is correctly signed. She will just write into the
spreadsheet's recipient column whatever the message asks her to write.

****
image::{imagedir}/faizas-new-ct.svg[]
****

Faiza sees the new row with her public key in the "To" column. It
gives her a warn and fuzzy feeling. She can now spend them as she
pleases. Faiza did not have to bother Lisa with her public key. This
saves Lisa a lot of work.

Let's summarize what we have done so far:

[.gbminiex]
.What can Acme do?
****
Please take a moment to think about what Acme Insurances can
figure out from the spreadsheet now. What information can they get if they figure out the sender or recipien of _one_ single payment.
****

* We have replaced names with public keys in the spreadsheet.
* Lisa has thrown away the table of names and public keys.
* The payment is made with public keys as sender and recipient instead of names.

These actions have improved privacy as well as simplified Lisa's
work. At the end of this chapter we will discuss more about how to
further improve privacy.

=== Harden the security of the private key

We rely on digital signatures to secure our cookie tokens. With all
public keys in the spreadsheet, imagine what could happen if a
weakness in the cryptoghraphy system is discovered that makes it
possible to reverse the public key derivation function. This would
mean that you can calculate the private key from the public key.

.Reversing the public key derivation function. You would be able to determine the private key from the public key.
image::{imagedir}/reverse-pubkey-derivation.svg[{half-width}]

This would make the system highly insecure, as anyone could now take
anyone else's money.

In reality, if a weakness is discovered, it doesn't neccesarily mean
that one can easily figure out the private key from a public key. It
more likely will just make it less hard to guess the private key by
some order of magnitude. For example it would require trial-and-error
with on average 2^127^ guesses instead of 2^255^. That is a very
serious weakaning of the private key security, but it would still be
very hard to find a private key by doing 2^127^ trials, but it might
not be totally infeasible.

==== Hash public key to 20 bytes

There are some really security oriented people at the company. They
have figured out a way to protect us from the above catastrophic
scenario. They suggest that we replace each public key in the cookie
token spreadsheet with a cryptographic hash of the public key. Not
from a single cryptographic hash function, but from two different
cryptographic hash functions:

.Replace the public keys with the RIPEMD160 hash of the SHA256 hash of the public key.
image::{imagedir}/hash-public-key.svg[{big-width}]

The public key is first hashed with SHA256, as we are familiar with
from the previous chapter. The result of that cryptographic hash
function is then hashed with RIPEMD160, a cryptographic hash function
that outputs a 160 bit (20 byte) number. We call this final hash the
_public key hash_.

All public keys in the spreadsheet are replaced by their respective
public key hashes.

image::{imagedir}/replace-public-keys-with-hashes.svg[{half-width}]

.Old style payment
****
image::{imagedir}/pay-to-pubkey-note.svg[]
****

The payment process now differs a bit from when Faiza received her 100
CT from the company. Suppose that John wants to buy a cookie.

.John buys a cookie. The sender is still a public key, but the recipient is a public key hash instead of a public key. Lisa needs to create the public key hash from the public key in order to verify the balance and execute the payment.
image::{imagedir}/payment-with-pubkey-hash.svg[{big-width}]

First, the message to Lisa is changed a little bit. John must put the
café's public key _hash_ as the recipient. The sender is still a
public key. Can you tell why John needs to provide his public key, and
not his public key hash, as the sender in the message?

Second, Lisa must create the public key hash from the sender's public
key in order to check the sender's balance.

.Pre-image resistance
****
image::{imagedir}/pre-image-resistance.svg[]
****

How are public key hashes protecting us from the catastrophic scenario
where the private key is not secure any more? I will explain in the
next paragraph, but I think you might be able to answer this
yourself. Use the hint in the margin. If not, don't worry, please read
ahead.

An attacker wanting to steal money from the café would need to reverse
three very different one-way functions. She would need to

1. pre-image attack RIPEMD160, this means reverse it.
2. pre-image attack SHA256
3. reverse the public key derivation function

To do this she would need to find major weaknesses in all three of
these technologies, which is highly unlikely. Just the probability of
the catastrophic scenario that started this idea is tiny. The
probability that all three of these technologies are weak is
exponentially tinier. Let's just say we're safe, shall we?

[.gbfaq]
.Have privacy improved?
****
No.
****

Now that we've stengthened the security of our cookie token
spreadsheet, let's think about privacy again. Has this improved
privacy? Is it harder for Acme Insurances to figure out information
about who's paying who now compared to when we used public keys in the
spreadsheet? The answer is no. There is a 1-to-1 correspondance
between the public keys and the public key hashes. Using public key
hashes does not hide personal information more than using plain public
keys.

[.inbitcoin]
.P2PKH
****
Most payments in Bitcoin are made with a public key has as the
recipient. But there are other types of payments as well.
****

The choice of RIPEMD160 as the last cryptographic hash function is not
just a random choice by the security consious coworkers. They
deliberatly chose one that would output slightly shorter values,
because they will be easier to write and take less space in the
spreadsheet while still providing enough security. Compare the output
from SHA256 with the output from RIPEMD160:

 SHA256:
 85ae273f0aa730eddf2285d3f3ab071eb29caba1e428db90e6dfbd71b8e1e918
 RIPEMD160:
 5f2613791b36f667fdb8e95608b55e3df4c5f9eb

It's a trade-off between security and convenience, as is very often
the case. From now on we will denote the public key hash as PKH.

=== Avoiding expensive typing errors

When Lisa verifies a payment before executing it, she doesn't care who
the recipient is or if it's even an existing recipient. She will just
put into the recipient column of the spreadsheet whatever the payer
asks her to. She cannot even know if a recipient is valid or not
because she no longer knows everyone's public keys.

This is convenient for Lisa, but it can cause people to lose money if
they are not very careful. Imagine once again that John wants to buy a
cookie. This time he's not careful enough when writing the message.

.John makes a typo on the recipient in the note to Lisa. What now?
image::{imagedir}/payment-to-bad-pubkey-hash.svg[{big-width}]

He makes a typing error on the recipient public key hash. The last
character is `d` when it should have been a `c`. What happens now?

[.gbinfo]
.Any recipient goes
****
There is no "wrong" recipient PKH. Lisa adds any recipient as long as
the signature is valid. She could validate that the length of the PKH
is 20 bytes if she wants to, but it depends on her mood. Don't rely
on it.
****

John doesn't notice the error and happily signs the message and send
the note to Lisa. Lisa verifies the signature, which verifies fine,
and calculates the public key hash of the sender. She doesn't care
about the recipient. She inserts a new row in the spreadsheet paying
from `5f2613791b36f667fdb8e95608b55e3df4c5f9eb` to
`87e3d1692022a7744bf2406a963c656c8393b1cd`.

Then she consideres herself done, moving on to other interesting
tasks. The café owner who is searching for his public key hash
in the spreadsheet will not see any incoming payment. John
stands at the counter in the café yelling at the café owner that he
DID send money, now GIVE ME THE FREAKIN' COOKIE. The café owner
refuses. John takes a close look at the spreadsheet and searches for
his public key hash. He find the one he just made and now realizes his
spelling mistake.

****
image:{imagedir}/pkh-pre-image-resistance.svg[]
****

John has sent money to a "public key hash" for which there is no known
private key. No one is ever going to be able to spend those 10 CT, not
the café, not John, nobody. John has just digitally burned 10 CT.

Unfortunately, this will probably happen again and again in the future
if nothing is done to prevent it. The problem can happen anywhere from
when the cafe owner reads his own public key hash to give to John, to
when John writes his message before signing it. You could argue that
Lisa could also make this mistake when she updates the spreadsheet,
but she's so thourough that it will _never_ happen. She's just too
good at what she's doing for that to happen. Lisa will never cause
someone else's funds to be burned.

The security oriented people discuss this problem and comes up with an
idea of Cookie Token Addresses. A cookie token address is a public key
hash endcoded in a certain way so that typing errors will be detected
if they occur. At the same time they will make the recipient even
shorter to write for the user.

==== Base58check

Suppose that Faiza feels sorry for John and wants make use of her 100
CT by giving John 20 CT, 10 CT to recover his funds, plus 10 CT extra
to make poor John stop crying.

[.inbitcoin]
.Bitcoin addresses
****
Cookie token addresses are exactly as the most common verion of
Bitcoin addresses. There are however other types of Bitcoin addresses.
****

She doesn't want to make the same mistake as John did, so she asks
John for his cookie token address. John creates it by endoding his
public key hash with a function called _base58check_:

.Overview of the base58check encoding which transforms a public key hash into a cookie token address
image::{imagedir}/base58check-encoding-simple.svg[{quart-width}]

The result is John's cookie token address
`19g6oo8foQF5jfqK9gH2bLkFNwgCenRBPD`. John hands this address to Faiza
who then makes a payment as follows:

.Faiza makes a payment to John's cookie token address. She decodes the address into a public key hash, while verifying that the address is not misspelled.
image::{imagedir}/payment-with-address.svg[{half-width}]

[.gbfaq]
.Who uses CT addresses?
****
Cookie token addresses are only used by users to safely transmit PKH
between each other. Lisa never handles them.
****

The payment process is changed for the payer, but nothing is changed
for Lisa. Faiza will base58check _decode_ John's address into a public
key hash. The decoding will make sure that there were no typing errors
made in the address. How that is done will be covered in the next few
diagrams. The note to Lisa is exactly the same as before. The cookie
token address is only used by users. It's not part of Lisa's
validation process or the spreadsheet in any way.

===== Base58check encoding

****
image::{imagedir}/base58check-encode-decode-1.svg[]
****

Let's see how this mysterious base58check encoding and decoding is working.

.Base58check encoding John's public key hash. A version is added to the hash, and then a checksum is created and appended to the versioned hash. Last, the checksummed, versioned hash is base58 encoded.
image::{imagedir}/address-encoding.svg[{big-width}]

The first thing that happens is that a version is added before the
public key hash. The group of people who came up with the idea of
cookie token addresses wanted to make future upgrades to the address
format easy. Right now there is just one version of cookie token
addresses. That version is a single 0 byte.

.Checksum
****
image::{imagedir}/checksum.svg[]
****

To detect typing errors, a checksum is added. A checksum is calculated
from versioned public key hash. To create a checksum, base58check
hashes the versioned public key hash with double SHA256. This means
that it is first hashed with SHA256 and the resulting hash is hashed
again with SHA256. We take the first four bytes of the second hash and
let those four bytes be our checksum. This checksum is then appended
to the versioned public key hash. We will see soon how this checksum
protects us from typing errors. Stay patient!

We started with a public key hash of 20 byte (40 hex characters). But
now that we have added a version and a checksum, we have 25 bytes (50
hex characters). To make up for this increase, we will encode the 25
bytes in a more compact way than hexadecimal encoding.

===== Use a compact encoding

Hex encoding is a very inefficient way to represent bytes of data. It
requires two characters for each byte. We only use 16 differect
characters, where each character represent 4 bits, 0000 to 1111.

What if we could use more different characters to represent
data. There are plenty of such encoding schemes. The most widely known
is base64. In Base64 each character represent 6 bits of data, but to
do that we would need characters besides just letters and
digits. Base64 uses the following alphabet:

 ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/

The character `A` represent the bits `000000` and the character `/`
represents `111111`. This is a very nice, easy and compact way to
represent data with human readable characters. You have already seen
base64 encoded data several times in this book, but I was too lazy to
explain what it was. Can you say where?

But base64 doesn't quite fit the bill for cookie token addresses. We
need an encoding that minimizes the risk of making typing errors, not
just detects them when they happen. Notice how some characters look
very similar in some fonts, lI (minor L, capital I), 0O (zero and
capital Oh). We also need a format that can be easily copy-and-pasted
by users, meaning that special characters, like `+` and `/` should not
be allowed because they will prevent you from marking the whole data
by double-clicking it. If we remove those 6 charachters we reduce the
possibility of typing errors. But now we only have 58 characters left,
so we need another type of encoding.

.Base58 encoding and decoding
****
image::{imagedir}/base58-encode-decode.svg[]
****

They came up with a new way to encode data. It's called base58 because
the alphabet is the 58 characters

 123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz

If you feel put off by this low level base58 mumbo jumbo, you can skip
to <<base58check-decoding>> and just accept that base58 is a way to encode and
decode data. For the rest of you, please continue. It's fun.

In base64, each character represents exactly 6 bits which makes it
straight forward to encode and decode data. But with base58 each
character represents slightly less than 6 bits, but more than 5
bits. We need to encode data differently.

Let's get back to our example where John creates his address. He has
just added a version and a checksum. Now it's time to encode the 25
bytes into an address.

.Encoding John's versioned and checksummed public key hash with base58. The essential part is where you divide the number by 58 and keep the remainders. The remainders are then mapped one by one in the lookup table.
image::{imagedir}/base58.svg[{big-width}]

[.inbitcoin]
.Addresses start with `1`
****
All Bitcoin addresses of version 0 start with a `1`. This is because
the version byte is `0` which is encoded by the character `1`.
****

The overall strategy of base58 is to treat the data as a huge number
that we divide by 58 over and over until the quotient is 0 and keep
the remainders of every division. Each remainder is looked up in the
lookup table and a `1` is appended last for each leading zero byte in
the input. The string is finally reversed and the result is John's
cookie token address. We can note that all cookie token addresses, not
just John's will start with a `1`. Can you figure out why? If not,
check the margin.

Base58 encoded data like John's address can be decoded back to the
original input of the base58 encoding. I will leave that as en
excersise for the interested reader.

[id=base58check-decoding]
==== Base58check decoding

****
image::{imagedir}/base58check-encode-decode-2.svg[]
****

John has just created his cookie token address by base58check encoding
his public key hash. He has given it to Faiza so that she can cheer
him up with 20 CT. Now Faiza needs to write a message to Lisa. In
order to do that she needs Johns public key hash. The great thing
about base58check encoding is that the process can be reversed so that
you can get the public key hash from the address while at the same
time checking for typing errors.

.Base58chack decoding is basically done by reversing the base58check encoding. Typing errors are detected when the checksums don't match.
image::{imagedir}/address-decoding.svg[{big-width}]

[.gbfaq]
.How safe is the checksum
****
The checksum is 4 bytes, which corresponds to 2^32^≈4.3 billion
values. The chance is 1 in 4.3 billion that base58check fails to
detect a typing error. It's pretty safe.
****

Faiza takes John's cookie token address and base58 decodes it. The
checksum is removed and the remaining part, the versioned public key
hash, is used to calculate the checksum again. The newly calculated
checksum and the just removed checksum must match. Otherwise some
typing error has occurred. If a typing error has occurred, Faiza would
not create the message. She would verify that she entered the address
correctly and that John gave her the correct address. Somewhere along
the way, the address got corrupted.

=== Summary of the address creation process

Let's put the pieces together and have a look at the whole process
again.

****
image::{imagedir}/address-creation-abstract.svg[]
****

.John creates his cookie token address. He creates a key pair and his public key is hashed into a public key hash. His public key hash is base58check encoded into a cookie token address.
image::{imagedir}/address-creation-summary.svg[{big-width}]

.Release notes
****
*Cookie Tokens 2.1*

|===
| Feature | Technology

| *safe from typing errors* | *CT addresses*
| *privacy improvements* | *PKH in spreadsheet*
| Secure payments | Digital signatures
|===
****

Faiza makes sure no typing errors happens by base58check decoding
the address before signing the message.

.Faiza makes the payment to John and makes sure the address is valid
image::{imagedir}/payment-with-address.svg[{half-width}]

.Toolbox
****
image::{imagedir}/toolbox.svg[]
****

Thanks to PKH and cookie token addresses

* Lisa can ditch her public key table.
* anyone can create an address without asking Lisa or anyone else.
* anyone can create multiple addresses.

We add PKH and addresses to our toolbox for later use.

=== Back to privacy

While privacy has improved, the spreadsheet still reveals some
information that Acme Insurances finds useful.

[.inbitcoin]
.Forensics
****
This technique is often used in Bitcoin during crime investigations
for example.
****

For example, they could probably figure out that the café has the
public key hash `87e3d1692022a7744bf2406a963c656c8393b1cc` because
there are a lot of 10CT payment to that public key hash. From that
they will be able to see what public key hashes are making the most
10CT payments to that public key hash. Let's say that Acme talks to
Faiza and asks her for information about her recent payments. She has
only made one payment so far, the one to John. Faiza, unknowing of why
Acme asks questions, discloses to Acme that the transaction is for
John.

.Dear John
****
It has come to our attention that you live an unhealthy life. We have
therefore promoted you to a higher risk category. Congratulations.

Sincerely, +
Acme Insurances
****

A week later, John receives a letter from Acme, politely informing him
that he is now promoted to a higher risk category, and his insurance
premium has been adjusted accordingly.

There are obviously still privacy issues to deal with. Luckily, as
noted above, users can create as many addresses they like. For example
the café could create a unique address for every incoming payment. And
John can create a brand new cookie token address the next time he will
accept cookie tokens from Faiza.

This will make it harder for Acme to extract information from the
cookie token spreadsheet. They will not be able to tell which payments
originate from the same person.

=== Exercises

.John's money
****
image::{imagedir}/exercise-johns-money.svg[]
****

1. Imagine that John wants a cookie from the café. He has two
addresses, one with balance 5 cookie tokens and another with 8 cookie
tokens. His total balance is 13 CT so he should afford to pay 10 CT
for a cookie. How would he pay 10 CT to the café?

1. Is it possible to deduce what addresses were involved in a certain
payment by looking at just the spreadsheet?
+
[{half-width}]
image::{imagedir}/exercise-deduce-address-or-pubkey.svg[]

1. Is it possible to deduce what public keys were involved in a
certain payment by looking at just the spreadsheet?

1. Suppose that everybody always used unique addresses for all
payments. What information could Acme use to roughly identify the
cafe's addresses?

=== Recap

In this chapter you leared that

* Privacy is important for you, not just for criminals.
* Using public key hashes instead of personal names as recipient for
  payments is important for privacy and more secure against fraud.
* Encoding a PKH as a Bitcoin address, or cookie token address,
  reduces the risk of sending money into void. The checksum in the
  address will prevent that.
* Only users care about Bitcoin addresses. The Bitcoin network, or
  Lisa, deals with plain public key hashes.
* You can have as many Bitcoin addresses as you like. Using multiple
  addresses, preferably one per received payment, improves your privacy.
