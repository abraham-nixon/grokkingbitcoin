[[ch08]]
== Peer to peer network - Ditch shared folder and email
:imagedir: {baseimagedir}/ch08
This chapter covers

* Removing last central authority, the shared folder
* Wallets broadcasting transactions to reach all miners
* Bootstrapping the peer to peer network

Let's talk about the elephant in the room. The shared folder. All
blocks the miners produce must pass through the shared folder on their
way to other full nodes and miners. This chapter will remove the
shared folder and replace it with a peer to peer network. A peer to
peer network lets full nodes (including miners) send blocks directly
to each other. When nodes are allowed to talk directly to each other,
we no longer need a central point of authority for communication.

Another issue we haven't talked much about is how wallets send their
transactions via email to the miners. When a new miner joins the
system, all wallets need to update their list of miners. Not cool. Now
when we have this nice peer to peer network of nodes, wallets can use
this network to broadcasst their transactions to all miners without
knowing who or where they are.

When a node starts up for the first time, how does it find other nodes
to connect to? How is the network bootstrapped? This is a hard problem
to solve, and there are no perfect solutions. We will do our best to
provide a good enough solution.

=== The shared folder

The shared folder administrator is a central authority. He ultimately
gets to decide what blocks are allowed to be stored in the shared
folder. He also gets to decide who is allowed to read from the shared
folder and write to it.

.The shared folder is a central point of authority
image::{imagedir}/shared-folder-problem.svg[{big-width}]

So far we have just assumed that the shared folder administrator is a
totally neutral good guy, but what if he's not, of what if he's forced
by Acme Insurances to reject certain blocks. What's the point of proof
of work, if the system can be censored at the block level any way?
Simply put, we are not yet censorship resistant. There are other
"solutions" besides the shared folder, for example, a radio station
broadcasting the blocks via digital radio to all interested full
nodes, but then the radio station is the central point of
authority. As long as you have a single entity that can decide what
blocks to allow, we are not censorship resistant.

There is yet another problem with the shared folder. Imagine that a
block of size 1MB has been created by Rashid, and he has just
published it to the shared folder. Everyone watching the shared
folder, all full nodes, will download Rashid's block at the same
time. If we have 100 full nodes, the total amount of data we need to
send from the shared folder to the different nodes would be
100 MB. This will cause _block propagation_, the transfer of blocks
from the creator to all other nodes, to be terribly slow. The more
nodes, the slower the block propagation.

=== Create a peer to peer network

What if the full nodes and miners could talk directly to each other
instead of relying on the cental shared folder. They could send the
blocks directly to one another in a _peer to peer network_.

.In a peer to peer network, blocks are being passed on from one node to another. Much like how gossip spreads among people.
image::{imagedir}/basic-network.svg[{half-width}]

Think of the peer to peer network as a number of people. One person
does not know everyone else, but he may know 5 people. When one person
discovers something interesting, for example he finds a block, he
tells his 6 friends about it who in turn tell all their friends, and
so on until everybody knows about this new block. We call this type of
networks for _gossip networks_ for apparent reasons.

Blocks can no longer be easily stopped. A node can chose not to pass
on the information to its peers, "friends", but the friends are
connected to several other friends who will gladly pass the
information to them. A single node can't do much to censor
information. Suppose that Rashid finds a block and he wants to get
this block out to all nodes.

.If the cafe refuse to forward a block to Lisa, someone else will do it.
image::{imagedir}/nodes-tolerate-bad-actors.svg[{half-width}]

Rashid sends his block to Qi, Tom and Cafe. For some reason, the cafe
doesn't forward the block to Lisa. But Lisa have several friends in this
network. She is connected to Tom and Qi. Tom will tell Lisa about this
new block and send it to her. The cafe can't hide information from
Lisa as long as Lisa is well connected, or has many friends.

Now that we have this nice network, why don't we use it for wallets to
pass their transactions to the miners? Then they don't have to keep
track of miner email addresses anymore. The transactions will just be
broadcast over the peer to peer network and within seconds reach all
miners. Do you remember this from <<ch01>>?

****
Transactions travel the network as we described in <<_step_2_the_bitcoin_network>>.
image::{commonimagedir}/periscope.gif[]
****

.Transactions travel the peer to peer network just like blocks do. Wallets don't need to know the miners anymore.
image::{imagedir}/transactions-over-p2p-network.svg[{big-width}]

Lightweight wallets will become first class citizens of the Bitcoin
(and Cookie Token) network. The same thing goes here as for blocks; a
single node cannot hinder transactions from reaching the whole
network. A very pleasant effect of using the peer to peer network for
transactions is that the recipient of the transaction can be notified
that a transaction is "pending", or about to be confirmed. We will see
how this work a bit later.

=== How do peers talk?

// REMEMBER: DON'T GO INTO IMPLEMENTATION DETAILS.

Let's have a look at how the communication between two peers
happen. We will look specifically at how Tom connects to Lisa and how
they communicate across their communication channel called a TCP
(Transmissin Control Protocol) connection.

.Tom and Lisa communicates over the Internet through a communication channel
image::{imagedir}/tom-lisa-communication.svg[{quart-width}]

Tom's node has heard about Lisa's node from another peer of his. He
got the IP (Internet Protocol) address and _port_ of Lisa's node from
that peer. Now he wants to connect to Lisa's node in order to
communicate with it. All computers on the internet has an IP
adreess. That is how one computer can send information to another
computer on the Internet. On top of the IP address, a computer program
that listens for incoming connections must listen on a specific _port_
number of that IP address. Lisas computer has the IP address
142.12.233.96 and runs a cookie token program that listens for
incoming connections on port 8333.

.Tom computer program sets up a TCP connection to Lisa's computer program. After this they can send and receive data easily.
image::{imagedir}/tcp-connection.svg[{half-width}]

Tom's node connects to Lisa's node through the IP address
142.12.233.96 and port 8333. His node (computer program) starts by
sending a message to Lisa's computer saying that he wants to talk to a
computer program on Lisa's port 8333. Her computer knows that a
program is actually listening on port 8333, so it sends back a "Sure,
welcome" message. Tom's computer acknowledges that by sending back a
"Ok, cool. Let's talk..." message.

The node software on Tom's and Lisa's computers were not involved in
this handshake, it was carried out by their operating systems, for
example Linux, Windows or MacOS. When the handshake sequence is
finished the connection is handed over to the node software by the
operating system. Lisa's and Tom's nodes can now speak freely to each
other. Tom can send data to Lisa and Lisa can send data to Tom over
this communication channel.

=== The network protocol

Tom and Lisa can send and receive data over a communication channel. For example

.Lisa must be able to understand what tom writes on the channel.
image::{imagedir}/need-protocol.svg[{quart-width}]

but if Tom's node speaks a language that Lisa's node don't understand,
the communication will not be meaningful. The nodes need to have a
common language, a _protocol_.

The Cookie token network protocol defines a set of different message
types that are allowed. A typical message in the Cookie token (well,
Bitcoin) network is the `inv` message:

[.gbinfo]
.This is abstract
****
The real network messages does not look exactly like these, we provide
an abstract view of the messages. The exact format of the network
messages is out of scope of this book.
****

.A typical network message.
image::{imagedir}/protocol-inv-example.svg[{half-width}]

The `inv`, short for _inventory_, message is used by a node to inform
other nodes about something it has. In the example above, Tom's node
informs Lisa's node that Tom has three things to offer Lisa, two
transactions and a block. The message contains the id for each of the
items.

Let's follow a transaction throught the network from start to end, to
see what network messages are used. Suppose that John wants to buy a
cookie from the cafe.

We will assume that the peer to peer network is already set up. We
will come back to how the network is _bootstrapped_ later in this
chapter.

==== John sends the transaction

In <<_lightweight_wallets>>, we said that wallets are allowed to
connect to full nodes and get information about all block headers and
transactions concerning them, using bloom filters and merkle paths.

.Lightweight wallets communicate with nodes using the Bitcoin network protocol.
image::{imagedir}/spv-node-exchange.svg[{big-width}]

We didn't go into detail then how the communication actually
works. That communication use the same protocol as the nodes use when
they communicate with each other. The wallets and the full nodes
(including miners) all speak the same "language".

John's wallet is connected to Tom's node with a TCP connection. He
scans the payment URI from the cafe's wallet. John's wallet create and
signs a transaction. You know the drill. Then it's time to send the
transaction to Tom's node:

.The transaction is sent to Tom's node using a TCP connection.
image::{imagedir}/john-sends-tx.svg[{half-width}]

This actually happens in a three-step process. John's wallet doesn't
just send the transaction unsolicited. He first informs Tom's node
that there is a transaction to be fetched.

.Tom's node is informed about John's transaction so that Tom can fetch it.
image::{imagedir}/tx-john-tom.svg[{half-width}]

The first message is an `inv` message as described in the previous
section. The `inv` is sent from John's wallet to Tom's full node. Tom
checks if he already has the transaction. He does not, because John's
wallet has just created it and hasn't sent it to anyone yet. Tom's
node wants to get this transaction so he requests it with a `getdata`
message that looks just like an `inv` message, but it has a different
meaning. `getdata` means "I want this stuff" while `inv` means "I have
this stuff".

John's wallet receives the `getdata` message and sends a `tx` message
containing the whole transaction to Tom's node. Tom will verify the
transaction and keep it. He will also pass this transaction on to his
network neighbors.

You may ask, why doesn't John's wallet simply send the whole
transaction immediately? Why go though the hassle with `inv` and
`getdata`? This will become clear later, but it's because nodes may
already have the transaction, se we save bandwidth by only sending
transaction hashes instead of whole transactions.

==== Tom forwards the transaction

If the transaction is valid, Tom's node will inform his neighbors
about this new transaction using an `inv` message, just like John did
when he informed Tom's node about the transaction.

.Tom forwards the transaction to his friends.
image::{imagedir}/tom-sends-tx.svg[{half-width}]

The process is exactly the same for these three message exchanges as
John used when he first sent the transaction to Tom. Lisa, Qi and
Rashid will get an `inv` message from Tom.

.Tom's node sends the transaction to Qi's node by using the familiar three-step process
image::{imagedir}/tx-tom-qi.svg[{half-width}]

When Lisa, Qi and Rashid has received the transaction, they too will
forward the transaction to their peers after they have verified the
transaction. Qi's and Rashid's nodes are a bit slower so it takes them
a while to verify the transaction, we will get back to them
later.

****
image::{imagedir}/2ndcol-lisa-sends-inv.svg[]
****

Lisa already knows that she received the transaction from Tom,
so she will not inform Tom's node with an `inv` message. But Lisa
doesn't know that Qi already has the transaction and she doesn't know
if the cafe has it. So she will send an `inv` to those nodes. The
cafe's node will send a `getdata`, because it has not yet seen this
transaction. But Qi's node is already aware of this transaction and
will not reply with anything.

.Lisa's node sends an inv to Qi's node, but Qi's node already has the transaction
image::{imagedir}/tx-lisa-qi.svg[{half-width}]

Now Qi has finished verifying the transaction. She knows that Lisa's
node has this transaction, so she doesn't have to send and `inv` to
Lisa's node. But she doesn't know if Rashid has it. So she sends an
`inv` to Rashid's node.

****
image::{imagedir}/2ndcol-rashid-sends-inv.svg[]
****

Rashid was the slowest node when verifying John's transaction so when
it's time for him to send an `inv` to his neighbors, he has already
received an `inv` from Qi's node. And he also knows from earlier that
Tom already has the transaction. He will just send an `inv` to the
cafe's node who will ignore the `inv`, because he already has the
transaction.

==== Cafe's lightweight wallet is notified

We said earlier that a good thing with letting transactions travel the
peer to peer network is that the recipient wallet can get a very quick
notification of the pending transaction. Now is the time to explore
this.

The cafe's full node has received the transaction and verified it. The
cafe also has a lightweight wallet on a mobile phone that it uses to
send and receive transactions. They are concerned with security, so
they have configured their lightweight wallet to only connect to their
own full node.

.The cafe's lightweight wallet has a TCP connection to their own full node
image::{imagedir}/cafe-connected-to-node.svg[{half-width}]

This is a common setup that gives the cafe the full security of a full
node combined with the flexibility and mobility of a lightweight
wallet. We described this setup in
<<_security_of_lightweight_wallets>>. But a lightweight wallet can
connect to any node. For example, John's lightweight wallet is
connected to Tom's node, but he doesn't know Tom.

The Cafe's full node has just verified Johns transaction. Now it
want's to inform its neighbors about this new transaction. It is
connected to Lisa's node, Rashid's node and the cafe's lightweight
wallet. The full node already knows that Lisa's and Rashid's nodes
have this transaction si it doesn't send an `inv` to those two
nodes. The full node does not know that the wallet has the
transaction, but it will not simply send an `inv` message to the
wallet.

.Bloom filter
****
image::{imagedir}/2ndcol-bloom-filter.svg[]
****

The wallet is a lightweight wallet, which uses bloom filters described
in <<_bloom_filters_obfuscate_addresses>>. The full node will test the
transaction against the bloom filter, and if it matches, an `inv`
message will be sent to the wallet. If no match, it will not send an
`inv` message.

John's transaction is actually for the cafe, so the bloom filter will
match the transaction and the full node sends an `inv`. The wallet
will request the actual transaction using `getdata`:

.The cafe's wallet gets John's transaction from their trusted node after checking against the bloom filter.
image::{imagedir}/tx-cafenode-cafe.svg[{half-width}]

[.gbinfo]
.0-conf tx
****
If the cafe accepts a transaction that is not yet in the blockchain,
it means that he trusts that John

1. Has paid enough transaction fee
2. Will not be double spent
****

The wallet has now received the transaction. It can show a message to
the cafe owner that a transaction is "pending". The cafe owner has a
choice here: He can chose to trust that the transaction will get
confirmed eventually, or he can wait until the transaction is included
in a block. This time, the cafe decides that it needs to wait until
the transaction is included in a valid block. This brings us to the
next phase, including the transaction in a block in the blockchain.

==== Include the transaction in a block

Let's recall some of our miners in this system. At the end of
<<_mitigating_miner_centralization>> we had 10 different miners, but
let's go back in time and pretend that Qi, Tom, Lisa and Rashid are
the only miners in this system right now.

****
image::{imagedir}/2ndcol-rashid-sends-inv.svg[]
****

The transaction has reached all these miners during transaction
propagation. Suppose that the transaction includes a nice transaction
fee to that miners are willing to include it in the blocks they are
currently trying to find a proof of work for.









. A node is listening for
incoming connections

Focus on whan information is transferred.

The anatomy of a peer to peer network message

image::{imagedir}/network-message-general.svg[{}]


What used to happen before was that Johns wallet would email the
transaction to the miners, and connect to a full node to get
notifications on when the transaction is included in a block.

[.gbinfo]
.TCP
****
TCP stands for Transmission Control Protocol. When you open a web page
on http://bitcoin.org, your web browser will make a TCP connection to
the computer named bitcoin.org and download an html file from their
web server.
****

This is not how it happens anymore. John's wallet is no longer aware
of any email addresses to miners. Instead, he just makes a internet
(TCP) connection to one or more full nodes and start exchanging
messages with them. In a sence, the lightweight wallets are now part
of the peer to peer network, but not quite, since they don't pass
information on.

==== Version

A lightweight wallet connects to a full node over the Internet. Once the connection is made, the lightweight wallet will send a version message to the full node. 

==== Inventory

==== Tx

==== Block


==== Compact blocks

==== MerkleBlock

Point back to ch 6 where we introduced merkle trees and lightweight
clients. Repeat the image from there.

=== Finding peers

Bootstrapping the network?

=== Wallets send transactions over the peer-to-peer network

Wallets stop sending transactions via email to miners. They are
transported across the network just like blocks are.

==== Mempool

Why do full nodes need a mempool? To avoid forwarding invalid
transactions to flood the network.

Full nodes and miners all keep unconfirmed transaction in the
_mempool_, short for memory pool.

Update mempool during reorg and new blocks

==== Users can see pending transactions

Trusting unconfirmed transactions is risky. Maybe its ok for a cookie.

==== The transaction lifecycle

=== Initial sync

==== System grows

* More miners compete for the new cookie tokens
* Users starts to use the system more frequently

What happens to the transactions in the stale blocks? What happens to
Lisa's block's transactions when she must update to a new chain tip?

Add pruning to ch06
