[[ch08]]
== Peer to peer network
:imagedir: {baseimagedir}/ch08
This chapter covers

* Removing last central authority, the shared folder
* Following a transaction in the peer to peer network
* Leaving the silly cookie tokens
* Bootstrapping the peer to peer network

Let's talk about the elephant in the room: The shared folder. All
blocks the miners produce must pass through the shared folder on their
way to other full nodes and miners. This chapter will remove the
central shared folder and replace it with a decentralized peer to peer
network. A peer to peer network lets full nodes (including miners)
send blocks directly to each other. When nodes are allowed to talk
directly to each other, we no longer need a central point of authority
for communication.

Another issue we haven't talked much about is how wallets send their
transactions via email to the miners. When a new miner joins the
system, all wallets need to update their list of miners. Not cool. Now
when we have this nice peer to peer network of nodes, wallets can use
this network to broadcast their transactions to all miners without
knowing who or where they are.

.Bitcoin's peer to peer network
image::{imagedir}/visual-toc-peer-to-peer-network.svg[{big-width}]

We will follow a transaction's path through the network, both as an
unconfirmed transaction, and eventually as part of a mined block. It
will start in John's wallet and end as a confirmed transaction in the
cafe's wallet.

We no longer need the cookie token system to help us understand
Bitcoin at this point in the chapter. We will talk only about Bitcoin
from now on. There are practically no differences between the cookie
token system and Bitcoin any more so it doesn't make sense to keep
talking about cookie tokens, when in fact we want to learn about
Bitcoin.

The last topic in this chapter will cover how a new node connects to
the network and becomes part of the peer to peer network. This is far
from trivial. How does it find nodes to connect to? How does it
download the blockchain up to the latest block? We will sort all
that out.

=== The shared folder

The shared folder administrator is a central authority. He ultimately
gets to decide what blocks are allowed to be stored in the shared
folder. He also gets to decide who is allowed to read from the shared
folder and write to it.

.The shared folder is a central point of authority
image::{imagedir}/shared-folder-problem.svg[{big-width}]

So far we have just assumed that the shared folder administrator is a
totally neutral good guy, but what if he's not, or what if he's forced
by Acme Insurances to reject certain blocks. What's the point of proof
of work, if the system can be censored at the block level any way?
Proof of work made the _transactions_ censorship resistant, because it
allowed users to send their transactions to multiple miners. But the
_blocks_ containing the transactions are still subject to censorship
by whomever has administrator privileges of the shared folder. Simply
put, we are not yet censorship resistant. As long as you have a single
entity that can decide what blocks or transactions to allow, we are
not censorship resistant.

There is yet another problem with the shared folder. Imagine that a
block of size 1MB has been created by Rashid, and he has just
published it to the shared folder. Everyone watching the shared
folder, all full nodes, will download Rashid's block at the same
time. If we have 100 full nodes, the total amount of data we need to
send from the shared folder to the different nodes would be
100 MB. This will cause _block propagation_, the transfer of a block
from the creator of the block to all other nodes, to be terribly
slow. The more nodes, the slower the block propagation.

=== Let's build a peer to peer network

What if the full nodes and miners could talk directly to each other
instead of relying on the central shared folder. They could send the
blocks directly to one another in a _peer to peer network_.

.In a peer to peer network, blocks are being passed on from one node to another. Much like how gossip spreads among people.
image::{imagedir}/basic-network.svg[{big-width}]

Think of the peer to peer network as a large number of people. One
person does not know everyone else, but he may know 5 people. When
something interesting happens, for example he finds a block, he tells
his 5 friends about it who in turn tell all their friends, and so on
until everybody knows about this new block. We call this type of
networks _gossip networks_ for apparent reasons.

[.gbinfo]
.Relay
****
To relay a received block means to pass the block on to others.
****

[role="important"]
Blocks can no longer be easily stopped. A node can chose
not to pass a block on, or _relay_ it, to its peers, but the peers are
connected to several other peers who will gladly relay the block to
them. A single node can't do much to censor information.

Suppose that Rashid finds a block and he wants to get this block out
to all nodes.

.If the cafe refuses to relay a block to Lisa, someone else will do it.
image::{imagedir}/nodes-tolerate-bad-actors.svg[{big-width}]

Rashid sends his block to Qi, Tom and Cafe. For some reason, the cafe
doesn't forward the block to Lisa. But Lisa has several peers in this
network. She is connected to Tom and Qi. Tom will tell Lisa about this
new block and send it to her. The cafe can't hide information from
Lisa as long as Lisa is well connected, has many different peers.

Now that we have this nice network, wallets can use it to get their
transactions sent to the miners. Then they don't have to keep track of
miner email addresses anymore. The transactions will be broadcast over
the peer to peer network and within seconds reach all full nodes. That
includes miners because they are also full nodes. This was mentioned
in <<ch01>> with this figure:

.Transactions travel the peer to peer network just like blocks do. Wallets don't need to know the miners anymore.
image::{imagedir}/transactions-over-p2p-network.svg[{big-width}]

The same thing goes here as for blocks; a single node cannot hinder
transactions from reaching the whole network. Another very pleasant
effect of using the peer to peer network for transactions is that the
recipient of the transaction can be notified that a transaction is
"pending", or about to be confirmed. We will see how this works a bit
later.

=== How do peers talk?

[.gbinfo]
.TCP
****
When you open a web page on http://bitcoin.org, your web browser will
make a TCP connection to bitcoin.org and download a web page through
that connection and display it to you.
****

Let's have a look at how the communication between two peers
happen. We will look specifically at how Tom connects to Lisa and how
they communicate across their communication channel called a TCP
(Transmission Control Protocol) connection.

.Tom and Lisa communicates over the Internet through a communication channel
image::{imagedir}/tom-lisa-communication.svg[{half-width}]

Suppose that Tom's node knows about Lisa's node. We will explain in
<<bootstrapping-the-network>> how Tom learns about other nodes. For
now let's just assume that he's got the IP (Internet Protocol) address
and _port_ of Lisa's node. Now he wants to connect to Lisa's node in
order to communicate with it. All computers on the Internet have an IP
address. That is how one computer can send information to another
computer on the Internet. A computer program that listens for incoming
connections must listen on a specific _port_ number of that IP
address. Lisa's computer has the IP address 142.12.233.96 and runs a
cookie token program that listens for incoming connections on port
8333.

[.inbitcoin]
.Port 8333
****
Port 8333 is the default listening port in Bitcoin Core, the most
widely used full node software.
****

.Tom's computer program sets up a TCP connection to Lisa's computer program. After this they can send and receive data between each other.
image::{imagedir}/tcp-connection.svg[{half-width}]

Tom's node connects to Lisa's node through the IP address
142.12.233.96 and TCP port 8333. His node (computer program) starts by
asking its operating system to initiate a connection to Lisa. The
operating system sends a message to Lisa's computer saying that he
wants to talk to a computer program on Lisa's port 8333. Her computer
knows that a program is actually listening on port 8333, so it sends
back a "Sure, welcome" message. Tom's computer acknowledges that by
sending back a "OK, cool. Let's talk..." message.

The node software on Tom's and Lisa's computers were not involved in
this handshake, it was carried out by their operating systems, for
example Linux, Windows or Mac OS. When the handshake sequence is
finished the connection is handed over to the node software by the
operating system. Lisa's and Tom's nodes can now speak freely to each
other. Tom can send data to Lisa and Lisa can send data to Tom over
this communication channel, or TCP connection.

[[the-network-protocol]]
=== The network protocol

Tom and Lisa can now send and receive data over a communication channel. For example

.Lisa must be able to understand what Tom writes on the channel.
image::{imagedir}/need-protocol.svg[{half-width}]

But if Tom's node speaks a language that Lisa's node don't understand,
the communication will not be meaningful. The nodes need to have a
common language, a _protocol_.

The Cookie Token network protocol defines a set of different message
types that are allowed. A typical message in the Cookie token (well,
Bitcoin) network is the `inv` message:

[.gbinfo]
.This is abstract
****
The real network messages does not look exactly like these, we provide
an abstract view of the messages. The exact format of the network
messages is out of scope of this book.
****

.A typical network message.
image::{imagedir}/protocol-inv-example.svg[{big-width}]

The `inv`, short for _inventory_, message is used by a node to inform
other nodes about something it has. In the example above, Tom's node
informs Lisa's node that Tom has three things to offer Lisa, two
transactions and a block. The message contains an id for each of the
items.

==== John sends the transaction

Let's follow a transaction through the network from start to end, to
see what network messages are being used. We will assume that the peer
to peer network is already set up. We will come back to how the
network is _bootstrapped_ later in this chapter.

In <<lightweight-wallets>>, we said that wallets are allowed to
connect to full nodes and get information about all block headers and
transactions concerning them, using bloom filters and merkle paths.

.Lightweight wallets communicate with nodes using the Bitcoin network protocol.
image::{imagedir}/spv-node-exchange.svg[{half-width}]

We didn't go into detail then how this communication actually
works. That communication use the same protocol as the nodes use when
they communicate with each other. The wallets and the full nodes
(including miners) all speak the same "language".

Suppose that John wants to buy a cookie from the cafe. John's wallet
is connected to Tom's node with a TCP connection. He scans the payment
URI from the cafe's wallet. John's wallet creates and signs a
transaction. You know the drill. Then it's time to send the
transaction to Tom's node:

.The transaction is sent to Tom's node through a TCP connection.
image::{imagedir}/john-sends-tx.svg[{half-width}]

This actually happens in a three-step process. John's wallet doesn't
just send the transaction unsolicited. He first informs Tom's node
that there is a transaction to be fetched.

.Tom's node is informed about John's transaction so that Tom can fetch it.
image::{imagedir}/tx-john-tom.svg[{big-width}]

The first message is an `inv` message as described in the previous
section. The `inv` is sent from John's wallet to Tom's full node. Tom
checks if he already has the transaction. He does not, because John's
wallet has just created it and hasn't sent it to anyone yet. Tom's
node wants to get this transaction so he requests it with a `getdata`
message that looks just like an `inv` message, but it has a different
meaning. `getdata` means "I want this stuff" while `inv` means "I have
this stuff".

John's wallet receives the `getdata` message and sends a `tx` message
containing the whole transaction to Tom's node. Tom will verify the
transaction and keep it. He will also relay this transaction to his
network neighbors.

You may ask, why doesn't John's wallet simply send the whole
transaction immediately? Why go though the hassle with `inv` and
`getdata`? This will become clear later, but it's because nodes may
already have the transaction, so we save bandwidth by only sending
transaction hashes instead of whole transactions.

==== Tom forwards the transaction

If the transaction is valid, Tom's node will inform his neighbors
about this new transaction using an `inv` message, just like John's
wallet did when it informed Tom's node about the transaction.

.Tom forwards the transaction to his friends.
image::{imagedir}/tom-sends-tx.svg[{big-width}]

The process is exactly the same for these three message exchanges as
John used when he first sent the transaction to Tom. Lisa, Qi and
Rashid will get an `inv` message from Tom.

.Tom's node sends the transaction to Qi's node by using the familiar three-step process
image::{imagedir}/tx-tom-qi.svg[{big-width}]

When Lisa, Qi and Rashid has received the transaction, they too will
inform their peers about the transaction after they have
verified it. Qi's and Rashid's nodes are a bit slower so it takes them
a while to verify the transaction, we will get back to them later.

****
image::{imagedir}/2ndcol-lisa-sends-inv.svg[]
****

Lisa was quick verifying the transaction so she will be the first of
the three to relay it. She already knows that she received the
transaction from Tom, so she will not inform Tom's node with an `inv`
message. But Lisa doesn't know that Qi already has the transaction and
she doesn't know if the cafe has it. So she will send an `inv` to
those two nodes. The cafe's node will send back a `getdata`, because
it has not yet seen this transaction. Qi's node already has this
transaction and will not reply with anything. She will remember that
Lisa has it, though.

.Lisa's node sends an inv to Qi's node, but Qi's node already has the transaction
image::{imagedir}/tx-lisa-qi.svg[{big-width}]

Now Qi has just finished verifying the transaction. She knows that
Lisa's node has this transaction, so she doesn't have to send and
`inv` to Lisa's node. But she doesn't know if Rashid has it. So she
sends an `inv` to Rashid's node.

****
image::{imagedir}/2ndcol-rashid-sends-inv.svg[]
****

Rashid was the slowest node when verifying John's transaction so when
it's time for him to send an `inv` to his neighbors, he has already
received an `inv` from Qi's node. And he also knows from earlier that
Tom already has the transaction. He will just send an `inv` to the
cafe's node who will ignore the `inv`, because they already have the
transaction.

==== Cafe's lightweight wallet is notified

We said earlier that a good thing with letting transactions travel the
peer to peer network is that the recipient wallet can get a very quick
notification of the pending transaction. Now is the time to explore
this.

The cafe's full node has received the transaction and verified it. The
cafe also has a lightweight wallet on a mobile phone that it uses to
send and receive money. They are concerned with security, so they have
configured their lightweight wallet to only connect to their own full
node, their _trusted node_.

.The cafe's lightweight wallet has a TCP connection to their own full node
image::{imagedir}/cafe-connected-to-node.svg[{half-width}]

This is a common setup that gives the cafe the full security of a full
node combined with the flexibility and mobility of a lightweight
wallet. We described this setup in
<<security-of-lightweight-wallets>>.

The Cafe's full node has just verified Johns transaction. Now it
want's to inform its neighbors about this new transaction. It is
connected to Lisa's node, Rashid's node and the cafe's lightweight
wallet. The full node already knows that Lisa's and Rashid's nodes
have this transaction so it doesn't send an `inv` to those two
nodes. The full node does not know that the wallet has the
transaction, but it will not simply send an `inv` message to the
wallet.

.Bloom filter
****
image::{imagedir}/2ndcol-bloom-filter.svg[]
****

The wallet is a lightweight wallet, which uses bloom filters described
in <<bloom-filters-obfuscate-addresses>>. The full node will test the
transaction against the bloom filter, and if it matches, an `inv`
message will be sent to the wallet. If no match, it will not send an
`inv` message.

John's transaction is actually for the cafe, so the bloom filter will
match the transaction and the full node sends an `inv`. The wallet
will request the actual transaction using `getdata`:

.The cafe's wallet gets John's transaction from their trusted node after being checked against the bloom filter.
image::{imagedir}/tx-cafenode-cafe.svg[{half-width}]

The wallet has now received the transaction. It can show a message to
the cafe owner that a transaction is "pending". The cafe owner has a
choice here: He can chose to trust that the transaction, a so-called
0-conf transaction, will get confirmed eventually, or he can wait
until the transaction is confirmed. If the cafe accepts the 0-conf
transaction, it means that they trust that John has paid enough
transaction fee and that it will not be double spent.

This time, the cafe decides that it needs to wait until the
transaction is included in a valid block. This brings us to the next
phase, including the transaction in a block in the blockchain.

[[include-the-transaction-in-a-block]]
==== Include the transaction in a block

Let's recall some of our miners in this system. At the end of
<<mitigating-miner-centralization>> we had 10 different miners, but
let's go back in time and pretend that Qi, Tom, Lisa and Rashid are
the only miners in this system right now.

****
image::{imagedir}/2ndcol-rashid-sends-inv.svg[]
****

The transaction has reached all these miners during transaction
propagation. John's wallet used to send the transaction via email to
all miners. Now he just sends it to any of the full nodes, and the
transaction will propagate across the whole peer to peer
network. Miners can now chose to include Johns transaction in the
blocks they are mining. Suppose that the transaction includes a nice
transaction fee so that some or all miners are willing to include it
and that Rashid is the next miner to find a valid proof of work for
his block, which happens to contain John's transaction.

.Rashid's block containing John's transaction
image::{imagedir}/2ndcol-rashids-block-valid.svg[{half-width}]

Now Rashid wants to get his block to the other miners as quickly as
possible to minimize the risk of some other miner getting a block out
before Rashid's block.

[.inbitcoin]
.BIP130
****
This process is defined in BIP130 that replaces an old block
propagation mechanism that used `inv` messages.
****

He creates a `headers` message and sends it to all his peers: Tom,
Cafe and Qi. Rashid's peers will send back a `getdata` message, and
Rashid will reply with the actual block. The message exchange between
Rashid and Qi will look like this:

.Rashid's node sends Rashid's block to Qi's node
image::{imagedir}/block-rashid-qi.svg[{half-width}]

The actual block is sent in a `block` message containing the full
block.

****
image::{imagedir}/2ndcol-rashid-sends-block.svg[]
****

Let's continue the block propagation throughout the peer to peer
network. Rashid has sent his block to Tom, Cafe and Qi. Now, those
three nodes will verify the block and, if valid, send out `headers`
messages to all their peers that might not already have it.

.All but Lisa has the block. Tom, Cafe and Qi send `headers` messages.
image::{imagedir}/tom-cafe-qi-sends-headers.svg[{half-width}]

Qi and Tom happens to send their `headers` messages to each other at
the same time. That's not a problem; since they both have the block,
they will just ignore the `headers` received from peers. Lisa will
request the block from one of her peers just like Qi requested the
block from Rashid. This concludes the propagation of this
block. Almost. The lightweight wallets need to be informed about the
block.

==== Notify wallets

Tom's node is connected to John's wallet so Tom sends a `headers`
message to John. Likewise, The cafe's full node sends a `headers` to
the cafe's lightweight wallet. Tom's and the cafe's full nodes will
not test the block against the bloom filters in any way. They will
just send the `headers` unconditionally, but the lightweight wallets
will not request the full blocks.

As we recall from <<ch06>>, lightweight wallets don't download the
full blocks. Most of the time John's wallet is only interested in the
block headers so that they can verify the proof of work of the
blockchain. However, every now and then there are transactions that
are relevant to John's wallet in the blocks, and the wallet wants
proof that those transactions are actually included in the block. In
this particular block, Rashid's block, we have John's transaction as
the third, and last, transaction of the block.

.Tom sends a `merkleblock` containing a merkle proof that John's transaction is in the block.
image::{imagedir}/john-requests-merkleblock.svg[{big-width}]

John gets a `merkleblock` message containing the block header and a
partial merkle tree connecting his transaction id to the merkle root
in the block header. Here is a little repetition from <<ch06>>:

.The merkleblock contains a block header and a partial merkle tree.
image::{imagedir}/verify-merkle-proof.svg[{big-width}]

John's wallet will verify that

* the block header is correct and has a valid proof of work.
* the merkle root in the header can be reconstructed using the partial
  merkle tree.
* The txid of John's transaction is included in the partial merkle
  tree. He doesn't care about the irrelevant transaction that is used
  to obfuscate what belongs to John..

John's wallet is now sure that his transaction is contained in the new
block. The wallet can display a message to John saying "Your
transaction has 1 confirmation".

The cafe's lightweight wallet will also be notified in the same way:

.The cafe requests a `merkleblock` from their trusted full node
image::{imagedir}/cafewallet-requests-merkleblock.svg[{big-width}]

****
image::{imagedir}/2ndcol-bloom-filter-tradeoff.svg[]
****

Because the cafe's wallet uses a trusted node, privacy is not much of
an issue. The wallet can use a really big bloom filter to reduce the
amount of irrelevant transactions which in turn will reduce mobile
data traffic. The sparser the bloom filter, the less extra obfuscation
traffic will be sent to the wallet.

The owner of the cafe feels comfortable handing over the cookie to
John now. John eats his cookie. The deal is done.

==== More confirmations

As time passes, more blocks will be mined by the miners. Those blocks
will all propagate the network and end up on all full nodes. The
lightweight wallets will get `merkleblock` versions to save bandwidth.

.As more blocks arrive, John's transaction becomes safer and safer
image::{imagedir}/further-confirmations.svg[{big-width}]

For each new block coming in, John's transaction will be buried under
more and more proof of work. This makes John's transaction harder and
harder to double spend. For each new block the transaction will get
one more confirmation.

=== Leaving the cookie token system

I don't think the cookie token system will help us understand Bitcoin
any more. It's time to let go of the cookie tokens and start talking
solely about Bitcoin from now on. We have developed the cookie token
system to a point where there are no differences from Bitcoin. Look at
our concept mapping table

[%autowidth]
.The shared folder is ditched in favor of a peer to peer network
|===
| Cookie Tokens | Bitcoin | Covered in

| 1 cookie token | 1 bitcoin | <<ch02>>
| *[.line-through]#The shared folder#* | *[.line-through]#The Bitcoin network#* | *[.line-through]#<<ch08>>#*
|===

The last cookie token concept that differs from Bitcoin, the shared
folder, has been eliminated. Let's have a look at how it all happened.

.The cookie token system evolution.
image::{imagedir}/cookie-token-evolution.svg[{full-width}]

We will keep our friends at the office a while longer. John will
probably have to buy a few more cookies, but he will use Bitcoin to
do it.

[[bitcoin-at-a-glance]]
==== Bitcoin at a glance

The Bitcoin peer to peer network is huge. As of writing:

[.movingtarget]
* It consists of about 10,000 publicly accessible full nodes.
* Bitcoin's money supply is about 17,100,000 BTC.
* Each bitcoin is worth around $6,500
* 200,000 transaction per day
* An estimate of 130,000 BTC, value $830M, being moved daily
* Total mining hashrate is about 36 Ehash/s, 36*10^18^ hash/s. A
  typical desktop computer can do about 25 Mhash/s.
* Transaction fees paid each day totals around 20 BTC. Which averages
  10,000 satoshis per transaction, or about $0.65  per transaction.
* People in all corners of the world use Bitcoin to get around
problems in their day-to-day life.

Moving on.

=== Where were we

****
image::{commonimagedir}/periscope.gif[]
****

This chapter is about Bitcoin's peer to peer network. The first half
of the chapter described the network in action after it has been
set up, as illustrated by this picture from <<ch01>>:

.The Bitcoin network distributes blocks (and transactions) to all participants.
image::{imagedir}/periscope-bitcoin-network.svg[{quart-width}]

The second half of this chapter will look at how a new node joins the
network.

[[bootstrapping-the-network]]
=== Bootstrapping the network

The scenario in <<the-network-protocol>> assumed that all nodes
involved were already connected to each other. But how does a new node
start? How would it find other nodes to connect to? How would it
download the full blockchain from the genesis block, block 0, and up
to the latest block? How does it know what the latest block is?

Let's sort it out.

Suppose that Selma wants to start her own full node. This is how it
would typically happen:

.Running a full node involves, downloading and running the software, connect to other nodes, download old blocks and enter normal operation
image::{imagedir}/running-a-full-node.svg[{full-width}]

1. Selma downloads, verifies and starts the full node computer program
2. The computer program connects to some nodes
3. Selma's node downloads blocks from her peers
4. Selma's node enters normal mode of operation

[[step-1]]
==== Step 1 - Run the software

****
image::{imagedir}/step-1-run-software.svg[]
****

Selma needs a computer program to run a full node. The most commonly
used such program is _Bitcoin Core_. There are several others, for
example libbitcoin, bcoin, Bitcoinj and btcd. We will only focus on
Bitcoin Core, but you are encouraged to explore the others yourself.

To download Bitcoin Core, Selma visits their main web page,
bitcoincore.org, and finds a download a link there. But there is a
potential problem: Selma isn't sure that the program she downloads is
actually the version that the developers behind Bitcoin Core
released. Someone could have fooled Selma to download the program from
bitconcore.org instead of bitcoincore.org, or someone might have
hacked bitcoincore.org and replaced the downloadable files with
alternative programs.

The Bitcoin Core team therefore signs all released versions of their
program with a private key, let's call it the Bitcoin Core key. They
provide the signatures in a downloadable file, usually named
`SHA256SUMS.asc`. This file contains the hash value of the released
Bitcoin Core software and a signature that signs the contents of the
`SHA256SUMS.asc` file:

.The Bitcoin Core team signs the released program with their private key
image::{imagedir}/core-signs-program.svg[{big-width}]

Selma has downloaded both the program itself, in a file called
`bitcoin-0.17.0-x86_64-linux-gnu.tar.gz` and the signature file called
`SHA256SUMS.asc`. In order to verify that the program is in fact
signed by the Bitcoin Core private key, she needs to know the
corresponding public key. But how can she know what this key is?

This is a hard problem. Remember when Lisa used to sign blocks with
her private key? How would the full nodes verify that the blocks are
actually signed by Lisa? They used multiple sources to fetch Lisa's
public key, for example the bulletin board at the entrance of the
office, the company's intranet, and asking colleagues. The same
applies here; You shouldn't trust a single source, but use at least
two different sources. The key that currently is being used to sign
Bitcoin Core releases is named

 Wladimir J. van der Laan (Bitcoin Core binary release signing key) <laanwj@gmail.com>

and has the _fingerprint_, 160 bit SHA1 hash of the key:

 01EA 5486 DE18 A882 D4C2  6845 90C8 019E 36C2 E964

This book can serve as _one_ of Selma's sources. She decides to

* get the fingerprint of the key from https://bitcoincore.org.
* verify the fingerprint with the Grokking Bitcoin book.
* verify the fingerprint with a fiend.
* download the actual key from a _key server_.

[.gbinfo]
.Where to get the key
****
It doesn't really matter where you get the actual public key from, but
it's important to verify that the fingerprint of the public key is
what you expect.
****

The fingerprints she got from the three sources match, so she
downloads the public key from a key server. A key server is a computer
on the Internet that provides a repository of keys. Key servers are
commonly used to download keys identified by the key's
fingerprint. Selma doesn't trust the key server so she needs to verify
that the fingerprint of the downloaded key actually matches the
expected fingerprint, which it does.

Now when she has the Bitcoin Core public key, she can verify the
signature of the `SHA256SUMS.asc` file.

.Selma verifies the Bitcoin Core signature and that the hash in the signature file matches the hash of the actual program.
image::{imagedir}/selma-verifies-program.svg[{big-width}]

She uses the Bitcoin Core public key to verify the signature in the
signature file. She must also verify that the program has the same
hash-value as stated in `SHA256SUMS.asc`. The signature is valid and
the hashes match, which means that she can be sure that the software
she is about to run is authentic.

Selma starts the program on her computer.

==== Step 2 - Connect to nodes

****
image::{imagedir}/step-2-connect.svg[]
****

When Selma's full node program starts, it is not connected to any
other nodes. She's not part of the Bitcoin network yet. In this step
the node will try to find peers to connect to.

To connect to a peer, the full node needs the IP address and the TCP
port for that peer, for example

 IP: 142.12.233.96 port: 8333

An IP address and port are often written as

 142.12.233.96:8333

===== Finding initial peers

Where does Selma's node find initial addresses of other peers? There are
several sources available:

.Selma's full node has three different types of sources to find initial peers
image::{imagedir}/initial-peer-addresses.svg[{big-width}]

1. Configure the full node with custom peer addresses. Selma can get
an address by asking a friend who's running a full node.
2. Use the Domain Name System, DNS, to lookup initial peer addresses
   to connect to.
3. Use "hard coded" peer addresses in the full node program itself.

[role="important"]
Selma's node should not initially connect to just one
single node. If that single node is malicious, you have no way of
knowing it. If you connect to multiple nodes initially, you can verify
that they all send data consistent with each other. If not, one or
more nodes are deliberately lying to you or they have themselves been
fooled.

The preferred way to find initial node addresses is to look them up in
the DNS system. DNS is a global name lookup system, used to lookup IP
numbers from computer names. For example, when you visit
`https://bitcoin.org` with your web browser, it will use DNS to lookup
the IP number of the name `bitcoin.org`. The Bitcoin Core software does
the same. The names to lookup are hard coded into Bitcoin Core, just
like the hard coded IP addresses and ports. There are several DNS
seeds coded into the software. A lookup of a DNS seed can return
several IP addresses on each lookup and every new lookup may return a
different set of IP addresses. The last, third, option is used as a
last resort.

Note from the picture above that the DNS lookups do not return a port
number. The other two methods of finding initial peers usually include
a port number. The DNS response can only return IP addresses, so the
nodes on these IP addresses are assumed to listen on the default port
that Bitcoin Core listens on, which is `8333`.

===== Handshaking

****
image::{imagedir}/initial-connection-simple.svg[]
****

Suppose that Selma's node chooses to connect to Qi's node,
`1.234.63.203:4567`, and to `47.196.31.246:8333`. She sets up a TCP
connection to each of the two nodes and sends an initial message to
both of them on the new TCP connections. Let's look at how she talks
to Qi's node.

.Selma exchanges `version` message with Qi.
image::{imagedir}/version-selma-qi.svg[{big-width}]

The exchange, called a _handshake_, starts with Selma who sends a
`version` message to Qi. The handshake is used to agree on a protocol
version to use and tell each other what block heights they have. The
`version` message contains a lot of information not shown in the
figure, but the most essential stuff is there:

Protocol version:: The version of the network protocol, or "language",
that peers use to talk to each other. Selma and Qi will use version
70012 because that's the highest version Qi will understand. Selma
knows all protocol versions up to her own version.
User agent:: This is shown as Software "identification" in the figure
because "User agent" is a bit of a cryptic word. It is used to hint
the other node what software you are running, but it can be anything.
height:: This is the height of the tip of the best chain that the
node has. This is used later in the synchronization step.

Some other useful information of the `version` message is

Services:: A list of features that this node supports. For example
bloom filtering used by lightweight clients.
My address:: The IP address and port of the node sending the `version`
message. Without it Qi wouldn't know what address to connect to if she
restarts and wants to reconnect to Selma's node.

When Qi's node receives Selma's `version` message, she will reply with
her own `version` message. She will also send a `verack` message
immediately after the `version` message. The `verack` doesn't contain
any information, it is used to acknowledge to Selma that Qi has
received the `version` message.

As soon as Selma's node receives Qi's `version` message, it will reply
with a `verack` message back to Qi's node. The handshake is done. She
does the same procedure with Rashid's node as well.

===== Finding peers' peers

When Selma's node is connected to Rashid's node it will ask that node
for other peer addresses to connect to. That way Selma will be able to
expand her set of peers.

.Selma asks her peers for more peer addresses to connect to.
image::{imagedir}/selma-finds-more-peers.svg[{big-width}]

Selma is only connected to two peers, Qi's node and Rashid's node. But
she thinks that she needs more nodes to connect to. Being connected to
only two nodes has some implications:

* Qi and Rashid can collude to hide transactions and blocks from Selma.
* Qi's node could break and Selma is left with only Rashid's
  node. Then Rashid can single handedly hide information from Selma.
* Both Qi's and Rashid's node could break in which case Selma is
  completely disconnected from the network until she connects to some
  other nodes via the initial peer lookup mechanisms.

This is how Selma asks Rashid for more peer addresses to connect to:

.Selma requests more peer addresses from Rashid's node. He responds with a bunch.
image::{imagedir}/addr-selma-rashid.svg[{big-width}]

[.gbinfo]
.Initial nodes
****
Nodes disconnect from initial nodes (except manually configured nodes)
after getting an `addr` message, to avoid overloading them. They are
initial nodes for many other nodes.
****

Selma sends a `getaddr` message to a peer, Rashid's node. Rashid
responds with a set of IP addresses and TCP ports that Selma can use
to connect to more peers. Rashid chooses what addresses to send to
Selma, but it's usually the addresses that Rashid is already connected
to, and possibly some addresses that Rashid collected from his peers
but didn't use himself.

Selma will connect to any number of the received addresses to increase
her _connectivity_. The more peers you are connected to, the better
your connectivity. A high degree of connectivity decreases the risk of
missing out on information due to misbehaving peers. Also, information
propagates quicker if nodes have higher connectivity. A typical full
node in Bitcoin has about 100 active connections at the same
time. Only eight (by default) of those are so-called outbound
connections, which means that the connections are initiated by that
node. The rest are in-bound connection, initiated by other nodes. As a
consequence, a full node that is not reachable on port 8333 from the
Internet, for example due to a firewall, will not get more than eight
connections in total.

==== Step 3 - Synchronize

****
image::{imagedir}/2ndcol-sync.svg[]
****

Now that Selma is well connected to, and part of, the Bitcoin network,
it's time for her to download and verify the full blockchain up to the
very latest block available. This process is called _synchronization_,
_sync_, or _initial blockchain download_.

Remember in step 2, when Selma received a `version` message from Qi's
node that stated `height=545104`? Selma will use that information now
to determine where to fetch historic blocks from.

Selma only has a single block, namely the genesis block. The genesis
block is hard coded in the Bitcoin Core software, so all nodes have
this block already when they start. Now she needs to download old
blocks from other nodes. These are the claimed heights of Selma's
peers:

|===
| Node | Height

| Qi | 545104
| Rashid | 545104
| Cafe | 545105
| Tom | 545105
|===

Selma wants all those blocks. She needs to download them all from her
peers and verify them before being able to verify newly created
blocks. This is because she has no idea of what the current UTXO set
looks like. To build the current UTXO set, she needs to start with an
empty UTXO set and go through all historic blocks from block 0, and
update the UTXO set with the information in the transactions in the
blocks.

The process is as follows:

1. Download all historic block headers from one peer and verify the
proof-of-work
2. Download all blocks on the strongest chain from multiple peers in
parallel.

Selma selects one of her peers, Tom, to download all block headers
from. This is how Selma's node downloads the block headers from Tom's
node:

[.gbinfo]
.Simplified
****
The `getheaders` message actually contains a list of some block ids
from Selma's blockchain, so that Tom can find a common block that they
both have in case Tom doesn't have Selma's tip. Let's not bother with
that.
****

.Selma downloads block headers from Tom by repeatedly sending a `getheaders` message with her latest block id.
image::{imagedir}/getheaders-selma-tom.svg[{big-width}]

She sends a `getheaders` message containing Selma's latest block id,
which happens to be the genesis block, block `0`. Tom sends back a
list of 2000 block headers, each block header is 80 bytes. Selma
verifies the proof of work of each header and requests a new batch of
headers from Tom. This process continues until Selma receives a batch
of less than 2000 headers from Tom, which is a signal that Tom has no
more headers to give Selma.

// TODO: Mention below that Selma doesn't wait for all headers, but for headers with
// enough total PoW before starting download.

When Selma has received all headers from Tom, she determines what
branch is the strongest and starts downloading actual block data
belonging to that branch from her peers. She can download block data
from multiple peers at the same time to speed things up. This is her
communication with Rashid's node:

[.inbitcoin]
.Bigger batches
****
In this example Selma requests three blocks at a time, but in reality,
Bitcoin Core would request a list of at most 16 block per batch.
****

.Selma downloads blocks from Tom by repeatedly sending a `getblocks` message with her latest block id.
image::{imagedir}/getblocks-selma-rashid.svg[{big-width}]

[.gbinfo]
.Initial download
****
[.movingtarget]

Initial blockchain download, about 200 GB as of writing, takes several
hours, even days, depending on the performance of your hardware and
Internet speed.
****

It starts with Selma who sends a `getdata` message to Rashid. This
message specifies what blocks she wants to download from
Rashid. Rashid sends back the requested blocks in `block` messages,
one by one. Note that she downloads only part of the blocks from
Rashid. She also downloads blocks from Tom in parallel, which is why
there are gaps in the sequence of requested block. The process is
repeated until Selma doesn't want any more blocks from Rashid.

At the time Selma has downloaded all blocks up to height 545105,
Rashid has probably received more fresh blocks from his peers. Suppose
that he has received block `545105` by the time Selma has received the
first 100 blocks from Rashid. Rashid would then send out a `headers`
message to his peers, including Selma, as described in
<<include-the-transaction-in-a-block>>. That way, Selma will be aware
of all new blocks appearing during her initial synchronization and can
later request them from any peer.

As Selma receives blocks, she verifies them, updates her UTXO set and
adds them to her own blockchain. 

[[validating-early-blocks]]
===== Validating early blocks

The most time consuming part of verifying a block is verifying the
transaction signatures. If you know of any block id that is part of a
valid blockchain, you can skip verifying the signatures of all blocks
prior to and including this block. This will greatly speed up the
initial blockchain download up to that block:

.Signatures of reasonably old transactions will not be verified to speed up initial block download
image::{imagedir}/skip-sigvalidation-of-early-blocks.svg[{big-width}]

Of course, other stuff like verifying that no double spends occur, or
that the block rewards are correct is still done. The syncing node
must build its own UTXO set, so it still has to go through all
transactions to be able to update the UTXO set accordingly.

Bitcoin Core ships with a preconfigured hard coded block id of a block
a number of weeks back from release date in the blockchain. For
Bitcoin Core 0.17.0, that block is

 height: 534292
 hash: 0000000000000000002e63058c023a9a1de233554f28c7b21380b6c9003f36a8

Which is about 10,000 blocks back in the blockchain at release
date. This is of course a configuration parameter and the above block
is just a default reasonable value. Selma could have changed this when
starting her node, or she could have verified with friends and other
sources she trusts that this block is in fact representing a "all
valid transactions blockchain". She could also have disabled the
feature completely to verify all transaction signatures since block 0.

After a long while, she is finally on the same page as the other
nodes. and ready to enter normal mode of operation.

==== Step 4 - Normal operation

This step is easy, because we have already described it in
<<the-network-protocol>>. Selma enters normal mode of operation. From
now on she will participate in block propagation, transaction
propagation and verify every transaction and block coming in.

.Selma is finally an active part of the Bitcoin peer to peer network
image::{imagedir}/selma-full-blown-node.svg[{half-width}]

Selma is now running a full blown full node.

[[run-your-own-full-node]]
=== Run your own full node

.On-line instructions
****
More detailed instructions for all major operating systems are
available at <<web-install>>.
****

[WARNING]

This section will walk you through setting up your own Bitcoin Core
full node on a Linux operating system. It is intended for readers
comfortable with the linux operating system and command line.

We have seen how a Bitcoin full node is downloaded, started, and
synchronized in theory. This section will help you get your own full
node installed.

This section requires that you

[.movingtarget]
* have a computer with at least 2GB of RAM running a Linux operating
  system.
* have lots of available disk space. As of writing, about 200 GB is needed.
* have an Internet connection without a limited data plan.
* know how to start and use a command-line terminal.

If you don't have a Linux operating system, you may still use these
instructions, but you will have to install the version of Bitcoin Core
that's appropriate for your system, and the commands will look
different. However, I suggest that you visit <<web-install>> to get
up-to-date instructions for your non-linux operating system.

The general process for getting your own node running is:

1. Download Bitcoin Core from https://bitcoincore.org/en/download/.
2. Verify software.
3. Unpack and start.
4. Wait for initial blockchain download to finish.

==== Download Bitcoin Core

****
image::{imagedir}/download-bitcoin-core.svg[]
****

To run your own full Bitcoin node, you need the software program
to run. In this example we will download Bitcoin Core from
<<web-download>>. As of writing the latest version of Bitcoin
Core is `0.17.0`. Let's download it:

----
$ wget https://bitcoincore.org/bin/bitcoin-core-0.17.0/bitcoin-0.17.0-x86_64-linux-gnu.tar.gz
----

As the file name `bitcoin-0.17.0-x86_64-linux-gnu.tar.gz` indicates,
we download version 0.17.0 for 64 bit (`x86_64`) linux
(`linux-gnu`). When you are reading this, new versions of Bitcoin Core
have probably been released. Consult <<web-download>> to get the
latest version of Bitcoin Core. Also, if you use another operating
system or computer architecture, please select the file that's right
for you.

==== Verify the the software

[WARNING]

This section is hard and requires a fair amount of work on the command
line. If you just want to install and run the Bitcoin Core software
for experimental purposes you can skip this section and jump to
<<unpack-and-start>>. If not for experimental purposes please
understand the risks explained in <<step-1>> before skipping this
step.

This section will show you how to verify that the downloaded `.tar.gz`
file is not tampered with in any way. That file is digitally signed by
the Bitcoin Core team's private key. The verification process
involves the following steps:

. Download the signature file
. Verify that the hash of the `.tar.gz` file matches the hash in the
message part of the signature file
. Download the Bitcoin Core team's public key
. Install the public key as trusted on your computer
. Verify the signature

Let's get started.

===== Download the signature file

To be able to verify that your downloaded Bitcoin Core package is
actually from the Bitcoin Core team, you need to download the
signature file named SHA256SUMS.asc. This figure from <<step-1>>
explains how the SHA256SUMS.asc file is designed:

.The Bitcoin Core team signs the released program with their private key
image::{imagedir}/core-signs-program.svg[{big-width}]

Download the signature file `SHA256SUMS.asc` from the same server as
you downloaded the program from:

----
$ wget https://bitcoincore.org/bin/bitcoin-core-0.17.0/SHA256SUMS.asc
----

This file will be used to verify that the downloaded `.tar.gz` file is
signed by the Bitcoin Core team. Note that this file is for version
0.17.0 only. If you use another version of Bitcoin Core, please select
the correct signature file at <<web-download>>.

The actual contents of this file looks like this (the actual hashes
have been shortened in this listing):

----
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA256

1e43...35ed  bitcoin-0.17.0-aarch64-linux-gnu.tar.gz
a4ff...7585  bitcoin-0.17.0-arm-linux-gnueabihf.tar.gz
967a...f1b7  bitcoin-0.17.0-i686-pc-linux-gnu.tar.gz
e421...5d61  bitcoin-0.17.0-osx64.tar.gz
0aea...ac58  bitcoin-0.17.0-osx.dmg
98ef...785e  bitcoin-0.17.0.tar.gz
1f40...8ee7  bitcoin-0.17.0-win32-setup.exe
402f...730d  bitcoin-0.17.0-win32.zip
b37f...0b1a  bitcoin-0.17.0-win64-setup.exe
d631...0799  bitcoin-0.17.0-win64.zip
9d6b...5a4f  bitcoin-0.17.0-x86_64-linux-gnu.tar.gz
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.11 (GNU/Linux)

iQIcBAEBCAAGBQJbtIOFAAoJEJDIAZ42wulk5aQP/0tQp+EwFQPtSJgtmjYucw8L
SskGHj76SviCBSfCJ0LKjBdnQ4nbrIBsSuw0oKYLVN6OIFIp6hvNSfxin1S8bipo
hCLX8xB0FuG4jVFHAqo8PKmF1XeB7ulfOkYg+qF3VR/qpkrjzQJ6S/nnrgc4bZu+
lXzyUBH+NNqqlMeTRzYW92g0zGMexig/ZEMqigMckTiFDrTUGkQjJGzwlIy73fXI
LZ/KtZYDUw82roZINXlp4oNHDQb8qT5R1L7ACvqmWixbq49Yqgt+MAL1NG5hvCSW
jiVX4fasHUJLlvVbmCH2L42Z+W24VCWYiy691XkZ2D0+bmllz0APMSPtgVEWDFEe
wcUeLXbFGkMtN1EDCLctQ6/DxYk3EM2Ffxkw3o5ehTSD6LczqNC7wG+ysPCjkV1P
O4oT4AyRSm/sP/o4qxvx/cpiRcu1BQU5qgIJDO+sPmCKzPn7wEG7vBoZGOeybxCS
UUPEOSGan1Elc0Jv4/bvbJ0XLVJPVC0AHk1dDE9zg/0PXof9lcFzGffzFBI+WRT3
zf1rBPKqrmQ3hHpybg34WCVmsvG94Zodp/hiJ3mGsxjqrOhCJO3PByk/F5LOyHtP
wjWPoicI2pRin2Xl/YTVAyeqex519XAnYCSDEXRpe+W4BdzFoOJwm5S6eW8Q+wkN
UtaRwoYjFfUsohMZ3Lbt
=H8c2
-----END PGP SIGNATURE-----
----

The signed message in the upper part of the file lists a number of
files along with their respective SHA256 hashes. The listed files are
all installation packages for all operating systems and architectures
that Bitcoin Core is released for. The lower part of the file is the
signature of the the message in the upper part. The signature commits
to the whole message and thus to all the hashes and files listed in
the message.

===== Verify the hash of the downloaded file

The file you downloaded is named for example
`bitcoin-0.17.0-x86_64-linux-gnu.tar.gz` so you expect that the SHA256
hash of that file matches `e632...6477` exactly. Let's check:

----
$ sha256sum bitcoin-0.17.0-x86_64-linux-gnu.tar.gz 
9d6b472dc2aceedb1a974b93a3003a81b7e0265963bd2aa0acdcb17598215a4f  bitcoin-0.17.0-x86_64-linux-gnu.tar.gz
----

The above command calculates the SHA256 hash of our downloaded
file. It does indeed match the hash in the `SHA256SUMS.asc` file. If
they don't match, then something is wrong and you should halt
installation and investigate what's wrong.

===== Get the Bitcoin Core signing key

****
image::{imagedir}/download-key.svg[]
****

To verify that the signature in the signature file is done by the
Bitcoin Core signing key, you need the corresponding public key. As
noted in <<step-1>>, you should convince yourself about what
_fingerprint_ the Bitcoin Core key has and then download that key from
any source.

You could for example

1. get the fingerprint of the Bitcoin Core team's key from
  `bitcoincore.org`, the official website of the Bitcoin Core team.
2. consult the book Grokking Bitcoin to verify the fingerprint.
3. verify the fingerprint with a friend.
4. download the public key from a key server.

You start with finding the Bitcoin Core team's public key fingerprint
on their website. You find the following fingerprint on their
downloads page: `01EA5486DE18A882D4C2684590C8019E36C2E964`.

You will now consult the book Grokking Bitcoin to check if the
fingerprint in that book matches the fingerprint from
`bitcoincore.org`. Let's have a look in <<step-1>> of that book. It
says:

 01EA 5486 DE18 A882 D4C2  6845 90C8 019E 36C2 E964

This is the same fingerprint (although formatted slightly
different). The book and the website `bitcoincore.org` both claim that
this key belong to the Bitcoin Core team. Let's not settle with
that. You will also call a friend you trust and have him/her read the
fingerprint to us.

You: Hello Donna! What's the fingerprint of the current Bitcoin Core
signing key?

Donna: Hi! I have verified that key myself a few months ago and I know
that the fingerprint is `01EA 5486 DE18 A882 D4C2 6845 90C8 019E 36C2
E964`.

You: Thank you, it matches mine, bye!

Donna: You're welcome, bye!

Donna's statement further strengthens your trust in this key. You think
you have collected enough evidence that this is in fact the
correct key.

Let's start downloading the key. To do this you can use a tool called
`gpg`, which stands for GnuPG, which in turn stands for Gnu Privacy
Guard. This is a program that conforms to a standard called OpenPGP,
Pretty Good Privacy. This standard specifies how keys can be exchanged
and how to do encryption and digital signatures in an
interoperable way.

GnuPG is available on most linux computers by default. To download a
public key with a certain fingerprint, you run the following `gpg`
command:

----
$ gpg --recv-keys 01EA5486DE18A882D4C2684590C8019E36C2E964
gpg: key 90C8019E36C2E964: public key "Wladimir J. van der Laan (Bitcoin Core binary release signing key) <laanwj@gmail.com>" imported
gpg: no ultimately trusted keys found
gpg: Total number processed: 1
gpg:               imported: 1
----

Depending on the version of gpg you use, the output may vary. This
downloads the public key from any available key server and verifies
that the downloaded public key in fact has the fingerprint that you
requested. The owner of this key is "Wladimir J. van der Laan (Bitcoin
Core binary release signing key)".

The above command downloads the key into gpg and adds it to your list
of known keys. But the output of the above command, mentions that `no
ultimately trusted keys found`. This means that this key is not signed
by any key that you trust. You have only imported the key. In gpg,
keys can sign other keys to certify that the signed key is legit.

===== Sign the public key as trusted on your computer

You have verified that the key belongs to the Bitcoin Core team, and
installed that key onto your system using `gpg`.

You will now sign that key with a private key that you own. You do
that to remember this key as trusted. The Bitcoin Core team will
probably release new versions of Bitcoin Core in the future. If GnuPG
remembers this public key as trusted, you don't have to go through all
these key verification steps again when you upgrade.

The process is:

1. Create a key of your own
2. Sign the Bitcoin Core public key with your own private key

To create a key of your own, GnuPG let's you create a key with the
following command:

----
$ gpg --gen-key
gpg (GnuPG) 2.1.18; Copyright (C) 2017 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Note: Use "gpg --full-generate-key" for a full featured key generation dialog.

GnuPG needs to construct a user ID to identify your key.
----

GnuPG will ask for your name and email address. Answer these
questions, they will be used to identify your key.

----
Real name: Kalle Rosenbaum
Email address: kalle@example.com
You selected this USER-ID:
    "Kalle Rosenbaum <kalle@example.com>"

Change (N)ame, (E)mail, or (O)kay/(Q)uit? 
----

Continue by pressing `O` (capital oh). Then you need to select a
password to encrypt your private key with. Chose a password and make
sure that you remember it. The key generation may take some time
because it takes time to generate good random numbers for your key. When it's finished, you should see output like this:

----
public and secret key created and signed.

pub   rsa2048 2018-04-27 [SC] [expires: 2020-04-26]
      B8C0D19BB7E17E5CEC6D69D487C0AC3FEDA7E796
      B8C0D19BB7E17E5CEC6D69D487C0AC3FEDA7E796
uid                      Kalle Rosenbaum <kalle@example.com>
sub   rsa2048 2018-04-27 [E] [expires: 2020-04-26]
----

Now you have a key of your own that you'll use to to sign keys that
you trust. Let's sign the Bitcoin Core team key:

----
$ gpg --sign-key 01EA5486DE18A882D4C2684590C8019E36C2E964

pub  rsa4096/90C8019E36C2E964
     created: 2015-06-24  expires: 2019-02-14  usage: SC  
     trust: unknown       validity: unknown
[ unknown] (1). Wladimir J. van der Laan (Bitcoin Core binary release signing key) <laanwj@gmail.com>


pub  rsa4096/90C8019E36C2E964
     created: 2015-06-24  expires: 2019-02-14  usage: SC  
     trust: unknown       validity: unknown
 Primary key fingerprint: 01EA 5486 DE18 A882 D4C2  6845 90C8 019E 36C2 E964

     Wladimir J. van der Laan (Bitcoin Core binary release signing key) <laanwj@gmail.com>

This key is due to expire on 2019-02-14.
Are you sure that you want to sign this key with your
key "Kalle Rosenbaum <kalle@example.com>" (8DC7D3846BA6AB5E)

Really sign? (y/N)
----

Enter `y`. You will be prompted for your private key password. Enter
it and press enter. The Bitcoin Core key should now be regarded as
trusted by `gpg`. This will simplify the process when you upgrade your
node in the future.

Let's look at your newly signed key:

----
$ gpg --list-keys 01EA5486DE18A882D4C2684590C8019E36C2E964
pub   rsa4096 2015-06-24 [SC] [expires: 2019-02-14]
      01EA5486DE18A882D4C2684590C8019E36C2E964
uid           [  full  ] Wladimir J. van der Laan (Bitcoin Core binary release signing key) <laanwj@gmail.com>
----

The word to look for is the `full` in square brackets. This means that
gpg, and you, fully trust this key.

===== Verify the signature

It's time to actually verify the signature of `SHA256SUMS.asc` file.

----
$ gpg --verify SHA256SUMS.asc 
gpg: Signature made Wed 03 Oct 2018 10:53:25 AM CEST
gpg:                using RSA key 90C8019E36C2E964
gpg: Good signature from "Wladimir J. van der Laan (Bitcoin Core binary release signing key) <laanwj@gmail.com>" [full]
----

It says that the signature is `Good` and that it's signed with a key
that you fully trust, `[full]`.

To summarize, you have:

1. downloaded Bitcoin Core and the signature file
2. verified that the hash of the `.tar.gz` file matches the stated hash
  in `SHA256SUMS.asc`.
3. downloaded a public key and verified that it belongs to Bitcoin Core
4. signed that key with our own private key so that GnuPG and you remember that the
  Bitcoin Core key is legit.
5. verified the signature of the `SHA256SUMS.asc` file.

When you later upgrade the program, you can skip several of the above
steps. The process then will be:

1. Download Bitcoin Core and the signature file
2. Verify that the hash of the `.tar.gz` file matches the stated hash
  in `SHA256SUMS.asc`.
3. Verify the signature of the `SHA256SUMS.asc` file.

[[unpack-and-start]]
==== Unpack and start

Let's unpack the software:

----
tar -zxvf bitcoin-0.17.0-x86_64-linux-gnu.tar.gz
----

This will create a directory called `bitcoin-0.17.0`. Go into the
directory `bitcoin-0.17.0/bin` and have a look:

----
$ cd bitcoin-0.17.0/bin
$ ls
bitcoin-cli  bitcoind  bitcoin-qt  bitcoin-tx  test_bitcoin
----

Here you have a number of executable programs:

* `bitcoin-cli` is a program you can use to extract information about
  the node you are running as well as manage a built-in wallet that's
  shipped with Bitcoin Core.
* `bitcoind` is the program to use if you want to run the node in the
  background without a graphical user interface.
* `bitcoin-qt` is the program to run if you want a graphical user
  interface for your node. This is mainly useful if you use the
  build-in wallet.
* `bitcoin-tx` is a small utility program to create and modify Bitcoin
  transactions.
* `test_bitcoin` lets you test run a test suite.

In this tutorial, we will run `bitcoind`, which stands for "Bitcoin
Daemon". In Unix systems like Linux, the word Daemon is used for
computer programs that runs in the background.

Let's start the Bitcoin Core daemon in the background (using the `-daemon` argument) and see what happens:

----
$ ./bitcoind -daemon
Bitcoin server starting
----

This starts your node. It will automatically start connecting to peers
and download the blockchain for you.

==== Initial blockchain download

****
image::{imagedir}/2ndcol-sync.svg[]
****

This process will take time. Depending on your internet connection,
processor and disk, it can vary from several days down to a few hours.

You can use the `bitcoin-cli` program to query the running node about
the progress:

----
$ ./bitcoin-cli getblockchaininfo
{
  "chain": "main",
  "blocks": 207546,
  "headers": 549398,
  "bestblockhash": "00000000000003a6a5f2f360f02a3b8e4c214d27bd8e079a70f5fb630a0817c5",
  "difficulty": 3304356.392990344,
  "mediantime": 1352672365,
  "verificationprogress": 0.0249296506976196,
  "initialblockdownload": true,
  "chainwork": "0000000000000000000000000000000000000000000000202ad90c17ec6ea33c",
  "size_on_disk": 11945130882,
  "pruned": false,
  "softforks": [
    {
      "id": "bip34",
      "version": 2,
      "reject": {
        "status": false
      }
    },
    {
      "id": "bip66",
      "version": 3,
      "reject": {
        "status": false
      }
    },
    {
      "id": "bip65",
      "version": 4,
      "reject": {
        "status": false
      }
    }
  ],
  "bip9_softforks": {
    "csv": {
      "status": "defined",
      "startTime": 1462060800,
      "timeout": 1493596800,
      "since": 0
    },
    "segwit": {
      "status": "defined",
      "startTime": 1479168000,
      "timeout": 1510704000,
      "since": 0
    }
  },
  "warnings": ""
}
----

This command shows a lot of information about the blockchain. We can
note that we have downloaded and verified blocks up to height
`207546`. Bitcoin Core will downloaded block headers prior to the full
blocks in order to verify proof of work. This node has downloaded
headers up to height `549398`, which are all headers there is at this
time. Another interesting thing is the `initialblockdownload` field,
which is will remain `true` until the initial block download is
finished.

Keep this daemon running. You will get back to this daemon in <<app1>>
where we will give you a small tutorial on how to use `bitcoin-cli` to
examine the blockchain and to use your built-in wallet.

If you want to stop the node, issue the following command:

----
$ ./bitcoin-cli stop
----

You can start the node again whenever you like, and the node will
start where it left off.

=== Summary

We have replaced the last central point of authority, the shared
folder, with a peer to peer network. In a peer to peer network the
full nodes communicate directly with each other. Each node is
connected to several, potentially hundreds, other nodes. This makes it
extremely hard to prevent blocks and transactions from propagating the
network.

This chapter had two main parts:

1. How transactions and blocks flows through the network.
2. How new nodes join the network.

==== Part 1: Following a transaction

In the fist part, we followed a transaction through the system. It
started with John buying a cookie. His transaction got propagated
across the peer to peer network and to the cafe's wallet:

.Johns transaction propagates to all participants
image::{imagedir}/summary-tx-propagation.svg[{big-width}]

The cafe will almost immediately see that a transaction is incoming,
but it's not yet confirmed. The next stage is to mine the
block. Rashid is the lucky miner who finds the next block containing
John's transaction:

.Rashid's block containing John's transaction propagates to all participants
image::{imagedir}/summary-block-propagation.svg[{big-width}]

Rashid sends out the block to his peers who will relay the block to
their peers and so on until the block has reached the whole
network. Part of that propagation includes sending the block to
lightweight wallets. The lightweight wallets will request
`merkleblock` messages from the full node so that they don't have to
download the full block.

==== Part 2: Joining the network

Starting a new node involves fours steps.

.Selma goes through four steps to join the network
image::{imagedir}/running-a-full-node.svg[{full-width}]

1. Download and verify for example the Bitcoin Core software. Then start it.
2. Connect to other nodes
3. Download historic blocks
4. Enter normal operation

==== System changes

Our table of concept mappings between the cookie token system and
Bitcoin has become tiny:

[%autowidth]
.The shared folder is ditched in favor of a peer to peer network
|===
| Cookie Tokens | Bitcoin | Covered in

| 1 cookie token | 1 bitcoin | <<ch02>>
|===

Since there are no technical differences between the cookie token
system and the Bitcoin system, we will drop the cookie tokens and only
work with Bitcoin from now on.

This will be the final release of the cookie token system. Another
much more widely used system, Bitcoin, has taken the world by storm,
and we have decided to ditch the cookie token project. Enjoy the last
version.

[%autowidth,options="header"]
.Release notes, cookie tokens 8.0
|===
|Version|Feature|How

.2+|image:{commonimagedir}/new.png[role="gbnew"]*8.0*
| Censorship resistant. For real this time.
| The shared folder is replaced by a peer to peer network.

| Transaction broadcasting
| Transactions are broadcast to miners and others using the peer to
  peer network.

.2+|7.0
| Censorship resistant
| Multiple miners, "Lisas", enabled by proof of work

| Anyone can join the mining race
| Automatic difficulty adjustments

.3+|6.0
| Prevent Lisa from deleting transactions
| Signed blocks in a blockchain

| Fully validating nodes
| Keeps a copy of the whole blockchain

| Lightweight wallet saves data traffic
| Bloom filters and merkle proofs
|===

=== Exercises

==== Warm up

. Why is the shared folder a bad idea?

. What does it mean to relay a transaction or a block?

. What are `inv` messages used for?

. How does the full node decide what transactions to send to
lightweight wallets?

. How does a node notify a lightweight wallet about an incoming
pending transaction?

. Blocks are not sent in full to lightweight wallets. What part of
the block is always sent to the wallet?

. Why do the cafe send a very big bloom filter to their trusted node?

. What would a security conscious person do after downloading Bitcoin
Core, but before starting the software?

. What types of sources for peer addresses are available to a newly
started node?

. How would a full node know if any newly created blocks are available
for download when it's finished syncing?

==== Dig in

[start=11]
. the Bitcoin peer to peer network consists of the following nodes:
+
image::{imagedir}/ex-network-lie-to-lisa.svg[{half-width}]
+
Which node owners do you need to threaten to prevent Lisa from getting
any blocks but the ones Lisa creates herself?

[start=12]
. Suppose that Qi just received two transactions with transaction id:s
TXID~1~ and TXID~2~, and one block with block ID BKID. Now she wants
to inform Rashid about these new items. She doesn't know if Rashid
already knows about these items. What does she do.

. Suppose that the current Bitcoin network looks like this:
+
image::{imagedir}/ex-network-badly-connected.svg[{half-width}]
+
When Qi creates a valid 1MB block, the cafe will experience a delay
before it gets the block. What can the cafe do to improve the time it
takes to receive blocks from Qi?

[start=14]
. Suppose that you are running a full node and experience a power
outage for 18 minutes. When power comes back you start your node
again. During those 18 minutes, two blocks, B~1~ and B~2~, have been
created. Your latest block is B~0~. What will your node do after
reconnecting to the network? For simplicity, you can assume that no
new blocks are found during synchronization and you only have one
peer. Use the following table of message types to fill out the
template below:

[%autowidth]
|===
| type | data | purpose

| `block` | full block | sends a block to a peer
| `getheaders` | block id | Ask a peer for subsequent block headers after the given block id
| `getdata` | txid:s or block ID:s | Request data from a peer
| `headers` | list of headers | Sends a list of headers to a peer
|===

image::{imagedir}/ex-getblocks-power-outage.svg[{big-width}]

=== Recap

In this chapter you learned that

* The peer to peer network makes blocks censorship resistant
* A node connects to multiple peers to reduce their vulnerability for
  information hiding.
* The Bitcoin network protocol is the "language" nodes speak to
  communicate.
* Transactions are broadcast on the Bitcoin peer to peer network to
  reach both miners and the recipient of the money early.
* New nodes synchronize with the Bitcoin network to get up to date
  with the other nodes. Takes hours or days.
* Nodes do not need to stay on-line 24/7. They can drop out and come
  back and sync up the latest stuff.
* Signature verification can be skipped for older blocks to speed up
  initial synchronization. This is useful if you know that a specific
  block is valid.
