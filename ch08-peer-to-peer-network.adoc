[[ch08]]
== Peer to peer network - Ditch shared folder and email
:imagedir: {baseimagedir}/ch08
This chapter covers

* Removing last central authority, the shared folder
* Following a transaction in the peer to peer network
* Leaving the silly cookie tokens
* Bootstrapping the peer to peer network

Let's talk about the elephant in the room. The shared folder. All
blocks the miners produce must pass through the shared folder on their
way to other full nodes and miners. This chapter will remove the
shared folder and replace it with a peer to peer network. A peer to
peer network lets full nodes (including miners) send blocks directly
to each other. When nodes are allowed to talk directly to each other,
we no longer need a central point of authority for communication.

Another issue we haven't talked much about is how wallets send their
transactions via email to the miners. When a new miner joins the
system, all wallets need to update their list of miners. Not cool. Now
when we have this nice peer to peer network of nodes, wallets can use
this network to broadcasst their transactions to all miners without
knowing who or where they are.

At this point we no longer need the cookie token system to help us
understand Bitcoin. We will talk only about Bitcoin from now on. All
major topics has been introduced with the help of the cookie token
system, and there are practically no differences between the cookie
token system and Bitcoin.

When a node starts up for the first time, how does it find other nodes
to connect to? How is the network bootstrapped? This is a hard problem
to solve, and there are no perfect solutions. We will do our best to
provide a good enough solution.

=== The shared folder

The shared folder administrator is a central authority. He ultimately
gets to decide what blocks are allowed to be stored in the shared
folder. He also gets to decide who is allowed to read from the shared
folder and write to it.

.The shared folder is a central point of authority
image::{imagedir}/shared-folder-problem.svg[{big-width}]

So far we have just assumed that the shared folder administrator is a
totally neutral good guy, but what if he's not, of what if he's forced
by Acme Insurances to reject certain blocks. What's the point of proof
of work, if the system can be censored at the block level any way?
Simply put, we are not yet censorship resistant. There are other
"solutions" besides the shared folder, for example, a radio station
broadcasting the blocks via digital radio to all interested full
nodes, but then the radio station is the central point of
authority. As long as you have a single entity that can decide what
blocks to allow, we are not censorship resistant.

There is yet another problem with the shared folder. Imagine that a
block of size 1MB has been created by Rashid, and he has just
published it to the shared folder. Everyone watching the shared
folder, all full nodes, will download Rashid's block at the same
time. If we have 100 full nodes, the total amount of data we need to
send from the shared folder to the different nodes would be
100 MB. This will cause _block propagation_, the transfer of blocks
from the creator to all other nodes, to be terribly slow. The more
nodes, the slower the block propagation.

=== Create a peer to peer network

What if the full nodes and miners could talk directly to each other
instead of relying on the cental shared folder. They could send the
blocks directly to one another in a _peer to peer network_.

.In a peer to peer network, blocks are being passed on from one node to another. Much like how gossip spreads among people.
image::{imagedir}/basic-network.svg[{half-width}]

Think of the peer to peer network as a number of people. One person
does not know everyone else, but he may know 5 people. When one person
discovers something interesting, for example he finds a block, he
tells his 6 friends about it who in turn tell all their friends, and
so on until everybody knows about this new block. We call this type of
networks for _gossip networks_ for apparent reasons.

Blocks can no longer be easily stopped. A node can chose not to pass
on the information to its peers, "friends", but the friends are
connected to several other friends who will gladly pass the
information to them. A single node can't do much to censor
information. Suppose that Rashid finds a block and he wants to get
this block out to all nodes.

.If the cafe refuse to forward a block to Lisa, someone else will do it.
image::{imagedir}/nodes-tolerate-bad-actors.svg[{half-width}]

Rashid sends his block to Qi, Tom and Cafe. For some reason, the cafe
doesn't forward the block to Lisa. But Lisa have several friends in this
network. She is connected to Tom and Qi. Tom will tell Lisa about this
new block and send it to her. The cafe can't hide information from
Lisa as long as Lisa is well connected, or has many friends.

Now that we have this nice network, why don't we use it for wallets to
pass their transactions to the miners? Then they don't have to keep
track of miner email addresses anymore. The transactions will just be
broadcast over the peer to peer network and within seconds reach all
miners. Do you remember this from <<ch01>>?

****
Transactions travel the network as we described in <<_step_2_the_bitcoin_network>>.
image::{commonimagedir}/periscope.gif[]
****

.Transactions travel the peer to peer network just like blocks do. Wallets don't need to know the miners anymore.
image::{imagedir}/transactions-over-p2p-network.svg[{big-width}]

Lightweight wallets will become first class citizens of the Bitcoin
(and Cookie Token) network. The same thing goes here as for blocks; a
single node cannot hinder transactions from reaching the whole
network. A very pleasant effect of using the peer to peer network for
transactions is that the recipient of the transaction can be notified
that a transaction is "pending", or about to be confirmed. We will see
how this work a bit later.

=== How do peers talk?

// REMEMBER: DON'T GO INTO IMPLEMENTATION DETAILS.

[.gbinfo]
.TCP
****
When you open a web page on http://bitcoin.org, your web browser will
make a TCP connection to bitcoin.org and download a web page through
that connection and display it to you.
****

Let's have a look at how the communication between two peers
happen. We will look specifically at how Tom connects to Lisa and how
they communicate across their communication channel called a TCP
(Transmissin Control Protocol) connection.

.Tom and Lisa communicates over the Internet through a communication channel
image::{imagedir}/tom-lisa-communication.svg[{quart-width}]

Tom's node has heard about Lisa's node from another peer of his. He
got the IP (Internet Protocol) address and _port_ of Lisa's node from
that peer. Now he wants to connect to Lisa's node in order to
communicate with it. All computers on the internet has an IP
adreess. That is how one computer can send information to another
computer on the Internet. On top of the IP address, a computer program
that listens for incoming connections must listen on a specific _port_
number of that IP address. Lisas computer has the IP address
142.12.233.96 and runs a cookie token program that listens for
incoming connections on port 8333.

.Tom computer program sets up a TCP connection to Lisa's computer program. After this they can send and receive data between each other.
image::{imagedir}/tcp-connection.svg[{half-width}]

Tom's node connects to Lisa's node through the IP address
142.12.233.96 and port 8333. His node (computer program) starts by
sending a message to Lisa's computer saying that he wants to talk to a
computer program on Lisa's port 8333. Her computer knows that a
program is actually listening on port 8333, so it sends back a "Sure,
welcome" message. Tom's computer acknowledges that by sending back a
"Ok, cool. Let's talk..." message.

The node software on Tom's and Lisa's computers were not involved in
this handshake, it was carried out by their operating systems, for
example Linux, Windows or MacOS. When the handshake sequence is
finished the connection is handed over to the node software by the
operating system. Lisa's and Tom's nodes can now speak freely to each
other. Tom can send data to Lisa and Lisa can send data to Tom over
this communication channel.

=== The network protocol

Tom and Lisa can send and receive data over a communication channel. For example

.Lisa must be able to understand what tom writes on the channel.
image::{imagedir}/need-protocol.svg[{quart-width}]

but if Tom's node speaks a language that Lisa's node don't understand,
the communication will not be meaningful. The nodes need to have a
common language, a _protocol_.

The Cookie token network protocol defines a set of different message
types that are allowed. A typical message in the Cookie token (well,
Bitcoin) network is the `inv` message:

[.gbinfo]
.This is abstract
****
The real network messages does not look exactly like these, we provide
an abstract view of the messages. The exact format of the network
messages is out of scope of this book.
****

.A typical network message.
image::{imagedir}/protocol-inv-example.svg[{half-width}]

The `inv`, short for _inventory_, message is used by a node to inform
other nodes about something it has. In the example above, Tom's node
informs Lisa's node that Tom has three things to offer Lisa, two
transactions and a block. The message contains the id for each of the
items.

Let's follow a transaction throught the network from start to end, to
see what network messages are used. Suppose that John wants to buy a
cookie from the cafe.

We will assume that the peer to peer network is already set up. We
will come back to how the network is _bootstrapped_ later in this
chapter.

==== John sends the transaction

In <<_lightweight_wallets>>, we said that wallets are allowed to
connect to full nodes and get information about all block headers and
transactions concerning them, using bloom filters and merkle paths.

.Lightweight wallets communicate with nodes using the Bitcoin network protocol.
image::{imagedir}/spv-node-exchange.svg[{big-width}]

We didn't go into detail then how the communication actually
works. That communication use the same protocol as the nodes use when
they communicate with each other. The wallets and the full nodes
(including miners) all speak the same "language".

John's wallet is connected to Tom's node with a TCP connection. He
scans the payment URI from the cafe's wallet. John's wallet creates
and signs a transaction. You know the drill. Then it's time to send
the transaction to Tom's node:

.The transaction is sent to Tom's node using a TCP connection.
image::{imagedir}/john-sends-tx.svg[{half-width}]

This actually happens in a three-step process. John's wallet doesn't
just send the transaction unsolicited. He first informs Tom's node
that there is a transaction to be fetched.

.Tom's node is informed about John's transaction so that Tom can fetch it.
image::{imagedir}/tx-john-tom.svg[{half-width}]

The first message is an `inv` message as described in the previous
section. The `inv` is sent from John's wallet to Tom's full node. Tom
checks if he already has the transaction. He does not, because John's
wallet has just created it and hasn't sent it to anyone yet. Tom's
node wants to get this transaction so he requests it with a `getdata`
message that looks just like an `inv` message, but it has a different
meaning. `getdata` means "I want this stuff" while `inv` means "I have
this stuff".

John's wallet receives the `getdata` message and sends a `tx` message
containing the whole transaction to Tom's node. Tom will verify the
transaction and keep it. He will also pass this transaction on to his
network neighbors.

You may ask, why doesn't John's wallet simply send the whole
transaction immediately? Why go though the hassle with `inv` and
`getdata`? This will become clear later, but it's because nodes may
already have the transaction, so we save bandwidth by only sending
transaction hashes instead of whole transactions.

==== Tom forwards the transaction

If the transaction is valid, Tom's node will inform his neighbors
about this new transaction using an `inv` message, just like John did
when he informed Tom's node about the transaction.

.Tom forwards the transaction to his friends.
image::{imagedir}/tom-sends-tx.svg[{half-width}]

The process is exactly the same for these three message exchanges as
John used when he first sent the transaction to Tom. Lisa, Qi and
Rashid will get an `inv` message from Tom.

.Tom's node sends the transaction to Qi's node by using the familiar three-step process
image::{imagedir}/tx-tom-qi.svg[{half-width}]

When Lisa, Qi and Rashid has received the transaction, they too will
forward the transaction to their peers after they have verified the
transaction. Qi's and Rashid's nodes are a bit slower so it takes them
a while to verify the transaction, we will get back to them
later.

****
image::{imagedir}/2ndcol-lisa-sends-inv.svg[]
****

Lisa already knows that she received the transaction from Tom,
so she will not inform Tom's node with an `inv` message. But Lisa
doesn't know that Qi already has the transaction and she doesn't know
if the cafe has it. So she will send an `inv` to those nodes. The
cafe's node will send a `getdata`, because it has not yet seen this
transaction. But Qi's node is already aware of this transaction and
will not reply with anything.

.Lisa's node sends an inv to Qi's node, but Qi's node already has the transaction
image::{imagedir}/tx-lisa-qi.svg[{half-width}]

Now Qi has finished verifying the transaction. She knows that Lisa's
node has this transaction, so she doesn't have to send and `inv` to
Lisa's node. But she doesn't know if Rashid has it. So she sends an
`inv` to Rashid's node.

****
image::{imagedir}/2ndcol-rashid-sends-inv.svg[]
****

Rashid was the slowest node when verifying John's transaction so when
it's time for him to send an `inv` to his neighbors, he has already
received an `inv` from Qi's node. And he also knows from earlier that
Tom already has the transaction. He will just send an `inv` to the
cafe's node who will ignore the `inv`, because he already has the
transaction.

==== Cafe's lightweight wallet is notified

We said earlier that a good thing with letting transactions travel the
peer to peer network is that the recipient wallet can get a very quick
notification of the pending transaction. Now is the time to explore
this.

The cafe's full node has received the transaction and verified it. The
cafe also has a lightweight wallet on a mobile phone that it uses to
send and receive transactions. They are concerned with security, so
they have configured their lightweight wallet to only connect to their
own full node, their _trusted node_.

.The cafe's lightweight wallet has a TCP connection to their own full node
image::{imagedir}/cafe-connected-to-node.svg[{half-width}]

This is a common setup that gives the cafe the full security of a full
node combined with the flexibility and mobility of a lightweight
wallet. We described this setup in
<<_security_of_lightweight_wallets>>.

The Cafe's full node has just verified Johns transaction. Now it
want's to inform its neighbors about this new transaction. It is
connected to Lisa's node, Rashid's node and the cafe's lightweight
wallet. The full node already knows that Lisa's and Rashid's nodes
have this transaction so it doesn't send an `inv` to those two
nodes. The full node does not know that the wallet has the
transaction, but it will not simply send an `inv` message to the
wallet.

.Bloom filter
****
image::{imagedir}/2ndcol-bloom-filter.svg[]
****

The wallet is a lightweight wallet, which uses bloom filters described
in <<_bloom_filters_obfuscate_addresses>>. The full node will test the
transaction against the bloom filter, and if it matches, an `inv`
message will be sent to the wallet. If no match, it will not send an
`inv` message.

John's transaction is actually for the cafe, so the bloom filter will
match the transaction and the full node sends an `inv`. The wallet
will request the actual transaction using `getdata`:

.The cafe's wallet gets John's transaction from their trusted node after checking against the bloom filter.
image::{imagedir}/tx-cafenode-cafe.svg[{half-width}]

[.gbinfo]
.0-conf tx
****
If the cafe accepts a transaction that is not yet in the blockchain,
it means that he trusts that John

1. Has paid enough transaction fee
2. Will not be double spent
****

The wallet has now received the transaction. It can show a message to
the cafe owner that a transaction is "pending". The cafe owner has a
choice here: He can chose to trust that the transaction will get
confirmed eventually, or he can wait until the transaction is included
in a block. This time, the cafe decides that it needs to wait until
the transaction is included in a valid block. This brings us to the
next phase, including the transaction in a block in the blockchain.

==== Include the transaction in a block

Let's recall some of our miners in this system. At the end of
<<_mitigating_miner_centralization>> we had 10 different miners, but
let's go back in time and pretend that Qi, Tom, Lisa and Rashid are
the only miners in this system right now.

****
image::{imagedir}/2ndcol-rashid-sends-inv.svg[]
****

The transaction has reached all these miners during transaction
propagation. John's wallet used to send the transaction via email to
all miners. Now he just sends it to any of the full nodes, and the
transaction will propagate across the whole peer to peer
network. Miners can now chose to include Johns transaction in their
blocks they are mining. Suppose that the transaction includes a nice
transaction fee so that some or all miners are willing to include it.

.Rashid's block
****
image::{imagedir}/2ndcol-rashids-block-valid.svg[]
****

Let's say that Rashid is the next miner to find a valid proof of work
for his block, which happens to contain John's transaction. Now Rashid
wants to get his block to the other miners as quickly as possible to
minimize the risk of some other miner getting its block out before
Rashid's block.

He creates an `inv` message and sends it to all her peers: Tom, Cafe
and Qi. Rashid's peers will send back a `getdata` message, and Rashid will
reply with the actual block. The message exchange between Rashid and
Qi will look like this:

.Rashid's node sends Rashid's block to Qi's node
image::{imagedir}/block-rashid-qi.svg[{half-width}]

The pattern looks familiar, but this time the `inv` message contains a
block id instead of a transaction id. The actual block is sent in a
`block` message containing the full block. It is often not neccesary
to send all tansactions in the block because the recipient may already
have most of them. We use that to speed up the transmission of the
block using something called _compact blocks_. We will talk a bit
about compact blocks towards the end of this chapter.

****
image::{imagedir}/2ndcol-rashid-sends-block.svg[]
****

Let's continue the block propagation throughout the peer to peer
network. Rashid has sent his block to Tom, Cafe and Qi. Now, those
three nodes will verify the block and, if valid, send out `inv`
messages to all their peers that might not already have it. Qi and Tom
happens to send their `inv` messages at the same time, so they are not
aware that the other already has the block.

.All but Lisa has the block. Tom, Cafe and Qi send `inv` messages.
image::{imagedir}/tom-cafe-qi-sends-inv.svg[{half-width}]

As you can see, Tom and Qi has sent an inv to one another. That's not
a problem; since they both have the block, they will just ignore the
`inv` received from peers. Lisa will request the block from one of her
peers just like Qi requested the block from Rashid.

==== Notify wallets

Tom's node is connected to John's wallet so Tom sends an `inv` to
John. Likewise, The cafe's full node sends an `inv` to the cafe's
lightweight wallet. Tom's and the cafe's full nodes will not test the
block against the bloom filters in any way. They will just send the
`inv` unconditionally, but the lightweight wallets will not request
the full blocks.

As we recall from <<ch06>>, lightweight wallets don't download the
full blocks. Most of the time John's wallet is only interested in the
block headers so that they can verify the proof of work of the
blockchain. However, every now and then there are transactions that
are relevant to John's wallet in the blocks, and the wallet wants
proof that those transactions are actually included in the block. In
this particular block, Rashid's block, we have John's transaction as
the third, and last, transaction of the block.

.Tom sends a `merkleblock` containing a merkle proof that John's transaction is in the block.
image::{imagedir}/john-requests-merkleblock.svg[{half-width}]

John gets a block header, two transaction id:s, and merkle paths
connecting those transaction id:s to the merkle root in the block
header. The merkleblock message contains transaction id:s of the
transactions that match John's bloom filter. It does not contain the
whole transactions, because it is assumed that John's wallet already
has them. If the wallet would lack them for some reason, it may fetch
them from Tom's node using a single `getdata` message with the missing
txids. This is how the `merkleblock` will look:

.The merkleblock contains a block header, the number of transactions in the block, and a merkle proof
image::{imagedir}/verify-merkle-proof.svg[{half-width}]

John's wallet will verify that

* the block header is correct and has a valid proof of work
* the merkle root can be reconstructed using the number of
  transactions (3) and the merkle proof.

John's wallet is now sure that his transaction is contained in the new
block. The wallet can display a message to John saying "Your
transaction has 1 confirmation".

The cafe's lightweight wallet will also be notified in the same way:

.The cafe requests a `merkleblock` from their trusted full node
image::{imagedir}/cafewallet-requests-merkleblock.svg[{half-width}]

The café owner is security conscious. They want to be absolutely sure
that their lightweight wallet is not fooled by some rouge full node,
so they run their own full node on a computer that they control, a
_trusted node_. They tell their lightweight wallet to connect to only
their trusted node. This is almost as good as having a full node right
on the mobile phone, but with far less expensive data traffic.

The owner of the café feels comfortable handing over the cookie to
John now. John eats his cookie. Deal is done.

==== More confirmations

As time passes, more blocks will be mined by the miners. Those blocks
will all propagate the network and end up on all full nodes. The
lightweight wallets will get `merkleblock` versions to save bandwidth.

.As more blocks arrive, John's transaction becomes safer and safer
image::{imagedir}/further-confirmations.svg[{big-width}]

For each new block coming in, John's transaction will be buried under
more and more proof of work. This makes John's transaction harder and
harder to double spend. For each new block the transaction will get
one more confirmation.

=== Leaving the cookie token system behind

I don't think the cookie token system will help us understand Bitcoin
any more. It's time to let go of the cookie tokens and start talking
solely about Bitcoin from now on. We have developed the cookie token
system to a point where there are no differences from Bitcoin.

image::{imagedir}/cookie-token-evolution.svg[{full-width}]

=== Bootstrapping the network

The above scenario assumed that all nodes involved were already
connected to each other. But how does a new node start? How would it
find other nodes to connect to? How would it download the full
blockchain from the genesis block, block 0, and up to the latest
block? How does it know what the latest block is?

Let's sort it out.

Suppose that Selma wants to start her own full node. This is how it
would typically happen:

.Running a full node involves, dowloading and running, connect to other nodes, download old blocks and enter normal operation
image::{imagedir}/running-a-full-node.svg[{big-width}]

1. Selma downloads, verifies and starts the full node computer program
2. The computer program connects to some nodes
3. Selmas node downloads blocks from her peers
4. Selmas node enters normal mode of operation

==== Step 1 - Run the software

****
image::{imagedir}/step-1-run-software.svg[]
****

Selma needs a computer program to run a full node. The most commonly
used such program is _Bitcoin Core_. There are several others, for
example libbitcoin, bcoin, Bitcoinj and btcd. We will only focus on
Bitcoin Core, but you are encouraged to explore the others yourself.

To download Bitcoin Core, Selma visits their main web page and find a
link there. The problem is that Selma isn't sure that the program she
downloads is actally the version that the developers behind Bitcoin
Core released. Someone could have fooled Selma to download the program
from bitconcore.org instead of bitcoincore.org, or someone might have
hacked bitcoincore.org and replaced the downloadable files with
alternative programs.

The Bitcoin Core team therefore signs all released versions of their
program with a private key, let's call it the Bitcoin Core key. They
provide the signatures in a downloadable file, usually named
`SHA256SUMS.asc`. This file contains the hash value of the released
Bitcoin Core software and a signature that signs the contents of the
`SHA256SUMS.asc` file:

.The Bitcoin Core team signs the released program with their private key
image::{imagedir}/core-signs-program.svg[{half-width}]

Selma has downloaded both the program itself, in a file called
`bitcoin-0.15.0.1-x86_64-linux-gnu.tar.gz` and the signature file
called `SHA256SUMS.asc`. She can verify that the program is in fact
signed by the private key corresponding to the public key in the
signature file. But how can she know that this key is not bogus? How
does she know that this key belongs to the Bitcoin Core team?

This is a hard problem. Remember when Lisa used to sign blocks with
her private key? How would the full nodes verify that the blocks are
actually signed by Lisa? They used multiple sources to fetch Lisa's
public key, for example the bulletin board at the entrance of the
office, the company's intranet, and asking collegues. The same applies
here. You can download the key from http://bitcoin.org, ask a friend
you trust, and download the key from one of the many _key servers_ on
the Internet. Usually you shouldn't trust a single source, but use at
least two different sources. The key that currently is being used to
sign Bitcoin Core releases is named

 Wladimir J. van der Laan (Bitcoin Core binary release signing key) <laanwj@gmail.com>

and has the _fingerprint_

 01EA 5486 DE18 A882 D4C2  6845 90C8 019E 36C2 E964

Selma checks that the key used to sign the `SHA256SUMS.asc` file has
the exact same fingerprint as the key she trusts to be from the
Bitcoin Core team.

Next she must verify that the program has the same hash-value as
stated in `SHA256SUMS.asc`. It does match, which means that she can be
sure that the software she is about to run is authentic.

Selma starts the program on her computer.

==== Step 2 - Connect to nodes

****
image::{imagedir}/step-2-connect.svg[]
****

When Selma's full node program starts, it is not connected to any
other nodes. She's not part of the Bitcoin network yet. In this step
the node will try to find peers to connect to.

To connect to a peer, the full node needs the IP address and the TCP
port for that peer, for example

 IP: 142.12.233.96 port: 8333

An IP number and port are often written as

 142.12.233.96:8333

===== Finding initial peers

Where does Selma's node find initial addresses of other peers? There are
several sources available:

.Selma's full node has three different types of sources to find initial peers
image::{imagedir}/initial-peer-addresses.svg[{big-width}]

1. Configure the full node with custom peer addresses. Selma can get
an address and port by asking a friend who's running a full node.
2. Use the, Domain Name System, DNS, to lookup initial peer addresses
   to connect to.
3. Use peer addresses "hard coded" in the full node program itself.

It is very important that Selma's node doesn't initially connect to
just a single node. If that single node is malicious, you have no way
of knowing. If you connect to multiple nodes initially, you can verify
that they all are consistent with each other. If not, one or more
nodes are deliberately lying to you or they have themselvees been
fooled.

The last, third, option is used as a last resort. The preferred way to
find initial node addresses is to look them up in the DNS system. DNS
is a global name lookup system, used to lookup IP numbers from
computer names. For example, when you visit https://bitcoin.org with
your web browser, it will use DNS to lookup the IP number of the name
bitcoin.org. The Bitcoin Core software does the same. The names to
lookup are hard coded into Bitcoin Core, just like the hard coded IP
addresses and ports. There are several DNS seeds coded into the
software. A lookup of a DNS seed can return several IP addresses on
each lookup and every new lookup may return a different set of IP
addresses.

Note from the picture above that the DNS lookups do not return a port
number. The other two methods of finding initial peers usually include
a port number. The DNS response can only return IP addresses, so the
nodes on these IP addresses are assumed to listen on the default port
that Bitcoin Core listens on is `8333`.

===== Handshaking

****
image::{imagedir}/initial-connection-simple.svg[]
****

Suppose that Selmas node choses to connect to Qi's node and to
`47.196.31.246:8333`. She sets up a TCP connection to each of the two
nodes and sends an initial message to both of them on the new TCP
connections. Let's look at how she talks to Qi's node.

.Selma exchanges `version` message with Qi.
image::{imagedir}/version-selma-qi.svg[{half-width}]

The exchange, called a _handshake_, starts with Selma who sends a
`version` message to Qi. The handshake is used to agree on a protocol
version to use and tell each other what block heights they have. The
`version` message contains a lot of information not shown in the
figure, but the most essential stuff is there:

Protocol version:: The version of the network protocol, or "language",
that peers use to talk to each other. Selma and Qi will use version
70012 because that's the highest version Qi will understand.
User agent:: This is shown as Software "identification" in the figure
because "User agent" is a bit cryptic. It is used to hint the other
node what software you are running, but it can be anything.
height:: This is the height of the tip of the best chain that the
node has. This is used later in the synchronization step.

Some other useful information of the `version` message is

Services:: A list of features that this node supports. For example
bloom filtering used by lightweight clients.
My address:: The IP address and port of the node sending the `version`
message. Without it Qi wouldn't know what address to connect to if she
restarts and wants to reconnect to Selma's node.

When Qi's node recieves Selma's `version` message, she will reply with
her own `version` message. She will also send a `verack` message
immediately after the `version` message. The `verack` doesn't contain
any information, it is used to acknowledge to Selma that Qi has
received the `version` message.

As soon as Selma's node receives Qi's `version` message, she will
reply with a `verack` message. The handshake is done. She does the
same procedure with Rashid's node as well.

===== Finding peers' peers

When Selma's node is connected to Rashid's node it will ask that node
for other peer addresses to connect to. That way Selma will be able to
expand her set of peers.

.Selma asks her peers for more peer addresses to connect to.
image::{imagedir}/selma-finds-more-peers.svg[{half-width}]

Selma is only connected to two peers, Qi's node and Rashid's node. But
she thinks that she needs more nodes to connect to. Being connected to
only two nodes has some implications:

* Qi and Rashid can collude to hide transactions and blocks from Selma.
* Qi's node could break and she's left with only Rashid's node. Then
  Rashid can single handedly hide information from Selma.
* Both Qi's and Rashid's node could break in which case Selma is
  completely disconnected from the network until she connects to some
  other nodes via the initial peer lookup mechanisms.

This is how Selma asks Rashid for more peer addresses to connect to:

.Selma requests more peer addresses from Rashid's node. He responds with a bunch.
image::{imagedir}/addr-selma-rashid.svg[{half-width}]

[.gbinfo]
.Seed nodes
****
Nodes disconnect from seed nodes after getting an `addr` message, to
avoid overloading them. They are potentially seed nodes for many
nodes.
****

Selma sends a `getaddr` message to a peer, Rashid's node. Rashid
responds with a set of IP addresses and TCP ports that Selma can use
to connect to more peers. Rashid choses what addresses to send to
Selma, but it's usually the addresses that Rashid is already connected
to, and possibly some addresses that Rashid collected from his peers
but didn't use himself.

[.gbinfo]
.Connectivity
****
A typical Bitcoin full node has about 100 active connections to other
nodes at the same time.
****

Selma will connect to any number of the received addresses to increase
her _connectivity_. The more peers you are connected to, the more your
connectivity. A high degree of connectivity decreases the risk of
missing out on information due to misbehaving nodes.

==== Step 3 - Synchronize

****
image::{imagedir}/2ndcol-sync.svg[]
****

Now that Selma is well connected to, and part of, the Bitcoin network,
it's time for her to download and verify the blockchain.

Remember in step 2, when Selma received a `version` message from Qi's
node that stated `height=487224`? Selma will use that information now
to determine where to fetch historic blocks from.

Selma only has a single block, namely the genesis block. The genesis
block is hard coded in the Bitcoin Core software, so all nodes have
this block already when they start. Now she needs to download old
blocks from other nodes. She knows that Qi has all blocks up to height
`487224`. She has received version messages from four different nodes:

|===
| Node | Height

| Qi | 487224
| Rashid | 487224
| Cafe | 487225
| Tom | 487223
|===

She also wants all those blocks. She needs to download them all from
her peers and verify them before being able to verify newly created
blocks. This is because she has no idea of what the current UTXO set
looks like. To build the current UTXO set, she needs to start with an
empty UTXO set and go through all historic blocks from block 0, and
update the UTXO set with the information in the transactions in the
blocks.

Selma selects one of her peers, Tom, to download blocks from. Selma
knows that Tom has 487224 blocks, so he should be able to send Selma
the first three blocks after block 0. That is blocks at height 1, 2
and 3. This is how Selma's node requests the blocks from Tom's node:

.Selma downloads blocks from Tom by repeatedly sending a `getblocks` message with her latest block id
image::{imagedir}/getblocks-selma-tom.svg[{half-width}]

It starts with Selma who sends a `getblocks` message to Tom. The
`getblocks` message contains Selma's latest block id, which happens to
be the genesis block, block `0`.

Tom sends back an `inv` with a bunch of block ids coming immediately
after Selmas best block id. In this example Tom sends three hashes,
but in reality, Bitcoin Core would send a list of at most 500
block ids.

[.gbinfo]
.Initial download
****
Initial blockchain download takes several hours, even days, depending
on the performance of your hardware and Internet speed.
****

Selma receives the `inv` and requests the actual blocks based on the
list she got from Tom using a `getdata` message. Tom sends back the
actual blocks in `block` messages, one by one. When he has sent the
very last of those blocks, he will finish by sending an `inv`
containing Tom's current chain tip block id. This `inv` is used by
Selma to determine if there are more blocks to fetch from Tom. The
initial `version` message from Tom contained a `height` value of
487223. Selma could of course use that information to determine if
there are more blocks, but only in the beginning. At the time Selma
has downloaded all block up to height 487223, Tom has probably
received more fresh blocks from his peers. This is why Tom advertises
his current best chain tip after sending each batch of blocks.

As Selma receives blocks, she validates them, updates her UTXO set and
adds them to her own blockchain.

===== Validating early blocks

Transactions in old blocks, a month old or more, are already verified
by most nodes and buried under a tremendous amount of proof of
work. Given that so many nodes and miners have extended the old blocks
is a good indication that the signatures in the transactions of those
blocks are actually valid, so verifying them makes little sense. To
make initial blockchain download faster, Bitcoin Core will skip
signature verifications on the transactions in early blocks.

.Signatures of reasonably old transactions will not be verified to speed up initial block download
image::{imagedir}/skip-sigvalidation-of-early-blocks.svg[{half-width}]

Bitcoin Core ships with a preconfigured block id of a block a number
of weeks back from release date in the blockchain. For Bitcoin Core
0.15.0.1, that block is

 height: 477890
 hash: 0000000000000000003b9ce759c2a087d52abc4266f8f4ebd6d768b89defa50a

Which is about 8000 blocks back in the blockchain at realease
date. This is of course a configuration parameter and the above block
is just a default reasonable value. Selma could have changed this when
starting her node, or she could have verified with friends and other
sources she trusts that this block is in fact representing a "all
valid transactions blockchain". She could also have disabled the
feature to verify all transaction signatures since block 0.

After a long while, she is finally on the same page as the other
nodes. and ready to enter normal mode of operation.

==== Step 4 - Normal operation

This step is easy, because we have already descibed it in
<<_the_network_protocol>>. Selma enters normal mode of operation. From
now on she will participate in block propagation, transaction
propagation and verify every transaction and block coming in.

.Selma is finally an active part of the Bitcoin peer to peer network
image::{imagedir}/selma-full-blown-node.svg[{half-width}]

Selma is now a full blown full node.

=== The actual Bitcoin network

The Bitcoin peer to peer network is huge. There are tens of thousands
of full nodes and a lot of miners. 

==== Compact blocks


==== System grows

* More miners compete for the new cookie tokens
* Users starts to use the system more frequently

What happens to the transactions in the stale blocks? What happens to
Lisa's block's transactions when she must update to a new chain tip?

Add pruning to ch06
